/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapGetAndUpdate extends ((Int)=>(Unit)) {
def apply(x151:Int): Unit = {
val x152 = new HashMap[Int,Int](200)
val x153 = x152.table
val x154 = x153(0)
val x155 = x152.size
val x156 = x152.loadFactor
val x157 = x152.MAXIMUM_CAPACITY
val x158 = x152.threshold
val x159 = x153.length
val x7 = 1.hashCode
val x8 = x7.toLong
val x9 = x8 >>> 20
val x10 = x8 >>> 12
val x11 = x9 ^ x10
val x12 = x11 ^ x8
val x13 = x12 >>> 7
val x14 = x12 ^ x13
val x15 = x12 >>> 4
val x16 = x14 ^ x15
val x17 = x16.toInt
val x160 = x159 - 1
val x161 = x17 & x160
val x162 = x153(x161)
var x163: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x162
val x164 = x163
val x165 = x164 == null
if (x165) {
val x166 = new Entry(1, 2)
x153(x161) = x166
val x168 = x155 + 1
x152.size = x168

} else {
while ({
val x171 = x163
val x172 = x171.hasNext
val x178 = if (x172) {
val x173 = x163
val x174 = x173.key
val x175 = x174 != 1

x175
} else false

x178
}) {
val x180 = x163
val x181 = x180.next
x163 = x181
()
}
val x185 = x163
val x186 = x185.key
val x187 = x186 == 1
if (x187) {
val x188 = x185.value
x185.value = 2

} else {
val x191 = new Entry(1, 2)
val x192 = x185.next
val x193 = x185.hasNext
x185.next = x191
val x168 = x155 + 1
x152.size = x168

}

}
val x200 = x152.size
val x201 = x200 >= x158
if (x201) {
val x202 = x159 == x157
if (x202) {
val x62 = scala.Int.MaxValue
x152.threshold = x62

} else {
val x205 = 2 * x159
val x206 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x205)
var x207: Int = 0
val x234 = x205 - 1
while ({
val x208 = x207
val x209 = x153.length
val x210 = x208 < x209
x210
}) {
val x212 = x207
val x213 = x153(x212)
var x214: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x213
val x215 = x214
val x216 = x215 != null
if (x216) {
x153(x212) = null
while ({
val x218 = x214
val x219 = x218 != null
x219
}) {
val x221 = x214
val x222 = x221.key
val x236 = x221.next
val x223 = x222.hashCode
val x224 = x223.toLong
val x225 = x224 >>> 20
val x226 = x224 >>> 12
val x227 = x225 ^ x226
val x228 = x227 ^ x224
val x229 = x228 >>> 7
val x230 = x228 ^ x229
val x231 = x228 >>> 4
val x232 = x230 ^ x231
val x233 = x232.toInt
val x235 = x233 & x234
val x237 = x206(x235)
val x238 = x221.hasNext
x221.next = x237
x206(x235) = x221
x214 = x236
()
}

} else {
()
}
val x246 = x212 + 1
x207 = x246
()
}
x152.table = x206
val x251 = x156 * x205
val x252 = x251.asInstanceOf[Int]
x152.threshold = x252

}

} else {
()
}
val x258 = x152.table
val x259 = x258.length
val x260 = x259 - 1
val x261 = x17 & x260
val x262 = x258(x261)
var x263: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x262
val x264 = x263
val x265 = x264 == null
val x288 = if (x265) {
val x126 = None
x126
} else {
while ({
val x266 = x263
val x267 = x266.hasNext
val x273 = if (x267) {
val x268 = x263
val x269 = x268.key
val x270 = x269 != 1

x270
} else false

x273
}) {
val x275 = x263
val x276 = x275.next
x263 = x276
()
}
val x280 = x263
val x281 = x280.key
val x282 = x281 == 1
val x286 = if (x282) {
val x283 = x280.value
val x284 = Some(x283)
x284
} else {
val x126 = None
x126
}
x286
}
println(x288)
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
