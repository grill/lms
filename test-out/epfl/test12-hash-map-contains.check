/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapContains extends ((Int)=>(Unit)) {
def apply(x185:Int): Unit = {
val x186 = new HashMap[Int,Int](200)
val x187 = x186.table
val x188 = x187(0)
val x189 = x186.size
val x190 = x186.loadFactor
val x191 = x186.MAXIMUM_CAPACITY
val x192 = x186.threshold
val x193 = x187.length
val x8 = 1.hashCode
val x9 = x8.toLong
val x10 = x9 >>> 20
val x11 = x9 >>> 12
val x12 = x10 ^ x11
val x13 = x12 ^ x9
val x14 = x13 >>> 7
val x15 = x13 ^ x14
val x16 = x13 >>> 4
val x17 = x15 ^ x16
val x18 = x17.toInt
val x194 = x193 - 1
val x195 = x18 & x194
val x196 = x187(x195)
var x197: Entry[Int, Int] = x196
val x198 = x197
val x199 = x198 == null
if (x199) {
val x200 = new Entry(1, 2)
x187(x195) = x200
val x202 = x189 + 1
x186.size = x202

} else {
while ({
val x205 = x197
val x206 = x205.hasNext
val x212 = if (x206) {
val x207 = x197
val x208 = x207.key
val x209 = x208 != 1

x209
} else false

x212
}) {
val x214 = x197
val x215 = x214.next
x197 = x215
()
}
val x219 = x197
val x220 = x219.key
val x221 = x220 == 1
if (x221) {
val x222 = x219.value
x219.value = 2

} else {
val x225 = new Entry(1, 2)
val x226 = x219.next
val x227 = x219.hasNext
x219.next = x225
val x202 = x189 + 1
x186.size = x202

}

}
val x234 = x186.size
val x235 = x234 >= x192
if (x235) {
val x236 = x187.length
val x237 = x236 == x191
if (x237) {
val x63 = scala.Int.MaxValue
x186.threshold = x63

} else {
val x240 = 2 * x236
val x241 = new Array[Entry[Int, Int]](x240)
var x242: Int = 0
val x269 = x240 - 1
while ({
val x243 = x242
val x244 = x187.length
val x245 = x243 < x244
x245
}) {
val x247 = x242
val x248 = x187(x247)
var x249: Entry[Int, Int] = x248
val x250 = x249
val x251 = x250 != null
if (x251) {
x187(x247) = null
while ({
val x253 = x249
val x254 = x253 != null
x254
}) {
val x256 = x249
val x257 = x256.key
val x271 = x256.next
val x258 = x257.hashCode
val x259 = x258.toLong
val x260 = x259 >>> 20
val x261 = x259 >>> 12
val x262 = x260 ^ x261
val x263 = x262 ^ x259
val x264 = x263 >>> 7
val x265 = x263 ^ x264
val x266 = x263 >>> 4
val x267 = x265 ^ x266
val x268 = x267.toInt
val x270 = x268 & x269
val x272 = x241(x270)
val x273 = x256.hasNext
x256.next = x272
x241(x270) = x256
x249 = x271
()
}

} else {
()
}
val x281 = x247 + 1
x242 = x281
()
}
x186.table = x241
val x286 = x190 * x240
val x287 = x286.asInstanceOf[Int]
x186.threshold = x287

}

} else {
()
}
val x293 = x186.table
val x294 = x293.length
val x295 = x294 - 1
val x296 = x18 & x295
val x297 = x293(x296)
var x298: Entry[Int, Int] = x297
val x299 = x298
val x300 = x299 == null
val x319 = if (x300) {
false
} else {
while ({
val x301 = x298
val x302 = x301.hasNext
val x308 = if (x302) {
val x303 = x298
val x304 = x303.key
val x305 = x304 != 1

x305
} else false

x308
}) {
val x310 = x298
val x311 = x310.next
x298 = x311
()
}
val x315 = x298
val x316 = x315.key
val x317 = x316 == 1
x317
}
println(x319)
val x321 = x293.length
val x148 = 0.hashCode
val x149 = x148.toLong
val x150 = x149 >>> 20
val x151 = x149 >>> 12
val x152 = x150 ^ x151
val x153 = x152 ^ x149
val x154 = x153 >>> 7
val x155 = x153 ^ x154
val x156 = x153 >>> 4
val x157 = x155 ^ x156
val x158 = x157.toInt
val x322 = x321 - 1
val x323 = x158 & x322
val x324 = x293(x323)
var x325: Entry[Int, Int] = x324
val x326 = x325
val x327 = x326 == null
val x346 = if (x327) {
false
} else {
while ({
val x328 = x325
val x329 = x328.hasNext
val x335 = if (x329) {
val x330 = x325
val x331 = x330.key
val x332 = x331 != 0

x332
} else false

x335
}) {
val x337 = x325
val x338 = x337.next
x325 = x338
()
}
val x342 = x325
val x343 = x342.key
val x344 = x343 == 0
x344
}
println(x346)
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
