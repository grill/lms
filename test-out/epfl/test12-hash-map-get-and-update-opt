/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapGetAndUpdateOpt extends ((Int)=>(Unit)) {
def apply(x392:Int): Unit = {
val x393 = new HashMap[Int,Int](200)
val x394 = x393.table
val x395 = x394(0)
val x396 = x393.size
val x397 = x393.loadFactor
val x398 = x393.MAXIMUM_CAPACITY
val x399 = x393.threshold
val x400 = x394.length
val x7 = 1.hashCode
val x8 = x7.toLong
val x9 = x8 >>> 20
val x10 = x8 >>> 12
val x11 = x9 ^ x10
val x12 = x11 ^ x8
val x13 = x12 >>> 7
val x14 = x12 ^ x13
val x15 = x12 >>> 4
val x16 = x14 ^ x15
val x17 = x16.toInt
val x401 = x400 - 1
val x402 = x17 & x401
val x403 = x394(x402)
var x404: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x403
val x405 = x404
val x406 = x405 == null
if (x406) {
val x407 = new Entry(1, 2)
x394(x402) = x407
val x409 = x396 + 1
x393.size = x409

} else {
while ({
val x412 = x404
val x413 = x412.hasNext
val x419 = if (x413) {
val x414 = x404
val x415 = x414.key
val x416 = x415 != 1

x416
} else false

x419
}) {
val x421 = x404
val x422 = x421.next
x404 = x422
()
}
val x426 = x404
val x427 = x426.key
val x428 = x427 == 1
if (x428) {
val x429 = x426.value
x426.value = 2

} else {
val x432 = new Entry(1, 2)
val x433 = x426.next
val x434 = x426.hasNext
x426.next = x432
val x409 = x396 + 1
x393.size = x409

}

}
val x441 = x393.size
val x442 = x441 >= x399
if (x442) {
val x443 = x400 == x398
if (x443) {
val x62 = scala.Int.MaxValue
x393.threshold = x62

} else {
val x446 = 2 * x400
val x447 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x446)
var x448: Int = 0
val x475 = x446 - 1
while ({
val x449 = x448
val x450 = x394.length
val x451 = x449 < x450
x451
}) {
val x453 = x448
val x454 = x394(x453)
var x455: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x454
val x456 = x455
val x457 = x456 != null
if (x457) {
x394(x453) = null
while ({
val x459 = x455
val x460 = x459 != null
x460
}) {
val x462 = x455
val x463 = x462.key
val x477 = x462.next
val x464 = x463.hashCode
val x465 = x464.toLong
val x466 = x465 >>> 20
val x467 = x465 >>> 12
val x468 = x466 ^ x467
val x469 = x468 ^ x465
val x470 = x469 >>> 7
val x471 = x469 ^ x470
val x472 = x469 >>> 4
val x473 = x471 ^ x472
val x474 = x473.toInt
val x476 = x474 & x475
val x478 = x447(x476)
val x479 = x462.hasNext
x462.next = x478
x447(x476) = x462
x455 = x477
()
}

} else {
()
}
val x487 = x453 + 1
x448 = x487
()
}
x393.table = x447
val x492 = x397 * x446
val x493 = x492.asInstanceOf[Int]
x393.threshold = x493

}

} else {
()
}
val x499 = x393.table
val x500 = x499.length
val x119 = 2.hashCode
val x120 = x119.toLong
val x121 = x120 >>> 20
val x122 = x120 >>> 12
val x123 = x121 ^ x122
val x124 = x123 ^ x120
val x125 = x124 >>> 7
val x126 = x124 ^ x125
val x127 = x124 >>> 4
val x128 = x126 ^ x127
val x129 = x128.toInt
val x501 = x500 - 1
val x502 = x129 & x501
val x503 = x499(x502)
var x504: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x503
val x505 = x504
val x506 = x505 == null
if (x506) {
val x507 = new Entry(2, 3)
x499(x502) = x507
val x509 = x441 + 1
x393.size = x509

} else {
while ({
val x512 = x504
val x513 = x512.hasNext
val x519 = if (x513) {
val x514 = x504
val x515 = x514.key
val x516 = x515 != 2

x516
} else false

x519
}) {
val x521 = x504
val x522 = x521.next
x504 = x522
()
}
val x526 = x504
val x527 = x526.key
val x528 = x527 == 2
if (x528) {
val x529 = x526.value
x526.value = 3

} else {
val x532 = new Entry(2, 3)
val x533 = x526.next
val x534 = x526.hasNext
x526.next = x532
val x509 = x441 + 1
x393.size = x509

}

}
val x541 = x393.threshold
val x542 = x393.size
val x543 = x542 >= x541
if (x543) {
val x544 = x500 == x398
if (x544) {
val x62 = scala.Int.MaxValue
x393.threshold = x62

} else {
val x547 = 2 * x500
val x548 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x547)
var x549: Int = 0
val x576 = x547 - 1
while ({
val x550 = x549
val x551 = x499.length
val x552 = x550 < x551
x552
}) {
val x554 = x549
val x555 = x499(x554)
var x556: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x555
val x557 = x556
val x558 = x557 != null
if (x558) {
x499(x554) = null
while ({
val x560 = x556
val x561 = x560 != null
x561
}) {
val x563 = x556
val x564 = x563.key
val x578 = x563.next
val x565 = x564.hashCode
val x566 = x565.toLong
val x567 = x566 >>> 20
val x568 = x566 >>> 12
val x569 = x567 ^ x568
val x570 = x569 ^ x566
val x571 = x570 >>> 7
val x572 = x570 ^ x571
val x573 = x570 >>> 4
val x574 = x572 ^ x573
val x575 = x574.toInt
val x577 = x575 & x576
val x579 = x548(x577)
val x580 = x563.hasNext
x563.next = x579
x548(x577) = x563
x556 = x578
()
}

} else {
()
}
val x588 = x554 + 1
x549 = x588
()
}
x393.table = x548
val x593 = x397 * x547
val x594 = x593.asInstanceOf[Int]
x393.threshold = x594

}

} else {
()
}
val x600 = x393.table
val x601 = x600.length
val x602 = x601 - 1
val x603 = x17 & x602
val x604 = x600(x603)
var x605: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x604
val x606 = x605
val x607 = x606 == null
val x630 = if (x607) {
val x238 = None
x238
} else {
while ({
val x608 = x605
val x609 = x608.hasNext
val x615 = if (x609) {
val x610 = x605
val x611 = x610.key
val x612 = x611 != 1

x612
} else false

x615
}) {
val x617 = x605
val x618 = x617.next
x605 = x618
()
}
val x622 = x605
val x623 = x622.key
val x624 = x623 == 1
val x628 = if (x624) {
val x625 = x622.value
val x626 = Some(x625)
x626
} else {
val x238 = None
x238
}
x628
}
val x631 = x630.get
var x633: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x604
val x634 = x633
val x635 = x634 == null
if (x635) {
val x632 = x631 + 1
val x636 = new Entry(1, x632)
x600(x603) = x636
val x638 = x542 + 1
x393.size = x638

} else {
while ({
val x641 = x633
val x642 = x641.hasNext
val x648 = if (x642) {
val x643 = x633
val x644 = x643.key
val x645 = x644 != 1

x645
} else false

x648
}) {
val x650 = x633
val x651 = x650.next
x633 = x651
()
}
val x655 = x633
val x656 = x655.key
val x657 = x656 == 1
if (x657) {
val x658 = x655.value
val x632 = x631 + 1
x655.value = x632

} else {
val x632 = x631 + 1
val x661 = new Entry(1, x632)
val x662 = x655.next
val x663 = x655.hasNext
x655.next = x661
val x638 = x542 + 1
x393.size = x638

}

}
val x670 = x393.threshold
val x671 = x393.size
val x672 = x671 >= x670
if (x672) {
val x673 = x601 == x398
if (x673) {
val x62 = scala.Int.MaxValue
x393.threshold = x62

} else {
val x676 = 2 * x601
val x677 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x676)
var x678: Int = 0
val x705 = x676 - 1
while ({
val x679 = x678
val x680 = x600.length
val x681 = x679 < x680
x681
}) {
val x683 = x678
val x684 = x600(x683)
var x685: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x684
val x686 = x685
val x687 = x686 != null
if (x687) {
x600(x683) = null
while ({
val x689 = x685
val x690 = x689 != null
x690
}) {
val x692 = x685
val x693 = x692.key
val x707 = x692.next
val x694 = x693.hashCode
val x695 = x694.toLong
val x696 = x695 >>> 20
val x697 = x695 >>> 12
val x698 = x696 ^ x697
val x699 = x698 ^ x695
val x700 = x699 >>> 7
val x701 = x699 ^ x700
val x702 = x699 >>> 4
val x703 = x701 ^ x702
val x704 = x703.toInt
val x706 = x704 & x705
val x708 = x677(x706)
val x709 = x692.hasNext
x692.next = x708
x677(x706) = x692
x685 = x707
()
}

} else {
()
}
val x717 = x683 + 1
x678 = x717
()
}
x393.table = x677
val x722 = x397 * x676
val x723 = x722.asInstanceOf[Int]
x393.threshold = x723

}

} else {
()
}
val x729 = x393.table
val x730 = x729.length
val x731 = x730 - 1
val x732 = x17 & x731
val x733 = x729(x732)
var x734: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x733
val x735 = x734
val x736 = x735 == null
val x759 = if (x736) {
val x238 = None
x238
} else {
while ({
val x737 = x734
val x738 = x737.hasNext
val x744 = if (x738) {
val x739 = x734
val x740 = x739.key
val x741 = x740 != 1

x741
} else false

x744
}) {
val x746 = x734
val x747 = x746.next
x734 = x747
()
}
val x751 = x734
val x752 = x751.key
val x753 = x752 == 1
val x757 = if (x753) {
val x754 = x751.value
val x755 = Some(x754)
x755
} else {
val x238 = None
x238
}
x757
}
println(x759)
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
