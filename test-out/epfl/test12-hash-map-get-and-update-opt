/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapGetAndUpdateOpt extends ((Int)=>(Unit)) {
def apply(x391:Int): Unit = {
val x392 = new HashMap[Int,Int](200)
val x393 = x392.table
val x394 = x392.size
val x395 = x392.loadFactor
val x396 = x392.MAXIMUM_CAPACITY
val x397 = x392.threshold
val x398 = x393.length
val x6 = 1.hashCode
val x7 = x6.toLong
val x8 = x7 >>> 20
val x9 = x7 >>> 12
val x10 = x8 ^ x9
val x11 = x10 ^ x7
val x12 = x11 >>> 7
val x13 = x11 ^ x12
val x14 = x11 >>> 4
val x15 = x13 ^ x14
val x16 = x15.toInt
val x399 = x398 - 1
val x400 = x16 & x399
val x401 = x393(x400)
var x402 = x401
val x403 = x402
val x404 = x403 == null
if (x404) {
val x405 = new Entry(1, 2)
x393(x400) = x405
val x407 = x394 + 1
x392.size = x407

} else {
while ({
val x410 = x402
val x411 = x410.hasNext
val x417 = if (x411) {
val x412 = x402
val x413 = x412.key
val x414 = x413 != 1

x414
} else false

x417
}) {
val x419 = x402
val x420 = x419.next
x402 = x420
()
}
val x424 = x402
val x425 = x424.key
val x426 = x425 == 1
if (x426) {
val x427 = x424.value
x424.value = 2

} else {
val x430 = new Entry(1, 2)
val x431 = x424.next
val x432 = x424.hasNext
x424.next = x430
val x407 = x394 + 1
x392.size = x407

}

}
val x439 = x392.size
val x440 = x439 >= x397
if (x440) {
val x441 = x398 == x396
if (x441) {
val x61 = scala.Int.MaxValue
x392.threshold = x61

} else {
val x444 = 2 * x398
val x445 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x444)
var x446 = 0
val x473 = x444 - 1
while ({
val x447 = x446
val x448 = x393.length
val x449 = x447 < x448
x449
}) {
val x451 = x446
val x452 = x393(x451)
var x453 = x452
val x454 = x453
val x455 = x454 != null
if (x455) {
x393(x451) = null
while ({
val x457 = x453
val x458 = x457 != null
x458
}) {
val x460 = x453
val x461 = x460.key
val x475 = x460.next
val x462 = x461.hashCode
val x463 = x462.toLong
val x464 = x463 >>> 20
val x465 = x463 >>> 12
val x466 = x464 ^ x465
val x467 = x466 ^ x463
val x468 = x467 >>> 7
val x469 = x467 ^ x468
val x470 = x467 >>> 4
val x471 = x469 ^ x470
val x472 = x471.toInt
val x474 = x472 & x473
val x476 = x445(x474)
val x477 = x460.hasNext
x460.next = x476
x445(x474) = x460
x453 = x475
()
}

} else {
()
}
val x485 = x451 + 1
x446 = x485
()
}
x392.table = x445
val x490 = x395 * x444
val x491 = x490.asInstanceOf[Int]
x392.threshold = x491

}

} else {
()
}
val x497 = x392.table
val x498 = x497.length
val x118 = 2.hashCode
val x119 = x118.toLong
val x120 = x119 >>> 20
val x121 = x119 >>> 12
val x122 = x120 ^ x121
val x123 = x122 ^ x119
val x124 = x123 >>> 7
val x125 = x123 ^ x124
val x126 = x123 >>> 4
val x127 = x125 ^ x126
val x128 = x127.toInt
val x499 = x498 - 1
val x500 = x128 & x499
val x501 = x497(x500)
var x502 = x501
val x503 = x502
val x504 = x503 == null
if (x504) {
val x505 = new Entry(2, 3)
x497(x500) = x505
val x507 = x439 + 1
x392.size = x507

} else {
while ({
val x510 = x502
val x511 = x510.hasNext
val x517 = if (x511) {
val x512 = x502
val x513 = x512.key
val x514 = x513 != 2

x514
} else false

x517
}) {
val x519 = x502
val x520 = x519.next
x502 = x520
()
}
val x524 = x502
val x525 = x524.key
val x526 = x525 == 2
if (x526) {
val x527 = x524.value
x524.value = 3

} else {
val x530 = new Entry(2, 3)
val x531 = x524.next
val x532 = x524.hasNext
x524.next = x530
val x507 = x439 + 1
x392.size = x507

}

}
val x539 = x392.threshold
val x540 = x392.size
val x541 = x540 >= x539
if (x541) {
val x542 = x498 == x396
if (x542) {
val x61 = scala.Int.MaxValue
x392.threshold = x61

} else {
val x545 = 2 * x498
val x546 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x545)
var x547 = 0
val x574 = x545 - 1
while ({
val x548 = x547
val x549 = x497.length
val x550 = x548 < x549
x550
}) {
val x552 = x547
val x553 = x497(x552)
var x554 = x553
val x555 = x554
val x556 = x555 != null
if (x556) {
x497(x552) = null
while ({
val x558 = x554
val x559 = x558 != null
x559
}) {
val x561 = x554
val x562 = x561.key
val x576 = x561.next
val x563 = x562.hashCode
val x564 = x563.toLong
val x565 = x564 >>> 20
val x566 = x564 >>> 12
val x567 = x565 ^ x566
val x568 = x567 ^ x564
val x569 = x568 >>> 7
val x570 = x568 ^ x569
val x571 = x568 >>> 4
val x572 = x570 ^ x571
val x573 = x572.toInt
val x575 = x573 & x574
val x577 = x546(x575)
val x578 = x561.hasNext
x561.next = x577
x546(x575) = x561
x554 = x576
()
}

} else {
()
}
val x586 = x552 + 1
x547 = x586
()
}
x392.table = x546
val x591 = x395 * x545
val x592 = x591.asInstanceOf[Int]
x392.threshold = x592

}

} else {
()
}
val x598 = x392.table
val x599 = x598.length
val x600 = x599 - 1
val x601 = x16 & x600
val x602 = x598(x601)
var x603 = x602
val x604 = x603
val x605 = x604 == null
val x628 = if (x605) {
val x237 = None
x237
} else {
while ({
val x606 = x603
val x607 = x606.hasNext
val x613 = if (x607) {
val x608 = x603
val x609 = x608.key
val x610 = x609 != 1

x610
} else false

x613
}) {
val x615 = x603
val x616 = x615.next
x603 = x616
()
}
val x620 = x603
val x621 = x620.key
val x622 = x621 == 1
val x626 = if (x622) {
val x623 = x620.value
val x624 = Some(x623)
x624
} else {
val x237 = None
x237
}
x626
}
val x629 = x628.get
var x631 = x602
val x632 = x631
val x633 = x632 == null
if (x633) {
val x630 = x629 + 1
val x634 = new Entry(1, x630)
x598(x601) = x634
val x636 = x540 + 1
x392.size = x636

} else {
while ({
val x639 = x631
val x640 = x639.hasNext
val x646 = if (x640) {
val x641 = x631
val x642 = x641.key
val x643 = x642 != 1

x643
} else false

x646
}) {
val x648 = x631
val x649 = x648.next
x631 = x649
()
}
val x653 = x631
val x654 = x653.key
val x655 = x654 == 1
if (x655) {
val x656 = x653.value
val x630 = x629 + 1
x653.value = x630

} else {
val x630 = x629 + 1
val x659 = new Entry(1, x630)
val x660 = x653.next
val x661 = x653.hasNext
x653.next = x659
val x636 = x540 + 1
x392.size = x636

}

}
val x668 = x392.threshold
val x669 = x392.size
val x670 = x669 >= x668
if (x670) {
val x671 = x599 == x396
if (x671) {
val x61 = scala.Int.MaxValue
x392.threshold = x61

} else {
val x674 = 2 * x599
val x675 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x674)
var x676 = 0
val x703 = x674 - 1
while ({
val x677 = x676
val x678 = x598.length
val x679 = x677 < x678
x679
}) {
val x681 = x676
val x682 = x598(x681)
var x683 = x682
val x684 = x683
val x685 = x684 != null
if (x685) {
x598(x681) = null
while ({
val x687 = x683
val x688 = x687 != null
x688
}) {
val x690 = x683
val x691 = x690.key
val x705 = x690.next
val x692 = x691.hashCode
val x693 = x692.toLong
val x694 = x693 >>> 20
val x695 = x693 >>> 12
val x696 = x694 ^ x695
val x697 = x696 ^ x693
val x698 = x697 >>> 7
val x699 = x697 ^ x698
val x700 = x697 >>> 4
val x701 = x699 ^ x700
val x702 = x701.toInt
val x704 = x702 & x703
val x706 = x675(x704)
val x707 = x690.hasNext
x690.next = x706
x675(x704) = x690
x683 = x705
()
}

} else {
()
}
val x715 = x681 + 1
x676 = x715
()
}
x392.table = x675
val x720 = x395 * x674
val x721 = x720.asInstanceOf[Int]
x392.threshold = x721

}

} else {
()
}
val x727 = x392.table
val x728 = x727.length
val x729 = x728 - 1
val x730 = x16 & x729
val x731 = x727(x730)
var x732 = x731
val x733 = x732
val x734 = x733 == null
val x757 = if (x734) {
val x237 = None
x237
} else {
while ({
val x735 = x732
val x736 = x735.hasNext
val x742 = if (x736) {
val x737 = x732
val x738 = x737.key
val x739 = x738 != 1

x739
} else false

x742
}) {
val x744 = x732
val x745 = x744.next
x732 = x745
()
}
val x749 = x732
val x750 = x749.key
val x751 = x750 == 1
val x755 = if (x751) {
val x752 = x749.value
val x753 = Some(x752)
x753
} else {
val x237 = None
x237
}
x755
}
println(x757)
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
