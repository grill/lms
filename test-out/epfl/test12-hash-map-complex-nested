/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapComplexNested extends ((Int)=>(Unit)) {
def apply(x1187:Int): Unit = {
val x1188 = new HashMap[Int,scala.virtualization.lms.epfl.test12.HashMap[Int, Int]](1)
val x1189 = x1188.table
val x1190 = x1189(0)
val x1191 = x1188.size
val x1192 = x1188.loadFactor
val x1193 = x1188.MAXIMUM_CAPACITY
val x1194 = x1188.threshold
val x1195 = new HashMap[Int,Int](1)
val x1196 = x1195.table
val x1197 = x1196(0)
val x1198 = x1195.size
val x1199 = x1195.loadFactor
val x1200 = x1195.MAXIMUM_CAPACITY
val x1201 = x1195.threshold
val x1202 = new HashMap[Int,Int](1)
val x1203 = x1202.table
val x1204 = x1203(0)
val x1205 = x1202.size
val x1206 = x1202.loadFactor
val x1207 = x1202.MAXIMUM_CAPACITY
val x1208 = x1202.threshold
val x1209 = x1189.length
val x21 = 1.hashCode
val x22 = x21.toLong
val x23 = x22 >>> 20
val x24 = x22 >>> 12
val x25 = x23 ^ x24
val x26 = x25 ^ x22
val x27 = x26 >>> 7
val x28 = x26 ^ x27
val x29 = x26 >>> 4
val x30 = x28 ^ x29
val x31 = x30.toInt
val x1210 = x1209 - 1
val x1211 = x31 & x1210
val x1212 = x1189(x1211)
var x1213: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1212
val x1214 = x1213
val x1215 = x1214 == null
val x1218 = x1191 + 1
if (x1215) {
val x1216 = new Entry(1, x1195)
x1189(x1211) = x1216
x1188.size = x1218

} else {
while ({
val x1221 = x1213
val x1222 = x1221.hasNext
val x1228 = if (x1222) {
val x1223 = x1213
val x1224 = x1223.key
val x1225 = x1224 != 1

x1225
} else false

x1228
}) {
val x1230 = x1213
val x1231 = x1230.next
x1213 = x1231
()
}
val x1235 = x1213
val x1236 = x1235.key
val x1237 = x1236 == 1
if (x1237) {
val x1238 = x1235.value
x1235.value = x1195

} else {
val x1241 = new Entry(1, x1195)
val x1242 = x1235.next
val x1243 = x1235.hasNext
x1235.next = x1241
x1188.size = x1218

}

}
val x1250 = x1188.size
val x1251 = x1250 >= x1194
val x77 = scala.Int.MaxValue
if (x1251) {
val x1252 = x1189.length
val x1253 = x1252 == x1193
if (x1253) {
x1188.threshold = x77

} else {
val x1256 = 2 * x1252
val x1257 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x1256)
var x1258: Int = 0
val x1285 = x1256 - 1
while ({
val x1259 = x1258
val x1260 = x1189.length
val x1261 = x1259 < x1260
x1261
}) {
val x1263 = x1258
val x1264 = x1189(x1263)
var x1265: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1264
val x1266 = x1265
val x1267 = x1266 != null
if (x1267) {
x1189(x1263) = null
while ({
val x1269 = x1265
val x1270 = x1269 != null
x1270
}) {
val x1272 = x1265
val x1273 = x1272.key
val x1287 = x1272.next
val x1274 = x1273.hashCode
val x1275 = x1274.toLong
val x1276 = x1275 >>> 20
val x1277 = x1275 >>> 12
val x1278 = x1276 ^ x1277
val x1279 = x1278 ^ x1275
val x1280 = x1279 >>> 7
val x1281 = x1279 ^ x1280
val x1282 = x1279 >>> 4
val x1283 = x1281 ^ x1282
val x1284 = x1283.toInt
val x1286 = x1284 & x1285
val x1288 = x1257(x1286)
val x1289 = x1272.hasNext
x1272.next = x1288
x1257(x1286) = x1272
x1265 = x1287
()
}

} else {
()
}
val x1297 = x1263 + 1
x1258 = x1297
()
}
x1188.table = x1257
val x1302 = x1192 * x1256
val x1303 = x1302.asInstanceOf[Int]
x1188.threshold = x1303

}

} else {
()
}
val x1309 = x1188.table
val x1310 = x1309.length
val x134 = 2.hashCode
val x135 = x134.toLong
val x136 = x135 >>> 20
val x137 = x135 >>> 12
val x138 = x136 ^ x137
val x139 = x138 ^ x135
val x140 = x139 >>> 7
val x141 = x139 ^ x140
val x142 = x139 >>> 4
val x143 = x141 ^ x142
val x144 = x143.toInt
val x1311 = x1310 - 1
val x1312 = x144 & x1311
val x1313 = x1309(x1312)
var x1314: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1313
val x1315 = x1314
val x1316 = x1315 == null
val x1319 = x1250 + 1
if (x1316) {
val x1317 = new Entry(2, x1202)
x1309(x1312) = x1317
x1188.size = x1319

} else {
while ({
val x1322 = x1314
val x1323 = x1322.hasNext
val x1329 = if (x1323) {
val x1324 = x1314
val x1325 = x1324.key
val x1326 = x1325 != 2

x1326
} else false

x1329
}) {
val x1331 = x1314
val x1332 = x1331.next
x1314 = x1332
()
}
val x1336 = x1314
val x1337 = x1336.key
val x1338 = x1337 == 2
if (x1338) {
val x1339 = x1336.value
x1336.value = x1202

} else {
val x1342 = new Entry(2, x1202)
val x1343 = x1336.next
val x1344 = x1336.hasNext
x1336.next = x1342
x1188.size = x1319

}

}
val x1351 = x1188.threshold
val x1352 = x1188.size
val x1353 = x1352 >= x1351
if (x1353) {
val x1354 = x1309.length
val x1355 = x1354 == x1193
if (x1355) {
x1188.threshold = x77

} else {
val x1358 = 2 * x1354
val x1359 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x1358)
var x1360: Int = 0
val x1387 = x1358 - 1
while ({
val x1361 = x1360
val x1362 = x1309.length
val x1363 = x1361 < x1362
x1363
}) {
val x1365 = x1360
val x1366 = x1309(x1365)
var x1367: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1366
val x1368 = x1367
val x1369 = x1368 != null
if (x1369) {
x1309(x1365) = null
while ({
val x1371 = x1367
val x1372 = x1371 != null
x1372
}) {
val x1374 = x1367
val x1375 = x1374.key
val x1389 = x1374.next
val x1376 = x1375.hashCode
val x1377 = x1376.toLong
val x1378 = x1377 >>> 20
val x1379 = x1377 >>> 12
val x1380 = x1378 ^ x1379
val x1381 = x1380 ^ x1377
val x1382 = x1381 >>> 7
val x1383 = x1381 ^ x1382
val x1384 = x1381 >>> 4
val x1385 = x1383 ^ x1384
val x1386 = x1385.toInt
val x1388 = x1386 & x1387
val x1390 = x1359(x1388)
val x1391 = x1374.hasNext
x1374.next = x1390
x1359(x1388) = x1374
x1367 = x1389
()
}

} else {
()
}
val x1399 = x1365 + 1
x1360 = x1399
()
}
x1188.table = x1359
val x1404 = x1192 * x1358
val x1405 = x1404.asInstanceOf[Int]
x1188.threshold = x1405

}

} else {
()
}
val x1411 = x1196.length
val x1412 = x1411 - 1
val x1413 = x31 & x1412
val x1414 = x1196(x1413)
var x1415: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1414
val x1416 = x1415
val x1417 = x1416 == null
if (x1417) {
val x1418 = new Entry(1, 1)
x1196(x1413) = x1418
val x1420 = x1198 + 1
x1195.size = x1420

} else {
while ({
val x1423 = x1415
val x1424 = x1423.hasNext
val x1430 = if (x1424) {
val x1425 = x1415
val x1426 = x1425.key
val x1427 = x1426 != 1

x1427
} else false

x1430
}) {
val x1432 = x1415
val x1433 = x1432.next
x1415 = x1433
()
}
val x1437 = x1415
val x1438 = x1437.key
val x1439 = x1438 == 1
if (x1439) {
val x1440 = x1437.value
x1437.value = 1

} else {
val x1443 = new Entry(1, 1)
val x1444 = x1437.next
val x1445 = x1437.hasNext
x1437.next = x1443
val x1420 = x1198 + 1
x1195.size = x1420

}

}
val x1452 = x1195.size
val x1453 = x1452 >= x1201
if (x1453) {
val x1454 = x1196.length
val x1455 = x1454 == x1200
if (x1455) {
x1195.threshold = x77

} else {
val x1458 = 2 * x1454
val x1459 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1458)
var x1460: Int = 0
val x1487 = x1458 - 1
while ({
val x1461 = x1460
val x1462 = x1196.length
val x1463 = x1461 < x1462
x1463
}) {
val x1465 = x1460
val x1466 = x1196(x1465)
var x1467: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1466
val x1468 = x1467
val x1469 = x1468 != null
if (x1469) {
x1196(x1465) = null
while ({
val x1471 = x1467
val x1472 = x1471 != null
x1472
}) {
val x1474 = x1467
val x1475 = x1474.key
val x1489 = x1474.next
val x1476 = x1475.hashCode
val x1477 = x1476.toLong
val x1478 = x1477 >>> 20
val x1479 = x1477 >>> 12
val x1480 = x1478 ^ x1479
val x1481 = x1480 ^ x1477
val x1482 = x1481 >>> 7
val x1483 = x1481 ^ x1482
val x1484 = x1481 >>> 4
val x1485 = x1483 ^ x1484
val x1486 = x1485.toInt
val x1488 = x1486 & x1487
val x1490 = x1459(x1488)
val x1491 = x1474.hasNext
x1474.next = x1490
x1459(x1488) = x1474
x1467 = x1489
()
}

} else {
()
}
val x1499 = x1465 + 1
x1460 = x1499
()
}
x1195.table = x1459
val x1504 = x1199 * x1458
val x1505 = x1504.asInstanceOf[Int]
x1195.threshold = x1505

}

} else {
()
}
val x1511 = x1188.table
val x1512 = x1511.length
val x1513 = x1512 - 1
val x1514 = x31 & x1513
val x1515 = x1511(x1514)
var x1516: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1515
val x1517 = x1516
val x1518 = x1517 == null
val x354 = None
val x1541 = if (x1518) {
x354
} else {
while ({
val x1519 = x1516
val x1520 = x1519.hasNext
val x1526 = if (x1520) {
val x1521 = x1516
val x1522 = x1521.key
val x1523 = x1522 != 1

x1523
} else false

x1526
}) {
val x1528 = x1516
val x1529 = x1528.next
x1516 = x1529
()
}
val x1533 = x1516
val x1534 = x1533.key
val x1535 = x1534 == 1
val x1539 = if (x1535) {
val x1536 = x1533.value
val x1537 = Some(x1536)
x1537
} else {
x354
}
x1539
}
val x1542 = x1541.get
val x1543 = x1542.table
val x1544 = x1543.length
val x1545 = x1544 - 1
val x1546 = x31 & x1545
val x1547 = x1543(x1546)
var x1548: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1547
val x1549 = x1542.size
val x1550 = x1548
val x1551 = x1550 == null
val x1554 = x1549 + 1
if (x1551) {
val x1552 = new Entry(1, 2)
x1543(x1546) = x1552
x1542.size = x1554

} else {
while ({
val x1557 = x1548
val x1558 = x1557.hasNext
val x1564 = if (x1558) {
val x1559 = x1548
val x1560 = x1559.key
val x1561 = x1560 != 1

x1561
} else false

x1564
}) {
val x1566 = x1548
val x1567 = x1566.next
x1548 = x1567
()
}
val x1571 = x1548
val x1572 = x1571.key
val x1573 = x1572 == 1
if (x1573) {
val x1574 = x1571.value
x1571.value = 2

} else {
val x1577 = new Entry(1, 2)
val x1578 = x1571.next
val x1579 = x1571.hasNext
x1571.next = x1577
x1542.size = x1554

}

}
val x1586 = x1542.threshold
val x1587 = x1542.MAXIMUM_CAPACITY
val x1588 = x1542.size
val x1589 = x1588 >= x1586
if (x1589) {
val x1590 = x1543.length
val x1591 = x1590 == x1587
if (x1591) {
x1542.threshold = x77

} else {
val x1594 = 2 * x1590
val x1595 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1594)
var x1596: Int = 0
val x1623 = x1594 - 1
while ({
val x1597 = x1596
val x1598 = x1543.length
val x1599 = x1597 < x1598
x1599
}) {
val x1601 = x1596
val x1602 = x1543(x1601)
var x1603: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1602
val x1604 = x1603
val x1605 = x1604 != null
if (x1605) {
x1543(x1601) = null
while ({
val x1607 = x1603
val x1608 = x1607 != null
x1608
}) {
val x1610 = x1603
val x1611 = x1610.key
val x1625 = x1610.next
val x1612 = x1611.hashCode
val x1613 = x1612.toLong
val x1614 = x1613 >>> 20
val x1615 = x1613 >>> 12
val x1616 = x1614 ^ x1615
val x1617 = x1616 ^ x1613
val x1618 = x1617 >>> 7
val x1619 = x1617 ^ x1618
val x1620 = x1617 >>> 4
val x1621 = x1619 ^ x1620
val x1622 = x1621.toInt
val x1624 = x1622 & x1623
val x1626 = x1595(x1624)
val x1627 = x1610.hasNext
x1610.next = x1626
x1595(x1624) = x1610
x1603 = x1625
()
}

} else {
()
}
val x1635 = x1601 + 1
x1596 = x1635
()
}
x1542.table = x1595
val x1640 = x1542.loadFactor
val x1641 = x1640 * x1594
val x1642 = x1641.asInstanceOf[Int]
x1542.threshold = x1642

}

} else {
()
}
var x1648: Int = 0
val x485 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]]
var x1649: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x485
val x499 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.Entry[Int, Int]]
while ({
val x1650 = x1648
val x1651 = x1511.length
val x1652 = x1650 < x1651
x1652
}) {
val x1654 = x1648
val x1655 = x1511(x1654)
val x1656 = x1655 != null
if (x1656) {
x1649 = x1655
println(x1655)
val x1659 = x1655.value
val x1660 = x1659.table
var x1661: Int = 0
var x1662: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x499
while ({
val x1663 = x1661
val x1664 = x1660.length
val x1665 = x1663 < x1664
x1665
}) {
val x1667 = x1661
val x1668 = x1660(x1667)
val x1669 = x1668 != null
if (x1669) {
x1662 = x1668
println(x1668)
while ({
val x1672 = x1662
val x1673 = x1672.hasNext
x1673
}) {
val x1675 = x1662
val x1676 = x1675.next
x1662 = x1676
val x1678 = x1662
println(x1678)

}

} else {
()
}
val x1684 = x1667 + 1
x1661 = x1684
()
}
while ({
val x1688 = x1649
val x1689 = x1688.hasNext
x1689
}) {
val x1691 = x1649
val x1692 = x1691.next
x1649 = x1692
val x1694 = x1649
println(x1694)
val x1696 = x1694.value
val x1697 = x1696.table
var x1698: Int = 0
var x1699: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x499
while ({
val x1700 = x1698
val x1701 = x1697.length
val x1702 = x1700 < x1701
x1702
}) {
val x1704 = x1698
val x1705 = x1697(x1704)
val x1706 = x1705 != null
if (x1706) {
x1699 = x1705
println(x1705)
while ({
val x1709 = x1699
val x1710 = x1709.hasNext
x1710
}) {
val x1712 = x1699
val x1713 = x1712.next
x1699 = x1713
val x1715 = x1699
println(x1715)

}

} else {
()
}
val x1721 = x1704 + 1
x1698 = x1721
()
}

}

} else {
()
}
val x1729 = x1654 + 1
x1648 = x1729
()
}
var x1733: Int = 0
var x1734: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x485
val x582 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]
while ({
val x1735 = x1733
val x1736 = x1511.length
val x1737 = x1735 < x1736
x1737
}) {
val x1739 = x1733
val x1740 = x1511(x1739)
val x1741 = x1740 != null
if (x1741) {
x1734 = x1740
val x1743 = x1740.key
val x1744 = x1188.table
val x1756 = x1744.length
val x1745 = x1743.hashCode
val x1746 = x1745.toLong
val x1747 = x1746 >>> 20
val x1748 = x1746 >>> 12
val x1749 = x1747 ^ x1748
val x1750 = x1749 ^ x1746
val x1751 = x1750 >>> 7
val x1752 = x1750 ^ x1751
val x1753 = x1750 >>> 4
val x1754 = x1752 ^ x1753
val x1755 = x1754.toInt
val x1757 = x1756 - 1
val x1758 = x1755 & x1757
val x1759 = x1744(x1758)
var x1760: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1759
val x1761 = x1188.size
val x1762 = x1760
val x1763 = x1762 == null
if (x1763) {
val x1764 = new Entry(x1743, x582)
x1744(x1758) = x1764
val x1766 = x1761 + 1
x1188.size = x1766

} else {
while ({
val x1769 = x1760
val x1770 = x1769.hasNext
val x1776 = if (x1770) {
val x1771 = x1760
val x1772 = x1771.key
val x1773 = x1772 != x1743

x1773
} else false

x1776
}) {
val x1778 = x1760
val x1779 = x1778.next
x1760 = x1779
()
}
val x1783 = x1760
val x1784 = x1783.key
val x1785 = x1784 == x1743
if (x1785) {
val x1786 = x1783.value
x1783.value = x582

} else {
val x1789 = new Entry(x1743, x582)
val x1790 = x1783.next
val x1791 = x1783.hasNext
x1783.next = x1789
val x1766 = x1761 + 1
x1188.size = x1766

}

}
val x1798 = x1188.threshold
val x1799 = x1188.MAXIMUM_CAPACITY
val x1800 = x1188.size
val x1801 = x1800 >= x1798
if (x1801) {
val x1802 = x1744.length
val x1803 = x1802 == x1799
if (x1803) {
x1188.threshold = x77

} else {
val x1806 = 2 * x1802
val x1807 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x1806)
var x1808: Int = 0
val x1835 = x1806 - 1
while ({
val x1809 = x1808
val x1810 = x1744.length
val x1811 = x1809 < x1810
x1811
}) {
val x1813 = x1808
val x1814 = x1744(x1813)
var x1815: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1814
val x1816 = x1815
val x1817 = x1816 != null
if (x1817) {
x1744(x1813) = null
while ({
val x1819 = x1815
val x1820 = x1819 != null
x1820
}) {
val x1822 = x1815
val x1823 = x1822.key
val x1837 = x1822.next
val x1824 = x1823.hashCode
val x1825 = x1824.toLong
val x1826 = x1825 >>> 20
val x1827 = x1825 >>> 12
val x1828 = x1826 ^ x1827
val x1829 = x1828 ^ x1825
val x1830 = x1829 >>> 7
val x1831 = x1829 ^ x1830
val x1832 = x1829 >>> 4
val x1833 = x1831 ^ x1832
val x1834 = x1833.toInt
val x1836 = x1834 & x1835
val x1838 = x1807(x1836)
val x1839 = x1822.hasNext
x1822.next = x1838
x1807(x1836) = x1822
x1815 = x1837
()
}

} else {
()
}
val x1847 = x1813 + 1
x1808 = x1847
()
}
x1188.table = x1807
val x1852 = x1188.loadFactor
val x1853 = x1852 * x1806
val x1854 = x1853.asInstanceOf[Int]
x1188.threshold = x1854

}

} else {
()
}
while ({
val x1860 = x1734
val x1861 = x1860.hasNext
x1861
}) {
val x1863 = x1734
val x1864 = x1863.next
x1734 = x1864
val x1866 = x1734
val x1867 = x1866.key
val x1868 = x1188.table
val x1880 = x1868.length
val x1869 = x1867.hashCode
val x1870 = x1869.toLong
val x1871 = x1870 >>> 20
val x1872 = x1870 >>> 12
val x1873 = x1871 ^ x1872
val x1874 = x1873 ^ x1870
val x1875 = x1874 >>> 7
val x1876 = x1874 ^ x1875
val x1877 = x1874 >>> 4
val x1878 = x1876 ^ x1877
val x1879 = x1878.toInt
val x1881 = x1880 - 1
val x1882 = x1879 & x1881
val x1883 = x1868(x1882)
var x1884: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1883
val x1885 = x1188.size
val x1886 = x1884
val x1887 = x1886 == null
if (x1887) {
val x1888 = new Entry(x1867, x582)
x1868(x1882) = x1888
val x1890 = x1885 + 1
x1188.size = x1890

} else {
while ({
val x1893 = x1884
val x1894 = x1893.hasNext
val x1900 = if (x1894) {
val x1895 = x1884
val x1896 = x1895.key
val x1897 = x1896 != x1867

x1897
} else false

x1900
}) {
val x1902 = x1884
val x1903 = x1902.next
x1884 = x1903
()
}
val x1907 = x1884
val x1908 = x1907.key
val x1909 = x1908 == x1867
if (x1909) {
val x1910 = x1907.value
x1907.value = x582

} else {
val x1913 = new Entry(x1867, x582)
val x1914 = x1907.next
val x1915 = x1907.hasNext
x1907.next = x1913
val x1890 = x1885 + 1
x1188.size = x1890

}

}
val x1922 = x1188.threshold
val x1923 = x1188.MAXIMUM_CAPACITY
val x1924 = x1188.size
val x1925 = x1924 >= x1922
if (x1925) {
val x1926 = x1868.length
val x1927 = x1926 == x1923
if (x1927) {
x1188.threshold = x77

} else {
val x1930 = 2 * x1926
val x1931 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x1930)
var x1932: Int = 0
val x1959 = x1930 - 1
while ({
val x1933 = x1932
val x1934 = x1868.length
val x1935 = x1933 < x1934
x1935
}) {
val x1937 = x1932
val x1938 = x1868(x1937)
var x1939: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x1938
val x1940 = x1939
val x1941 = x1940 != null
if (x1941) {
x1868(x1937) = null
while ({
val x1943 = x1939
val x1944 = x1943 != null
x1944
}) {
val x1946 = x1939
val x1947 = x1946.key
val x1961 = x1946.next
val x1948 = x1947.hashCode
val x1949 = x1948.toLong
val x1950 = x1949 >>> 20
val x1951 = x1949 >>> 12
val x1952 = x1950 ^ x1951
val x1953 = x1952 ^ x1949
val x1954 = x1953 >>> 7
val x1955 = x1953 ^ x1954
val x1956 = x1953 >>> 4
val x1957 = x1955 ^ x1956
val x1958 = x1957.toInt
val x1960 = x1958 & x1959
val x1962 = x1931(x1960)
val x1963 = x1946.hasNext
x1946.next = x1962
x1931(x1960) = x1946
x1939 = x1961
()
}

} else {
()
}
val x1971 = x1937 + 1
x1932 = x1971
()
}
x1188.table = x1931
val x1976 = x1188.loadFactor
val x1977 = x1976 * x1930
val x1978 = x1977.asInstanceOf[Int]
x1188.threshold = x1978

}

} else {
()
}

}

} else {
()
}
val x1988 = x1739 + 1
x1733 = x1988
()
}
var x1992: Int = 0
var x1993: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x485
while ({
val x1994 = x1992
val x1995 = x1511.length
val x1996 = x1994 < x1995
x1996
}) {
val x1998 = x1992
val x1999 = x1511(x1998)
val x2000 = x1999 != null
if (x2000) {
x1993 = x1999
println(x1999)
while ({
val x2003 = x1993
val x2004 = x2003.hasNext
x2004
}) {
val x2006 = x1993
val x2007 = x2006.next
x1993 = x2007
val x2009 = x1993
println(x2009)

}

} else {
()
}
val x2015 = x1998 + 1
x1992 = x2015
()
}
var x2019: Int = 0
var x2020: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x485
while ({
val x2021 = x2019
val x2022 = x1511.length
val x2023 = x2021 < x2022
x2023
}) {
val x2025 = x2019
val x2026 = x1511(x2025)
val x2027 = x2026 != null
if (x2027) {
x2020 = x2026
val x2029 = x2026.key
val x2030 = x1188.table
val x2042 = x2030.length
var x2045: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x485
val x2031 = x2029.hashCode
val x2032 = x2031.toLong
val x2033 = x2032 >>> 20
val x2034 = x2032 >>> 12
val x2035 = x2033 ^ x2034
val x2036 = x2035 ^ x2032
val x2037 = x2036 >>> 7
val x2038 = x2036 ^ x2037
val x2039 = x2036 >>> 4
val x2040 = x2038 ^ x2039
val x2041 = x2040.toInt
val x2043 = x2042 - 1
val x2044 = x2041 & x2043
val x2046 = x2030(x2044)
var x2047: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x2046
val x2048 = x2047
val x2049 = x2048 != null
if (x2049) {
while ({
val x2050 = x2047
val x2051 = x2050.hasNext
val x2057 = if (x2051) {
val x2052 = x2047
val x2053 = x2052.key
val x2054 = x2053 != x2029

x2054
} else false

x2057
}) {
val x2059 = x2047
x2045 = x2059
val x2061 = x2059.next
x2047 = x2061
()
}
val x2065 = x2045
val x2066 = x2065 == null
if (x2066) {
x2030(x2044) = null

} else {
val x2069 = x2047
val x2070 = x2069.key
val x2071 = x2070 == x2029
if (x2071) {
val x2072 = x2069.next
val x2073 = x2065.next
val x2074 = x2065.hasNext
x2065.next = x2072

} else {
()
}

}

} else {
()
}
while ({
val x2082 = x2020
val x2083 = x2082.hasNext
x2083
}) {
val x2085 = x2020
val x2086 = x2085.next
x2020 = x2086
val x2088 = x2020
val x2089 = x2088.key
val x2090 = x1188.table
val x2102 = x2090.length
var x2105: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x485
val x2091 = x2089.hashCode
val x2092 = x2091.toLong
val x2093 = x2092 >>> 20
val x2094 = x2092 >>> 12
val x2095 = x2093 ^ x2094
val x2096 = x2095 ^ x2092
val x2097 = x2096 >>> 7
val x2098 = x2096 ^ x2097
val x2099 = x2096 >>> 4
val x2100 = x2098 ^ x2099
val x2101 = x2100.toInt
val x2103 = x2102 - 1
val x2104 = x2101 & x2103
val x2106 = x2090(x2104)
var x2107: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x2106
val x2108 = x2107
val x2109 = x2108 != null
if (x2109) {
while ({
val x2110 = x2107
val x2111 = x2110.hasNext
val x2117 = if (x2111) {
val x2112 = x2107
val x2113 = x2112.key
val x2114 = x2113 != x2089

x2114
} else false

x2117
}) {
val x2119 = x2107
x2105 = x2119
val x2121 = x2119.next
x2107 = x2121
()
}
val x2125 = x2105
val x2126 = x2125 == null
if (x2126) {
x2090(x2104) = null

} else {
val x2129 = x2107
val x2130 = x2129.key
val x2131 = x2130 == x2089
if (x2131) {
val x2132 = x2129.next
val x2133 = x2125.next
val x2134 = x2125.hasNext
x2125.next = x2132

} else {
()
}

}

} else {
()
}

}

} else {
()
}
val x2146 = x2025 + 1
x2019 = x2146
()
}
val x2150 = x1511.length
val x989 = 3.hashCode
val x990 = x989.toLong
val x991 = x990 >>> 20
val x992 = x990 >>> 12
val x993 = x991 ^ x992
val x994 = x993 ^ x990
val x995 = x994 >>> 7
val x996 = x994 ^ x995
val x997 = x994 >>> 4
val x998 = x996 ^ x997
val x999 = x998.toInt
val x2151 = x2150 - 1
val x2152 = x999 & x2151
val x2153 = x1511(x2152)
var x2154: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x2153
val x2155 = x2154
val x2156 = x2155 == null
val x2159 = x1352 + 1
if (x2156) {
val x2157 = new Entry(3, x1195)
x1511(x2152) = x2157
x1188.size = x2159

} else {
while ({
val x2162 = x2154
val x2163 = x2162.hasNext
val x2169 = if (x2163) {
val x2164 = x2154
val x2165 = x2164.key
val x2166 = x2165 != 3

x2166
} else false

x2169
}) {
val x2171 = x2154
val x2172 = x2171.next
x2154 = x2172
()
}
val x2176 = x2154
val x2177 = x2176.key
val x2178 = x2177 == 3
if (x2178) {
val x2179 = x2176.value
x2176.value = x1195

} else {
val x2182 = new Entry(3, x1195)
val x2183 = x2176.next
val x2184 = x2176.hasNext
x2176.next = x2182
x1188.size = x2159

}

}
val x2191 = x1188.threshold
val x2192 = x1188.size
val x2193 = x2192 >= x2191
if (x2193) {
val x2194 = x1511.length
val x2195 = x2194 == x1193
if (x2195) {
x1188.threshold = x77

} else {
val x2198 = 2 * x2194
val x2199 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x2198)
var x2200: Int = 0
val x2227 = x2198 - 1
while ({
val x2201 = x2200
val x2202 = x1511.length
val x2203 = x2201 < x2202
x2203
}) {
val x2205 = x2200
val x2206 = x1511(x2205)
var x2207: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x2206
val x2208 = x2207
val x2209 = x2208 != null
if (x2209) {
x1511(x2205) = null
while ({
val x2211 = x2207
val x2212 = x2211 != null
x2212
}) {
val x2214 = x2207
val x2215 = x2214.key
val x2229 = x2214.next
val x2216 = x2215.hashCode
val x2217 = x2216.toLong
val x2218 = x2217 >>> 20
val x2219 = x2217 >>> 12
val x2220 = x2218 ^ x2219
val x2221 = x2220 ^ x2217
val x2222 = x2221 >>> 7
val x2223 = x2221 ^ x2222
val x2224 = x2221 >>> 4
val x2225 = x2223 ^ x2224
val x2226 = x2225.toInt
val x2228 = x2226 & x2227
val x2230 = x2199(x2228)
val x2231 = x2214.hasNext
x2214.next = x2230
x2199(x2228) = x2214
x2207 = x2229
()
}

} else {
()
}
val x2239 = x2205 + 1
x2200 = x2239
()
}
x1188.table = x2199
val x2244 = x1192 * x2198
val x2245 = x2244.asInstanceOf[Int]
x1188.threshold = x2245

}

} else {
()
}
val x2251 = x1188.table
var x2252: Int = 0
var x2253: scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]] = x485
while ({
val x2254 = x2252
val x2255 = x2251.length
val x2256 = x2254 < x2255
x2256
}) {
val x2258 = x2252
val x2259 = x2251(x2258)
val x2260 = x2259 != null
if (x2260) {
x2253 = x2259
println(x2259)
val x2263 = x2259.value
val x2264 = x2263.table
var x2265: Int = 0
var x2266: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x499
while ({
val x2267 = x2265
val x2268 = x2264.length
val x2269 = x2267 < x2268
x2269
}) {
val x2271 = x2265
val x2272 = x2264(x2271)
val x2273 = x2272 != null
if (x2273) {
x2266 = x2272
println(x2272)
while ({
val x2276 = x2266
val x2277 = x2276.hasNext
x2277
}) {
val x2279 = x2266
val x2280 = x2279.next
x2266 = x2280
val x2282 = x2266
println(x2282)

}

} else {
()
}
val x2288 = x2271 + 1
x2265 = x2288
()
}
while ({
val x2292 = x2253
val x2293 = x2292.hasNext
x2293
}) {
val x2295 = x2253
val x2296 = x2295.next
x2253 = x2296
val x2298 = x2253
println(x2298)
val x2300 = x2298.value
val x2301 = x2300.table
var x2302: Int = 0
var x2303: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x499
while ({
val x2304 = x2302
val x2305 = x2301.length
val x2306 = x2304 < x2305
x2306
}) {
val x2308 = x2302
val x2309 = x2301(x2308)
val x2310 = x2309 != null
if (x2310) {
x2303 = x2309
println(x2309)
while ({
val x2313 = x2303
val x2314 = x2313.hasNext
x2314
}) {
val x2316 = x2303
val x2317 = x2316.next
x2303 = x2317
val x2319 = x2303
println(x2319)

}

} else {
()
}
val x2325 = x2308 + 1
x2302 = x2325
()
}

}

} else {
()
}
val x2333 = x2258 + 1
x2252 = x2333
()
}
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
