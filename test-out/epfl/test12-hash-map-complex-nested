/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapComplexNested extends ((Int)=>(Unit)) {
def apply(x1175:Int): Unit = {
val x1176 = new HashMap[Int,scala.virtualization.lms.epfl.test12.HashMap[Int, Int]](1)
val x1177 = x1176.table
val x1178 = x1176.size
val x1179 = x1176.loadFactor
val x1180 = x1176.MAXIMUM_CAPACITY
val x1181 = x1176.threshold
val x1182 = new HashMap[Int,Int](1)
val x1183 = x1182.table
val x1184 = x1182.size
val x1185 = x1182.loadFactor
val x1186 = x1182.MAXIMUM_CAPACITY
val x1187 = x1182.threshold
val x1188 = new HashMap[Int,Int](1)
val x1189 = x1188.table
val x1190 = x1188.size
val x1191 = x1188.loadFactor
val x1192 = x1188.MAXIMUM_CAPACITY
val x1193 = x1188.threshold
val x1194 = x1177.length
val x18 = 1.hashCode
val x19 = x18.toLong
val x20 = x19 >>> 20
val x21 = x19 >>> 12
val x22 = x20 ^ x21
val x23 = x22 ^ x19
val x24 = x23 >>> 7
val x25 = x23 ^ x24
val x26 = x23 >>> 4
val x27 = x25 ^ x26
val x28 = x27.toInt
val x1195 = x1194 - 1
val x1196 = x28 & x1195
val x1197 = x1177(x1196)
var x1198 = x1197
val x1199 = x1198
val x1200 = x1199 == null
val x1203 = x1178 + 1
if (x1200) {
val x1201 = new Entry(1, x1182)
x1177(x1196) = x1201
x1176.size = x1203

} else {
while ({
val x1206 = x1198
val x1207 = x1206.hasNext
val x1213 = if (x1207) {
val x1208 = x1198
val x1209 = x1208.key
val x1210 = x1209 != 1

x1210
} else false

x1213
}) {
val x1215 = x1198
val x1216 = x1215.next
x1198 = x1216
()
}
val x1220 = x1198
val x1221 = x1220.key
val x1222 = x1221 == 1
if (x1222) {
val x1223 = x1220.value
x1220.value = x1182

} else {
val x1226 = new Entry(1, x1182)
val x1227 = x1220.next
val x1228 = x1220.hasNext
x1220.next = x1226
x1176.size = x1203

}

}
val x1235 = x1176.size
val x1236 = x1235 >= x1181
val x1237 = x1194 == x1180
val x73 = scala.Int.MaxValue
val x1240 = 2 * x1194
val x1269 = x1240 - 1
val x1286 = x1179 * x1240
val x1287 = x1286.asInstanceOf[Int]
if (x1236) {
if (x1237) {
x1176.threshold = x73

} else {
val x1241 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x1240)
var x1242 = 0
while ({
val x1243 = x1242
val x1244 = x1177.length
val x1245 = x1243 < x1244
x1245
}) {
val x1247 = x1242
val x1248 = x1177(x1247)
var x1249 = x1248
val x1250 = x1249
val x1251 = x1250 != null
if (x1251) {
x1177(x1247) = null
while ({
val x1253 = x1249
val x1254 = x1253 != null
x1254
}) {
val x1256 = x1249
val x1257 = x1256.key
val x1271 = x1256.next
val x1258 = x1257.hashCode
val x1259 = x1258.toLong
val x1260 = x1259 >>> 20
val x1261 = x1259 >>> 12
val x1262 = x1260 ^ x1261
val x1263 = x1262 ^ x1259
val x1264 = x1263 >>> 7
val x1265 = x1263 ^ x1264
val x1266 = x1263 >>> 4
val x1267 = x1265 ^ x1266
val x1268 = x1267.toInt
val x1270 = x1268 & x1269
val x1272 = x1241(x1270)
val x1273 = x1256.hasNext
x1256.next = x1272
x1241(x1270) = x1256
x1249 = x1271
()
}

} else {
()
}
val x1281 = x1247 + 1
x1242 = x1281
()
}
x1176.table = x1241
x1176.threshold = x1287

}

} else {
()
}
val x1293 = x1176.table
val x1294 = x1293.length
val x130 = 2.hashCode
val x131 = x130.toLong
val x132 = x131 >>> 20
val x133 = x131 >>> 12
val x134 = x132 ^ x133
val x135 = x134 ^ x131
val x136 = x135 >>> 7
val x137 = x135 ^ x136
val x138 = x135 >>> 4
val x139 = x137 ^ x138
val x140 = x139.toInt
val x1295 = x1294 - 1
val x1296 = x140 & x1295
val x1297 = x1293(x1296)
var x1298 = x1297
val x1299 = x1298
val x1300 = x1299 == null
val x1303 = x1235 + 1
if (x1300) {
val x1301 = new Entry(2, x1188)
x1293(x1296) = x1301
x1176.size = x1303

} else {
while ({
val x1306 = x1298
val x1307 = x1306.hasNext
val x1313 = if (x1307) {
val x1308 = x1298
val x1309 = x1308.key
val x1310 = x1309 != 2

x1310
} else false

x1313
}) {
val x1315 = x1298
val x1316 = x1315.next
x1298 = x1316
()
}
val x1320 = x1298
val x1321 = x1320.key
val x1322 = x1321 == 2
if (x1322) {
val x1323 = x1320.value
x1320.value = x1188

} else {
val x1326 = new Entry(2, x1188)
val x1327 = x1320.next
val x1328 = x1320.hasNext
x1320.next = x1326
x1176.size = x1303

}

}
val x1335 = x1176.threshold
val x1336 = x1176.size
val x1337 = x1336 >= x1335
val x1338 = x1294 == x1180
val x1341 = 2 * x1294
val x1370 = x1341 - 1
val x1387 = x1179 * x1341
val x1388 = x1387.asInstanceOf[Int]
if (x1337) {
if (x1338) {
x1176.threshold = x73

} else {
val x1342 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x1341)
var x1343 = 0
while ({
val x1344 = x1343
val x1345 = x1293.length
val x1346 = x1344 < x1345
x1346
}) {
val x1348 = x1343
val x1349 = x1293(x1348)
var x1350 = x1349
val x1351 = x1350
val x1352 = x1351 != null
if (x1352) {
x1293(x1348) = null
while ({
val x1354 = x1350
val x1355 = x1354 != null
x1355
}) {
val x1357 = x1350
val x1358 = x1357.key
val x1372 = x1357.next
val x1359 = x1358.hashCode
val x1360 = x1359.toLong
val x1361 = x1360 >>> 20
val x1362 = x1360 >>> 12
val x1363 = x1361 ^ x1362
val x1364 = x1363 ^ x1360
val x1365 = x1364 >>> 7
val x1366 = x1364 ^ x1365
val x1367 = x1364 >>> 4
val x1368 = x1366 ^ x1367
val x1369 = x1368.toInt
val x1371 = x1369 & x1370
val x1373 = x1342(x1371)
val x1374 = x1357.hasNext
x1357.next = x1373
x1342(x1371) = x1357
x1350 = x1372
()
}

} else {
()
}
val x1382 = x1348 + 1
x1343 = x1382
()
}
x1176.table = x1342
x1176.threshold = x1388

}

} else {
()
}
val x1394 = x1183.length
val x1395 = x1394 - 1
val x1396 = x28 & x1395
val x1397 = x1183(x1396)
var x1398 = x1397
val x1399 = x1398
val x1400 = x1399 == null
if (x1400) {
val x1401 = new Entry(1, 1)
x1183(x1396) = x1401
val x1403 = x1184 + 1
x1182.size = x1403

} else {
while ({
val x1406 = x1398
val x1407 = x1406.hasNext
val x1413 = if (x1407) {
val x1408 = x1398
val x1409 = x1408.key
val x1410 = x1409 != 1

x1410
} else false

x1413
}) {
val x1415 = x1398
val x1416 = x1415.next
x1398 = x1416
()
}
val x1420 = x1398
val x1421 = x1420.key
val x1422 = x1421 == 1
if (x1422) {
val x1423 = x1420.value
x1420.value = 1

} else {
val x1426 = new Entry(1, 1)
val x1427 = x1420.next
val x1428 = x1420.hasNext
x1420.next = x1426
val x1403 = x1184 + 1
x1182.size = x1403

}

}
val x1435 = x1182.size
val x1436 = x1435 >= x1187
if (x1436) {
val x1437 = x1394 == x1186
if (x1437) {
x1182.threshold = x73

} else {
val x1440 = 2 * x1394
val x1441 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1440)
var x1442 = 0
val x1469 = x1440 - 1
while ({
val x1443 = x1442
val x1444 = x1183.length
val x1445 = x1443 < x1444
x1445
}) {
val x1447 = x1442
val x1448 = x1183(x1447)
var x1449 = x1448
val x1450 = x1449
val x1451 = x1450 != null
if (x1451) {
x1183(x1447) = null
while ({
val x1453 = x1449
val x1454 = x1453 != null
x1454
}) {
val x1456 = x1449
val x1457 = x1456.key
val x1471 = x1456.next
val x1458 = x1457.hashCode
val x1459 = x1458.toLong
val x1460 = x1459 >>> 20
val x1461 = x1459 >>> 12
val x1462 = x1460 ^ x1461
val x1463 = x1462 ^ x1459
val x1464 = x1463 >>> 7
val x1465 = x1463 ^ x1464
val x1466 = x1463 >>> 4
val x1467 = x1465 ^ x1466
val x1468 = x1467.toInt
val x1470 = x1468 & x1469
val x1472 = x1441(x1470)
val x1473 = x1456.hasNext
x1456.next = x1472
x1441(x1470) = x1456
x1449 = x1471
()
}

} else {
()
}
val x1481 = x1447 + 1
x1442 = x1481
()
}
x1182.table = x1441
val x1486 = x1185 * x1440
val x1487 = x1486.asInstanceOf[Int]
x1182.threshold = x1487

}

} else {
()
}
val x1493 = x1176.table
val x1494 = x1493.length
val x1495 = x1494 - 1
val x1496 = x28 & x1495
val x1497 = x1493(x1496)
var x1498 = x1497
val x1499 = x1498
val x1500 = x1499 == null
val x348 = None
val x1523 = if (x1500) {
x348
} else {
while ({
val x1501 = x1498
val x1502 = x1501.hasNext
val x1508 = if (x1502) {
val x1503 = x1498
val x1504 = x1503.key
val x1505 = x1504 != 1

x1505
} else false

x1508
}) {
val x1510 = x1498
val x1511 = x1510.next
x1498 = x1511
()
}
val x1515 = x1498
val x1516 = x1515.key
val x1517 = x1516 == 1
val x1521 = if (x1517) {
val x1518 = x1515.value
val x1519 = Some(x1518)
x1519
} else {
x348
}
x1521
}
val x1524 = x1523.get
val x1525 = x1524.table
val x1526 = x1525.length
val x1527 = x1526 - 1
val x1528 = x28 & x1527
val x1529 = x1525(x1528)
var x1530 = x1529
val x1531 = x1524.size
val x1532 = x1530
val x1533 = x1532 == null
val x1536 = x1531 + 1
if (x1533) {
val x1534 = new Entry(1, 2)
x1525(x1528) = x1534
x1524.size = x1536

} else {
while ({
val x1539 = x1530
val x1540 = x1539.hasNext
val x1546 = if (x1540) {
val x1541 = x1530
val x1542 = x1541.key
val x1543 = x1542 != 1

x1543
} else false

x1546
}) {
val x1548 = x1530
val x1549 = x1548.next
x1530 = x1549
()
}
val x1553 = x1530
val x1554 = x1553.key
val x1555 = x1554 == 1
if (x1555) {
val x1556 = x1553.value
x1553.value = 2

} else {
val x1559 = new Entry(1, 2)
val x1560 = x1553.next
val x1561 = x1553.hasNext
x1553.next = x1559
x1524.size = x1536

}

}
val x1568 = x1524.threshold
val x1569 = x1524.MAXIMUM_CAPACITY
val x1570 = x1524.size
val x1571 = x1570 >= x1568
val x1572 = x1526 == x1569
val x1575 = 2 * x1526
val x1604 = x1575 - 1
if (x1571) {
if (x1572) {
x1524.threshold = x73

} else {
val x1576 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1575)
var x1577 = 0
while ({
val x1578 = x1577
val x1579 = x1525.length
val x1580 = x1578 < x1579
x1580
}) {
val x1582 = x1577
val x1583 = x1525(x1582)
var x1584 = x1583
val x1585 = x1584
val x1586 = x1585 != null
if (x1586) {
x1525(x1582) = null
while ({
val x1588 = x1584
val x1589 = x1588 != null
x1589
}) {
val x1591 = x1584
val x1592 = x1591.key
val x1606 = x1591.next
val x1593 = x1592.hashCode
val x1594 = x1593.toLong
val x1595 = x1594 >>> 20
val x1596 = x1594 >>> 12
val x1597 = x1595 ^ x1596
val x1598 = x1597 ^ x1594
val x1599 = x1598 >>> 7
val x1600 = x1598 ^ x1599
val x1601 = x1598 >>> 4
val x1602 = x1600 ^ x1601
val x1603 = x1602.toInt
val x1605 = x1603 & x1604
val x1607 = x1576(x1605)
val x1608 = x1591.hasNext
x1591.next = x1607
x1576(x1605) = x1591
x1584 = x1606
()
}

} else {
()
}
val x1616 = x1582 + 1
x1577 = x1616
()
}
x1524.table = x1576
val x1621 = x1524.loadFactor
val x1622 = x1621 * x1575
val x1623 = x1622.asInstanceOf[Int]
x1524.threshold = x1623

}

} else {
()
}
var x1629 = 0
val x478 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]]
var x1630 = x478
val x492 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.Entry[Int, Int]]
while ({
val x1631 = x1629
val x1632 = x1493.length
val x1633 = x1631 < x1632
x1633
}) {
val x1635 = x1629
val x1636 = x1493(x1635)
val x1637 = x1636 != null
if (x1637) {
x1630 = x1636
println(x1636)
val x1640 = x1636.value
val x1641 = x1640.table
var x1642 = 0
var x1643 = x492
while ({
val x1644 = x1642
val x1645 = x1641.length
val x1646 = x1644 < x1645
x1646
}) {
val x1648 = x1642
val x1649 = x1641(x1648)
val x1650 = x1649 != null
if (x1650) {
x1643 = x1649
println(x1649)
while ({
val x1653 = x1643
val x1654 = x1653.hasNext
x1654
}) {
val x1656 = x1643
val x1657 = x1656.next
x1643 = x1657
val x1659 = x1643
println(x1659)

}

} else {
()
}
val x1665 = x1648 + 1
x1642 = x1665
()
}
while ({
val x1669 = x1630
val x1670 = x1669.hasNext
x1670
}) {
val x1672 = x1630
val x1673 = x1672.next
x1630 = x1673
val x1675 = x1630
println(x1675)
val x1677 = x1675.value
val x1678 = x1677.table
var x1679 = 0
var x1680 = x492
while ({
val x1681 = x1679
val x1682 = x1678.length
val x1683 = x1681 < x1682
x1683
}) {
val x1685 = x1679
val x1686 = x1678(x1685)
val x1687 = x1686 != null
if (x1687) {
x1680 = x1686
println(x1686)
while ({
val x1690 = x1680
val x1691 = x1690.hasNext
x1691
}) {
val x1693 = x1680
val x1694 = x1693.next
x1680 = x1694
val x1696 = x1680
println(x1696)

}

} else {
()
}
val x1702 = x1685 + 1
x1679 = x1702
()
}

}

} else {
()
}
val x1710 = x1635 + 1
x1629 = x1710
()
}
var x1714 = 0
var x1715 = x478
val x575 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]
while ({
val x1716 = x1714
val x1717 = x1493.length
val x1718 = x1716 < x1717
x1718
}) {
val x1720 = x1714
val x1721 = x1493(x1720)
val x1722 = x1721 != null
if (x1722) {
x1715 = x1721
val x1724 = x1721.key
val x1725 = x1176.table
val x1737 = x1725.length
val x1726 = x1724.hashCode
val x1727 = x1726.toLong
val x1728 = x1727 >>> 20
val x1729 = x1727 >>> 12
val x1730 = x1728 ^ x1729
val x1731 = x1730 ^ x1727
val x1732 = x1731 >>> 7
val x1733 = x1731 ^ x1732
val x1734 = x1731 >>> 4
val x1735 = x1733 ^ x1734
val x1736 = x1735.toInt
val x1738 = x1737 - 1
val x1739 = x1736 & x1738
val x1740 = x1725(x1739)
var x1741 = x1740
val x1742 = x1176.size
val x1743 = x1741
val x1744 = x1743 == null
if (x1744) {
val x1745 = new Entry(x1724, x575)
x1725(x1739) = x1745
val x1747 = x1742 + 1
x1176.size = x1747

} else {
while ({
val x1750 = x1741
val x1751 = x1750.hasNext
val x1757 = if (x1751) {
val x1752 = x1741
val x1753 = x1752.key
val x1754 = x1753 != x1724

x1754
} else false

x1757
}) {
val x1759 = x1741
val x1760 = x1759.next
x1741 = x1760
()
}
val x1764 = x1741
val x1765 = x1764.key
val x1766 = x1765 == x1724
if (x1766) {
val x1767 = x1764.value
x1764.value = x575

} else {
val x1770 = new Entry(x1724, x575)
val x1771 = x1764.next
val x1772 = x1764.hasNext
x1764.next = x1770
val x1747 = x1742 + 1
x1176.size = x1747

}

}
val x1779 = x1176.threshold
val x1780 = x1176.MAXIMUM_CAPACITY
val x1781 = x1176.size
val x1782 = x1781 >= x1779
if (x1782) {
val x1783 = x1737 == x1780
if (x1783) {
x1176.threshold = x73

} else {
val x1786 = 2 * x1737
val x1787 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x1786)
var x1788 = 0
val x1815 = x1786 - 1
while ({
val x1789 = x1788
val x1790 = x1725.length
val x1791 = x1789 < x1790
x1791
}) {
val x1793 = x1788
val x1794 = x1725(x1793)
var x1795 = x1794
val x1796 = x1795
val x1797 = x1796 != null
if (x1797) {
x1725(x1793) = null
while ({
val x1799 = x1795
val x1800 = x1799 != null
x1800
}) {
val x1802 = x1795
val x1803 = x1802.key
val x1817 = x1802.next
val x1804 = x1803.hashCode
val x1805 = x1804.toLong
val x1806 = x1805 >>> 20
val x1807 = x1805 >>> 12
val x1808 = x1806 ^ x1807
val x1809 = x1808 ^ x1805
val x1810 = x1809 >>> 7
val x1811 = x1809 ^ x1810
val x1812 = x1809 >>> 4
val x1813 = x1811 ^ x1812
val x1814 = x1813.toInt
val x1816 = x1814 & x1815
val x1818 = x1787(x1816)
val x1819 = x1802.hasNext
x1802.next = x1818
x1787(x1816) = x1802
x1795 = x1817
()
}

} else {
()
}
val x1827 = x1793 + 1
x1788 = x1827
()
}
x1176.table = x1787
val x1832 = x1176.loadFactor
val x1833 = x1832 * x1786
val x1834 = x1833.asInstanceOf[Int]
x1176.threshold = x1834

}

} else {
()
}
while ({
val x1840 = x1715
val x1841 = x1840.hasNext
x1841
}) {
val x1843 = x1715
val x1844 = x1843.next
x1715 = x1844
val x1846 = x1715
val x1847 = x1846.key
val x1848 = x1176.table
val x1860 = x1848.length
val x1849 = x1847.hashCode
val x1850 = x1849.toLong
val x1851 = x1850 >>> 20
val x1852 = x1850 >>> 12
val x1853 = x1851 ^ x1852
val x1854 = x1853 ^ x1850
val x1855 = x1854 >>> 7
val x1856 = x1854 ^ x1855
val x1857 = x1854 >>> 4
val x1858 = x1856 ^ x1857
val x1859 = x1858.toInt
val x1861 = x1860 - 1
val x1862 = x1859 & x1861
val x1863 = x1848(x1862)
var x1864 = x1863
val x1865 = x1176.size
val x1866 = x1864
val x1867 = x1866 == null
if (x1867) {
val x1868 = new Entry(x1847, x575)
x1848(x1862) = x1868
val x1870 = x1865 + 1
x1176.size = x1870

} else {
while ({
val x1873 = x1864
val x1874 = x1873.hasNext
val x1880 = if (x1874) {
val x1875 = x1864
val x1876 = x1875.key
val x1877 = x1876 != x1847

x1877
} else false

x1880
}) {
val x1882 = x1864
val x1883 = x1882.next
x1864 = x1883
()
}
val x1887 = x1864
val x1888 = x1887.key
val x1889 = x1888 == x1847
if (x1889) {
val x1890 = x1887.value
x1887.value = x575

} else {
val x1893 = new Entry(x1847, x575)
val x1894 = x1887.next
val x1895 = x1887.hasNext
x1887.next = x1893
val x1870 = x1865 + 1
x1176.size = x1870

}

}
val x1902 = x1176.threshold
val x1903 = x1176.MAXIMUM_CAPACITY
val x1904 = x1176.size
val x1905 = x1904 >= x1902
if (x1905) {
val x1906 = x1860 == x1903
if (x1906) {
x1176.threshold = x73

} else {
val x1909 = 2 * x1860
val x1910 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x1909)
var x1911 = 0
val x1938 = x1909 - 1
while ({
val x1912 = x1911
val x1913 = x1848.length
val x1914 = x1912 < x1913
x1914
}) {
val x1916 = x1911
val x1917 = x1848(x1916)
var x1918 = x1917
val x1919 = x1918
val x1920 = x1919 != null
if (x1920) {
x1848(x1916) = null
while ({
val x1922 = x1918
val x1923 = x1922 != null
x1923
}) {
val x1925 = x1918
val x1926 = x1925.key
val x1940 = x1925.next
val x1927 = x1926.hashCode
val x1928 = x1927.toLong
val x1929 = x1928 >>> 20
val x1930 = x1928 >>> 12
val x1931 = x1929 ^ x1930
val x1932 = x1931 ^ x1928
val x1933 = x1932 >>> 7
val x1934 = x1932 ^ x1933
val x1935 = x1932 >>> 4
val x1936 = x1934 ^ x1935
val x1937 = x1936.toInt
val x1939 = x1937 & x1938
val x1941 = x1910(x1939)
val x1942 = x1925.hasNext
x1925.next = x1941
x1910(x1939) = x1925
x1918 = x1940
()
}

} else {
()
}
val x1950 = x1916 + 1
x1911 = x1950
()
}
x1176.table = x1910
val x1955 = x1176.loadFactor
val x1956 = x1955 * x1909
val x1957 = x1956.asInstanceOf[Int]
x1176.threshold = x1957

}

} else {
()
}

}

} else {
()
}
val x1967 = x1720 + 1
x1714 = x1967
()
}
var x1971 = 0
var x1972 = x478
while ({
val x1973 = x1971
val x1974 = x1493.length
val x1975 = x1973 < x1974
x1975
}) {
val x1977 = x1971
val x1978 = x1493(x1977)
val x1979 = x1978 != null
if (x1979) {
x1972 = x1978
println(x1978)
while ({
val x1982 = x1972
val x1983 = x1982.hasNext
x1983
}) {
val x1985 = x1972
val x1986 = x1985.next
x1972 = x1986
val x1988 = x1972
println(x1988)

}

} else {
()
}
val x1994 = x1977 + 1
x1971 = x1994
()
}
var x1998 = 0
var x1999 = x478
while ({
val x2000 = x1998
val x2001 = x1493.length
val x2002 = x2000 < x2001
x2002
}) {
val x2004 = x1998
val x2005 = x1493(x2004)
val x2006 = x2005 != null
if (x2006) {
x1999 = x2005
val x2008 = x2005.key
val x2009 = x1176.table
val x2021 = x2009.length
var x2024 = x478
val x2010 = x2008.hashCode
val x2011 = x2010.toLong
val x2012 = x2011 >>> 20
val x2013 = x2011 >>> 12
val x2014 = x2012 ^ x2013
val x2015 = x2014 ^ x2011
val x2016 = x2015 >>> 7
val x2017 = x2015 ^ x2016
val x2018 = x2015 >>> 4
val x2019 = x2017 ^ x2018
val x2020 = x2019.toInt
val x2022 = x2021 - 1
val x2023 = x2020 & x2022
val x2025 = x2009(x2023)
var x2026 = x2025
val x2027 = x2026
val x2028 = x2027 != null
if (x2028) {
while ({
val x2029 = x2026
val x2030 = x2029.hasNext
val x2036 = if (x2030) {
val x2031 = x2026
val x2032 = x2031.key
val x2033 = x2032 != x2008

x2033
} else false

x2036
}) {
val x2038 = x2026
x2024 = x2038
val x2040 = x2038.next
x2026 = x2040
()
}
val x2044 = x2024
val x2045 = x2044 == null
if (x2045) {
x2009(x2023) = null

} else {
val x2048 = x2026
val x2049 = x2048.key
val x2050 = x2049 == x2008
if (x2050) {
val x2051 = x2048.next
val x2052 = x2044.next
val x2053 = x2044.hasNext
x2044.next = x2051

} else {
()
}

}

} else {
()
}
while ({
val x2061 = x1999
val x2062 = x2061.hasNext
x2062
}) {
val x2064 = x1999
val x2065 = x2064.next
x1999 = x2065
val x2067 = x1999
val x2068 = x2067.key
val x2069 = x1176.table
val x2081 = x2069.length
var x2084 = x478
val x2070 = x2068.hashCode
val x2071 = x2070.toLong
val x2072 = x2071 >>> 20
val x2073 = x2071 >>> 12
val x2074 = x2072 ^ x2073
val x2075 = x2074 ^ x2071
val x2076 = x2075 >>> 7
val x2077 = x2075 ^ x2076
val x2078 = x2075 >>> 4
val x2079 = x2077 ^ x2078
val x2080 = x2079.toInt
val x2082 = x2081 - 1
val x2083 = x2080 & x2082
val x2085 = x2069(x2083)
var x2086 = x2085
val x2087 = x2086
val x2088 = x2087 != null
if (x2088) {
while ({
val x2089 = x2086
val x2090 = x2089.hasNext
val x2096 = if (x2090) {
val x2091 = x2086
val x2092 = x2091.key
val x2093 = x2092 != x2068

x2093
} else false

x2096
}) {
val x2098 = x2086
x2084 = x2098
val x2100 = x2098.next
x2086 = x2100
()
}
val x2104 = x2084
val x2105 = x2104 == null
if (x2105) {
x2069(x2083) = null

} else {
val x2108 = x2086
val x2109 = x2108.key
val x2110 = x2109 == x2068
if (x2110) {
val x2111 = x2108.next
val x2112 = x2104.next
val x2113 = x2104.hasNext
x2104.next = x2111

} else {
()
}

}

} else {
()
}

}

} else {
()
}
val x2125 = x2004 + 1
x1998 = x2125
()
}
val x980 = 3.hashCode
val x981 = x980.toLong
val x982 = x981 >>> 20
val x983 = x981 >>> 12
val x984 = x982 ^ x983
val x985 = x984 ^ x981
val x986 = x985 >>> 7
val x987 = x985 ^ x986
val x988 = x985 >>> 4
val x989 = x987 ^ x988
val x990 = x989.toInt
val x2129 = x990 & x1495
val x2130 = x1493(x2129)
var x2131 = x2130
val x2132 = x2131
val x2133 = x2132 == null
val x2136 = x1336 + 1
if (x2133) {
val x2134 = new Entry(3, x1182)
x1493(x2129) = x2134
x1176.size = x2136

} else {
while ({
val x2139 = x2131
val x2140 = x2139.hasNext
val x2146 = if (x2140) {
val x2141 = x2131
val x2142 = x2141.key
val x2143 = x2142 != 3

x2143
} else false

x2146
}) {
val x2148 = x2131
val x2149 = x2148.next
x2131 = x2149
()
}
val x2153 = x2131
val x2154 = x2153.key
val x2155 = x2154 == 3
if (x2155) {
val x2156 = x2153.value
x2153.value = x1182

} else {
val x2159 = new Entry(3, x1182)
val x2160 = x2153.next
val x2161 = x2153.hasNext
x2153.next = x2159
x1176.size = x2136

}

}
val x2168 = x1176.threshold
val x2169 = x1176.size
val x2170 = x2169 >= x2168
val x2171 = x1494 == x1180
val x2174 = 2 * x1494
val x2203 = x2174 - 1
val x2220 = x1179 * x2174
val x2221 = x2220.asInstanceOf[Int]
if (x2170) {
if (x2171) {
x1176.threshold = x73

} else {
val x2175 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, scala.virtualization.lms.epfl.test12.HashMap[Int, Int]]](x2174)
var x2176 = 0
while ({
val x2177 = x2176
val x2178 = x1493.length
val x2179 = x2177 < x2178
x2179
}) {
val x2181 = x2176
val x2182 = x1493(x2181)
var x2183 = x2182
val x2184 = x2183
val x2185 = x2184 != null
if (x2185) {
x1493(x2181) = null
while ({
val x2187 = x2183
val x2188 = x2187 != null
x2188
}) {
val x2190 = x2183
val x2191 = x2190.key
val x2205 = x2190.next
val x2192 = x2191.hashCode
val x2193 = x2192.toLong
val x2194 = x2193 >>> 20
val x2195 = x2193 >>> 12
val x2196 = x2194 ^ x2195
val x2197 = x2196 ^ x2193
val x2198 = x2197 >>> 7
val x2199 = x2197 ^ x2198
val x2200 = x2197 >>> 4
val x2201 = x2199 ^ x2200
val x2202 = x2201.toInt
val x2204 = x2202 & x2203
val x2206 = x2175(x2204)
val x2207 = x2190.hasNext
x2190.next = x2206
x2175(x2204) = x2190
x2183 = x2205
()
}

} else {
()
}
val x2215 = x2181 + 1
x2176 = x2215
()
}
x1176.table = x2175
x1176.threshold = x2221

}

} else {
()
}
val x2227 = x1176.table
var x2228 = 0
var x2229 = x478
while ({
val x2230 = x2228
val x2231 = x2227.length
val x2232 = x2230 < x2231
x2232
}) {
val x2234 = x2228
val x2235 = x2227(x2234)
val x2236 = x2235 != null
if (x2236) {
x2229 = x2235
println(x2235)
val x2239 = x2235.value
val x2240 = x2239.table
var x2241 = 0
var x2242 = x492
while ({
val x2243 = x2241
val x2244 = x2240.length
val x2245 = x2243 < x2244
x2245
}) {
val x2247 = x2241
val x2248 = x2240(x2247)
val x2249 = x2248 != null
if (x2249) {
x2242 = x2248
println(x2248)
while ({
val x2252 = x2242
val x2253 = x2252.hasNext
x2253
}) {
val x2255 = x2242
val x2256 = x2255.next
x2242 = x2256
val x2258 = x2242
println(x2258)

}

} else {
()
}
val x2264 = x2247 + 1
x2241 = x2264
()
}
while ({
val x2268 = x2229
val x2269 = x2268.hasNext
x2269
}) {
val x2271 = x2229
val x2272 = x2271.next
x2229 = x2272
val x2274 = x2229
println(x2274)
val x2276 = x2274.value
val x2277 = x2276.table
var x2278 = 0
var x2279 = x492
while ({
val x2280 = x2278
val x2281 = x2277.length
val x2282 = x2280 < x2281
x2282
}) {
val x2284 = x2278
val x2285 = x2277(x2284)
val x2286 = x2285 != null
if (x2286) {
x2279 = x2285
println(x2285)
while ({
val x2289 = x2279
val x2290 = x2289.hasNext
x2290
}) {
val x2292 = x2279
val x2293 = x2292.next
x2279 = x2293
val x2295 = x2279
println(x2295)

}

} else {
()
}
val x2301 = x2284 + 1
x2278 = x2301
()
}

}

} else {
()
}
val x2309 = x2234 + 1
x2228 = x2309
()
}
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
