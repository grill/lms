/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapAssignmentProblem2 extends ((Int)=>(Unit)) {
def apply(x256:Int): Unit = {
val x257 = new HashMap[Int,Int](200)
val x258 = x257.table
val x259 = x257.size
val x260 = x257.loadFactor
val x261 = x257.MAXIMUM_CAPACITY
val x262 = x257.threshold
val x263 = x258.length
val x6 = 1.hashCode
val x7 = x6.toLong
val x8 = x7 >>> 20
val x9 = x7 >>> 12
val x10 = x8 ^ x9
val x11 = x10 ^ x7
val x12 = x11 >>> 7
val x13 = x11 ^ x12
val x14 = x11 >>> 4
val x15 = x13 ^ x14
val x16 = x15.toInt
val x264 = x263 - 1
val x265 = x16 & x264
val x266 = x258(x265)
var x267 = x266
val x268 = x267
val x269 = x268 == null
if (x269) {
val x270 = new Entry(1, 2)
x258(x265) = x270
val x272 = x259 + 1
x257.size = x272

} else {
while ({
val x275 = x267
val x276 = x275.hasNext
val x282 = if (x276) {
val x277 = x267
val x278 = x277.key
val x279 = x278 != 1

x279
} else false

x282
}) {
val x284 = x267
val x285 = x284.next
x267 = x285
()
}
val x289 = x267
val x290 = x289.key
val x291 = x290 == 1
if (x291) {
val x292 = x289.value
x289.value = 2

} else {
val x295 = new Entry(1, 2)
val x296 = x289.next
val x297 = x289.hasNext
x289.next = x295
val x272 = x259 + 1
x257.size = x272

}

}
val x304 = x257.size
val x305 = x304 >= x262
if (x305) {
val x306 = x263 == x261
if (x306) {
val x61 = scala.Int.MaxValue
x257.threshold = x61

} else {
val x309 = 2 * x263
val x310 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x309)
var x311 = 0
val x338 = x309 - 1
while ({
val x312 = x311
val x313 = x258.length
val x314 = x312 < x313
x314
}) {
val x316 = x311
val x317 = x258(x316)
var x318 = x317
val x319 = x318
val x320 = x319 != null
if (x320) {
x258(x316) = null
while ({
val x322 = x318
val x323 = x322 != null
x323
}) {
val x325 = x318
val x326 = x325.key
val x340 = x325.next
val x327 = x326.hashCode
val x328 = x327.toLong
val x329 = x328 >>> 20
val x330 = x328 >>> 12
val x331 = x329 ^ x330
val x332 = x331 ^ x328
val x333 = x332 >>> 7
val x334 = x332 ^ x333
val x335 = x332 >>> 4
val x336 = x334 ^ x335
val x337 = x336.toInt
val x339 = x337 & x338
val x341 = x310(x339)
val x342 = x325.hasNext
x325.next = x341
x310(x339) = x325
x318 = x340
()
}

} else {
()
}
val x350 = x316 + 1
x311 = x350
()
}
x257.table = x310
val x355 = x260 * x309
val x356 = x355.asInstanceOf[Int]
x257.threshold = x356

}

} else {
()
}
var x362 = x257
val x363 = x362
val x364 = x363.table
val x365 = x364.length
val x366 = x365 - 1
val x367 = x16 & x366
val x368 = x364(x367)
var x369 = x368
val x370 = x363.size
val x371 = x369
val x372 = x371 == null
if (x372) {
val x373 = new Entry(1, 3)
x364(x367) = x373
val x375 = x370 + 1
x363.size = x375

} else {
while ({
val x378 = x369
val x379 = x378.hasNext
val x385 = if (x379) {
val x380 = x369
val x381 = x380.key
val x382 = x381 != 1

x382
} else false

x385
}) {
val x387 = x369
val x388 = x387.next
x369 = x388
()
}
val x392 = x369
val x393 = x392.key
val x394 = x393 == 1
if (x394) {
val x395 = x392.value
x392.value = 3

} else {
val x398 = new Entry(1, 3)
val x399 = x392.next
val x400 = x392.hasNext
x392.next = x398
val x375 = x370 + 1
x363.size = x375

}

}
val x407 = x363.threshold
val x408 = x363.MAXIMUM_CAPACITY
val x409 = x363.size
val x410 = x409 >= x407
if (x410) {
val x411 = x365 == x408
if (x411) {
val x61 = scala.Int.MaxValue
x363.threshold = x61

} else {
val x414 = 2 * x365
val x415 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x414)
var x416 = 0
val x443 = x414 - 1
while ({
val x417 = x416
val x418 = x364.length
val x419 = x417 < x418
x419
}) {
val x421 = x416
val x422 = x364(x421)
var x423 = x422
val x424 = x423
val x425 = x424 != null
if (x425) {
x364(x421) = null
while ({
val x427 = x423
val x428 = x427 != null
x428
}) {
val x430 = x423
val x431 = x430.key
val x445 = x430.next
val x432 = x431.hashCode
val x433 = x432.toLong
val x434 = x433 >>> 20
val x435 = x433 >>> 12
val x436 = x434 ^ x435
val x437 = x436 ^ x433
val x438 = x437 >>> 7
val x439 = x437 ^ x438
val x440 = x437 >>> 4
val x441 = x439 ^ x440
val x442 = x441.toInt
val x444 = x442 & x443
val x446 = x415(x444)
val x447 = x430.hasNext
x430.next = x446
x415(x444) = x430
x423 = x445
()
}

} else {
()
}
val x455 = x421 + 1
x416 = x455
()
}
x363.table = x415
val x460 = x363.loadFactor
val x461 = x460 * x414
val x462 = x461.asInstanceOf[Int]
x363.threshold = x462

}

} else {
()
}
val x468 = x257.table
val x469 = x468.length
val x470 = x469 - 1
val x471 = x16 & x470
val x472 = x468(x471)
var x473 = x472
val x474 = x473
val x475 = x474 == null
val x498 = if (x475) {
val x231 = None
x231
} else {
while ({
val x476 = x473
val x477 = x476.hasNext
val x483 = if (x477) {
val x478 = x473
val x479 = x478.key
val x480 = x479 != 1

x480
} else false

x483
}) {
val x485 = x473
val x486 = x485.next
x473 = x486
()
}
val x490 = x473
val x491 = x490.key
val x492 = x491 == 1
val x496 = if (x492) {
val x493 = x490.value
val x494 = Some(x493)
x494
} else {
val x231 = None
x231
}
x496
}
println(x498)
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
