/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapAssignmentProblem2 extends ((Int)=>(Unit)) {
def apply(x261:Int): Unit = {
val x262 = new HashMap[Int,Int](200)
val x263 = x262.table
val x264 = x263(0)
val x265 = x262.size
val x266 = x262.loadFactor
val x267 = x262.MAXIMUM_CAPACITY
val x268 = x262.threshold
val x269 = x263.length
val x8 = 1.hashCode
val x9 = x8.toLong
val x10 = x9 >>> 20
val x11 = x9 >>> 12
val x12 = x10 ^ x11
val x13 = x12 ^ x9
val x14 = x13 >>> 7
val x15 = x13 ^ x14
val x16 = x13 >>> 4
val x17 = x15 ^ x16
val x18 = x17.toInt
val x270 = x269 - 1
val x271 = x18 & x270
val x272 = x263(x271)
var x273: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x272
val x274 = x273
val x275 = x274 == null
if (x275) {
val x276 = new Entry(1, 2)
x263(x271) = x276
val x278 = x265 + 1
x262.size = x278

} else {
while ({
val x281 = x273
val x282 = x281.hasNext
val x288 = if (x282) {
val x283 = x273
val x284 = x283.key
val x285 = x284 != 1

x285
} else false

x288
}) {
val x290 = x273
val x291 = x290.next
x273 = x291
()
}
val x295 = x273
val x296 = x295.key
val x297 = x296 == 1
if (x297) {
val x298 = x295.value
x295.value = 2

} else {
val x301 = new Entry(1, 2)
val x302 = x295.next
val x303 = x295.hasNext
x295.next = x301
val x278 = x265 + 1
x262.size = x278

}

}
val x310 = x262.size
val x311 = x310 >= x268
if (x311) {
val x312 = x263.length
val x313 = x312 == x267
if (x313) {
val x63 = scala.Int.MaxValue
x262.threshold = x63

} else {
val x316 = 2 * x312
val x317 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x316)
var x318: Int = 0
val x345 = x316 - 1
while ({
val x319 = x318
val x320 = x263.length
val x321 = x319 < x320
x321
}) {
val x323 = x318
val x324 = x263(x323)
var x325: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x324
val x326 = x325
val x327 = x326 != null
if (x327) {
x263(x323) = null
while ({
val x329 = x325
val x330 = x329 != null
x330
}) {
val x332 = x325
val x333 = x332.key
val x347 = x332.next
val x334 = x333.hashCode
val x335 = x334.toLong
val x336 = x335 >>> 20
val x337 = x335 >>> 12
val x338 = x336 ^ x337
val x339 = x338 ^ x335
val x340 = x339 >>> 7
val x341 = x339 ^ x340
val x342 = x339 >>> 4
val x343 = x341 ^ x342
val x344 = x343.toInt
val x346 = x344 & x345
val x348 = x317(x346)
val x349 = x332.hasNext
x332.next = x348
x317(x346) = x332
x325 = x347
()
}

} else {
()
}
val x357 = x323 + 1
x318 = x357
()
}
x262.table = x317
val x362 = x266 * x316
val x363 = x362.asInstanceOf[Int]
x262.threshold = x363

}

} else {
()
}
var x369: scala.virtualization.lms.epfl.test12.HashMap[Int, Int] = x262
val x370 = x369
val x371 = x370.table
val x372 = x371.length
val x373 = x372 - 1
val x374 = x18 & x373
val x375 = x371(x374)
var x376: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x375
val x377 = x376
val x378 = x377 == null
if (x378) {
val x379 = new Entry(1, 3)
x371(x374) = x379
val x381 = x370.size
val x382 = x381 + 1
x370.size = x382

} else {
while ({
val x385 = x376
val x386 = x385.hasNext
val x392 = if (x386) {
val x387 = x376
val x388 = x387.key
val x389 = x388 != 1

x389
} else false

x392
}) {
val x394 = x376
val x395 = x394.next
x376 = x395
()
}
val x399 = x376
val x400 = x399.key
val x401 = x400 == 1
if (x401) {
val x402 = x399.value
x399.value = 3

} else {
val x405 = new Entry(1, 3)
val x406 = x399.next
val x407 = x399.hasNext
x399.next = x405
val x409 = x370.size
val x410 = x409 + 1
x370.size = x410

}

}
val x416 = x370.threshold
val x417 = x370.MAXIMUM_CAPACITY
val x418 = x370.size
val x419 = x418 >= x416
if (x419) {
val x420 = x371.length
val x421 = x420 == x417
if (x421) {
val x63 = scala.Int.MaxValue
x370.threshold = x63

} else {
val x424 = 2 * x420
val x425 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x424)
var x426: Int = 0
val x453 = x424 - 1
while ({
val x427 = x426
val x428 = x371.length
val x429 = x427 < x428
x429
}) {
val x431 = x426
val x432 = x371(x431)
var x433: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x432
val x434 = x433
val x435 = x434 != null
if (x435) {
x371(x431) = null
while ({
val x437 = x433
val x438 = x437 != null
x438
}) {
val x440 = x433
val x441 = x440.key
val x455 = x440.next
val x442 = x441.hashCode
val x443 = x442.toLong
val x444 = x443 >>> 20
val x445 = x443 >>> 12
val x446 = x444 ^ x445
val x447 = x446 ^ x443
val x448 = x447 >>> 7
val x449 = x447 ^ x448
val x450 = x447 >>> 4
val x451 = x449 ^ x450
val x452 = x451.toInt
val x454 = x452 & x453
val x456 = x425(x454)
val x457 = x440.hasNext
x440.next = x456
x425(x454) = x440
x433 = x455
()
}

} else {
()
}
val x465 = x431 + 1
x426 = x465
()
}
x370.table = x425
val x470 = x370.loadFactor
val x471 = x470 * x424
val x472 = x471.asInstanceOf[Int]
x370.threshold = x472

}

} else {
()
}
val x478 = x262.table
val x479 = x478.length
val x480 = x479 - 1
val x481 = x18 & x480
val x482 = x478(x481)
var x483: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x482
val x484 = x483
val x485 = x484 == null
val x508 = if (x485) {
val x236 = None
x236
} else {
while ({
val x486 = x483
val x487 = x486.hasNext
val x493 = if (x487) {
val x488 = x483
val x489 = x488.key
val x490 = x489 != 1

x490
} else false

x493
}) {
val x495 = x483
val x496 = x495.next
x483 = x496
()
}
val x500 = x483
val x501 = x500.key
val x502 = x501 == 1
val x506 = if (x502) {
val x503 = x500.value
val x504 = Some(x503)
x504
} else {
val x236 = None
x236
}
x506
}
println(x508)
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
