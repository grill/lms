/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapComplex extends ((Int)=>(Unit)) {
def apply(x953:Int): Unit = {
val x954 = new HashMap[Int,Int](1)
val x955 = x954.table
val x956 = x955(0)
val x957 = x954.size
val x958 = x954.loadFactor
val x959 = x954.MAXIMUM_CAPACITY
val x960 = x954.threshold
val x961 = x955.length
val x7 = 1.hashCode
val x8 = x7.toLong
val x9 = x8 >>> 20
val x10 = x8 >>> 12
val x11 = x9 ^ x10
val x12 = x11 ^ x8
val x13 = x12 >>> 7
val x14 = x12 ^ x13
val x15 = x12 >>> 4
val x16 = x14 ^ x15
val x17 = x16.toInt
val x962 = x961 - 1
val x963 = x17 & x962
val x964 = x955(x963)
var x965: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x964
val x966 = x965
val x967 = x966 == null
val x970 = x957 + 1
if (x967) {
val x968 = new Entry(1, 2)
x955(x963) = x968
x954.size = x970

} else {
while ({
val x973 = x965
val x974 = x973.hasNext
val x980 = if (x974) {
val x975 = x965
val x976 = x975.key
val x977 = x976 != 1

x977
} else false

x980
}) {
val x982 = x965
val x983 = x982.next
x965 = x983
()
}
val x987 = x965
val x988 = x987.key
val x989 = x988 == 1
if (x989) {
val x990 = x987.value
x987.value = 2

} else {
val x993 = new Entry(1, 2)
val x994 = x987.next
val x995 = x987.hasNext
x987.next = x993
x954.size = x970

}

}
val x1002 = x954.size
val x1003 = x1002 >= x960
val x63 = scala.Int.MaxValue
if (x1003) {
val x1004 = x955.length
val x1005 = x1004 == x959
if (x1005) {
x954.threshold = x63

} else {
val x1008 = 2 * x1004
val x1009 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1008)
var x1010: Int = 0
val x1037 = x1008 - 1
while ({
val x1011 = x1010
val x1012 = x955.length
val x1013 = x1011 < x1012
x1013
}) {
val x1015 = x1010
val x1016 = x955(x1015)
var x1017: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1016
val x1018 = x1017
val x1019 = x1018 != null
if (x1019) {
x955(x1015) = null
while ({
val x1021 = x1017
val x1022 = x1021 != null
x1022
}) {
val x1024 = x1017
val x1025 = x1024.key
val x1039 = x1024.next
val x1026 = x1025.hashCode
val x1027 = x1026.toLong
val x1028 = x1027 >>> 20
val x1029 = x1027 >>> 12
val x1030 = x1028 ^ x1029
val x1031 = x1030 ^ x1027
val x1032 = x1031 >>> 7
val x1033 = x1031 ^ x1032
val x1034 = x1031 >>> 4
val x1035 = x1033 ^ x1034
val x1036 = x1035.toInt
val x1038 = x1036 & x1037
val x1040 = x1009(x1038)
val x1041 = x1024.hasNext
x1024.next = x1040
x1009(x1038) = x1024
x1017 = x1039
()
}

} else {
()
}
val x1049 = x1015 + 1
x1010 = x1049
()
}
x954.table = x1009
val x1054 = x958 * x1008
val x1055 = x1054.asInstanceOf[Int]
x954.threshold = x1055

}

} else {
()
}
val x1061 = x954.table
val x1062 = x1061.length
val x120 = 2.hashCode
val x121 = x120.toLong
val x122 = x121 >>> 20
val x123 = x121 >>> 12
val x124 = x122 ^ x123
val x125 = x124 ^ x121
val x126 = x125 >>> 7
val x127 = x125 ^ x126
val x128 = x125 >>> 4
val x129 = x127 ^ x128
val x130 = x129.toInt
val x1063 = x1062 - 1
val x1064 = x130 & x1063
val x1065 = x1061(x1064)
var x1066: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1065
val x1067 = x1066
val x1068 = x1067 == null
val x1071 = x1002 + 1
if (x1068) {
val x1069 = new Entry(2, 3)
x1061(x1064) = x1069
x954.size = x1071

} else {
while ({
val x1074 = x1066
val x1075 = x1074.hasNext
val x1081 = if (x1075) {
val x1076 = x1066
val x1077 = x1076.key
val x1078 = x1077 != 2

x1078
} else false

x1081
}) {
val x1083 = x1066
val x1084 = x1083.next
x1066 = x1084
()
}
val x1088 = x1066
val x1089 = x1088.key
val x1090 = x1089 == 2
if (x1090) {
val x1091 = x1088.value
x1088.value = 3

} else {
val x1094 = new Entry(2, 3)
val x1095 = x1088.next
val x1096 = x1088.hasNext
x1088.next = x1094
x954.size = x1071

}

}
val x1103 = x954.threshold
val x1104 = x954.size
val x1105 = x1104 >= x1103
if (x1105) {
val x1106 = x1061.length
val x1107 = x1106 == x959
if (x1107) {
x954.threshold = x63

} else {
val x1110 = 2 * x1106
val x1111 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1110)
var x1112: Int = 0
val x1139 = x1110 - 1
while ({
val x1113 = x1112
val x1114 = x1061.length
val x1115 = x1113 < x1114
x1115
}) {
val x1117 = x1112
val x1118 = x1061(x1117)
var x1119: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1118
val x1120 = x1119
val x1121 = x1120 != null
if (x1121) {
x1061(x1117) = null
while ({
val x1123 = x1119
val x1124 = x1123 != null
x1124
}) {
val x1126 = x1119
val x1127 = x1126.key
val x1141 = x1126.next
val x1128 = x1127.hashCode
val x1129 = x1128.toLong
val x1130 = x1129 >>> 20
val x1131 = x1129 >>> 12
val x1132 = x1130 ^ x1131
val x1133 = x1132 ^ x1129
val x1134 = x1133 >>> 7
val x1135 = x1133 ^ x1134
val x1136 = x1133 >>> 4
val x1137 = x1135 ^ x1136
val x1138 = x1137.toInt
val x1140 = x1138 & x1139
val x1142 = x1111(x1140)
val x1143 = x1126.hasNext
x1126.next = x1142
x1111(x1140) = x1126
x1119 = x1141
()
}

} else {
()
}
val x1151 = x1117 + 1
x1112 = x1151
()
}
x954.table = x1111
val x1156 = x958 * x1110
val x1157 = x1156.asInstanceOf[Int]
x954.threshold = x1157

}

} else {
()
}
val x1163 = x954.table
val x1164 = x1163.length
val x1165 = x1164 - 1
val x1166 = x17 & x1165
val x1167 = x1163(x1166)
var x1168: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1167
val x1169 = x1168
val x1170 = x1169 == null
val x240 = None
val x1193 = if (x1170) {
x240
} else {
while ({
val x1171 = x1168
val x1172 = x1171.hasNext
val x1178 = if (x1172) {
val x1173 = x1168
val x1174 = x1173.key
val x1175 = x1174 != 1

x1175
} else false

x1178
}) {
val x1180 = x1168
val x1181 = x1180.next
x1168 = x1181
()
}
val x1185 = x1168
val x1186 = x1185.key
val x1187 = x1186 == 1
val x1191 = if (x1187) {
val x1188 = x1185.value
val x1189 = Some(x1188)
x1189
} else {
x240
}
x1191
}
val x1194 = x1193.get
val x1196 = x1163.length
val x1197 = x1196 - 1
val x1198 = x17 & x1197
val x1199 = x1163(x1198)
var x1200: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1199
val x1201 = x1200
val x1202 = x1201 == null
val x1195 = x1194 + 1
val x1205 = x1104 + 1
if (x1202) {
val x1203 = new Entry(1, x1195)
x1163(x1198) = x1203
x954.size = x1205

} else {
while ({
val x1208 = x1200
val x1209 = x1208.hasNext
val x1215 = if (x1209) {
val x1210 = x1200
val x1211 = x1210.key
val x1212 = x1211 != 1

x1212
} else false

x1215
}) {
val x1217 = x1200
val x1218 = x1217.next
x1200 = x1218
()
}
val x1222 = x1200
val x1223 = x1222.key
val x1224 = x1223 == 1
if (x1224) {
val x1225 = x1222.value
x1222.value = x1195

} else {
val x1228 = new Entry(1, x1195)
val x1229 = x1222.next
val x1230 = x1222.hasNext
x1222.next = x1228
x954.size = x1205

}

}
val x1237 = x954.threshold
val x1238 = x954.size
val x1239 = x1238 >= x1237
if (x1239) {
val x1240 = x1163.length
val x1241 = x1240 == x959
if (x1241) {
x954.threshold = x63

} else {
val x1244 = 2 * x1240
val x1245 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1244)
var x1246: Int = 0
val x1273 = x1244 - 1
while ({
val x1247 = x1246
val x1248 = x1163.length
val x1249 = x1247 < x1248
x1249
}) {
val x1251 = x1246
val x1252 = x1163(x1251)
var x1253: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1252
val x1254 = x1253
val x1255 = x1254 != null
if (x1255) {
x1163(x1251) = null
while ({
val x1257 = x1253
val x1258 = x1257 != null
x1258
}) {
val x1260 = x1253
val x1261 = x1260.key
val x1275 = x1260.next
val x1262 = x1261.hashCode
val x1263 = x1262.toLong
val x1264 = x1263 >>> 20
val x1265 = x1263 >>> 12
val x1266 = x1264 ^ x1265
val x1267 = x1266 ^ x1263
val x1268 = x1267 >>> 7
val x1269 = x1267 ^ x1268
val x1270 = x1267 >>> 4
val x1271 = x1269 ^ x1270
val x1272 = x1271.toInt
val x1274 = x1272 & x1273
val x1276 = x1245(x1274)
val x1277 = x1260.hasNext
x1260.next = x1276
x1245(x1274) = x1260
x1253 = x1275
()
}

} else {
()
}
val x1285 = x1251 + 1
x1246 = x1285
()
}
x954.table = x1245
val x1290 = x958 * x1244
val x1291 = x1290.asInstanceOf[Int]
x954.threshold = x1291

}

} else {
()
}
val x1297 = x954.table
var x1298: Int = 0
val x369 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.Entry[Int, Int]]
var x1299: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x369
while ({
val x1300 = x1298
val x1301 = x1297.length
val x1302 = x1300 < x1301
x1302
}) {
val x1304 = x1298
val x1305 = x1297(x1304)
val x1306 = x1305 != null
if (x1306) {
x1299 = x1305
println(x1305)
while ({
val x1309 = x1299
val x1310 = x1309.hasNext
x1310
}) {
val x1312 = x1299
val x1313 = x1312.next
x1299 = x1313
val x1315 = x1299
println(x1315)

}

} else {
()
}
val x1321 = x1304 + 1
x1298 = x1321
()
}
var x1325: Int = 0
var x1326: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x369
while ({
val x1327 = x1325
val x1328 = x1297.length
val x1329 = x1327 < x1328
x1329
}) {
val x1331 = x1325
val x1332 = x1297(x1331)
val x1333 = x1332 != null
if (x1333) {
x1326 = x1332
val x1335 = x1332.key
val x1336 = x954.table
val x1348 = x1336.length
val x1337 = x1335.hashCode
val x1338 = x1337.toLong
val x1339 = x1338 >>> 20
val x1340 = x1338 >>> 12
val x1341 = x1339 ^ x1340
val x1342 = x1341 ^ x1338
val x1343 = x1342 >>> 7
val x1344 = x1342 ^ x1343
val x1345 = x1342 >>> 4
val x1346 = x1344 ^ x1345
val x1347 = x1346.toInt
val x1349 = x1348 - 1
val x1350 = x1347 & x1349
val x1351 = x1336(x1350)
var x1352: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1351
val x1353 = x954.size
val x1354 = x1352
val x1355 = x1354 == null
if (x1355) {
val x1356 = new Entry(x1335, 0)
x1336(x1350) = x1356
val x1358 = x1353 + 1
x954.size = x1358

} else {
while ({
val x1361 = x1352
val x1362 = x1361.hasNext
val x1368 = if (x1362) {
val x1363 = x1352
val x1364 = x1363.key
val x1365 = x1364 != x1335

x1365
} else false

x1368
}) {
val x1370 = x1352
val x1371 = x1370.next
x1352 = x1371
()
}
val x1375 = x1352
val x1376 = x1375.key
val x1377 = x1376 == x1335
if (x1377) {
val x1378 = x1375.value
x1375.value = 0

} else {
val x1381 = new Entry(x1335, 0)
val x1382 = x1375.next
val x1383 = x1375.hasNext
x1375.next = x1381
val x1358 = x1353 + 1
x954.size = x1358

}

}
val x1390 = x954.threshold
val x1391 = x954.MAXIMUM_CAPACITY
val x1392 = x954.size
val x1393 = x1392 >= x1390
if (x1393) {
val x1394 = x1336.length
val x1395 = x1394 == x1391
if (x1395) {
x954.threshold = x63

} else {
val x1398 = 2 * x1394
val x1399 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1398)
var x1400: Int = 0
val x1427 = x1398 - 1
while ({
val x1401 = x1400
val x1402 = x1336.length
val x1403 = x1401 < x1402
x1403
}) {
val x1405 = x1400
val x1406 = x1336(x1405)
var x1407: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1406
val x1408 = x1407
val x1409 = x1408 != null
if (x1409) {
x1336(x1405) = null
while ({
val x1411 = x1407
val x1412 = x1411 != null
x1412
}) {
val x1414 = x1407
val x1415 = x1414.key
val x1429 = x1414.next
val x1416 = x1415.hashCode
val x1417 = x1416.toLong
val x1418 = x1417 >>> 20
val x1419 = x1417 >>> 12
val x1420 = x1418 ^ x1419
val x1421 = x1420 ^ x1417
val x1422 = x1421 >>> 7
val x1423 = x1421 ^ x1422
val x1424 = x1421 >>> 4
val x1425 = x1423 ^ x1424
val x1426 = x1425.toInt
val x1428 = x1426 & x1427
val x1430 = x1399(x1428)
val x1431 = x1414.hasNext
x1414.next = x1430
x1399(x1428) = x1414
x1407 = x1429
()
}

} else {
()
}
val x1439 = x1405 + 1
x1400 = x1439
()
}
x954.table = x1399
val x1444 = x954.loadFactor
val x1445 = x1444 * x1398
val x1446 = x1445.asInstanceOf[Int]
x954.threshold = x1446

}

} else {
()
}
while ({
val x1452 = x1326
val x1453 = x1452.hasNext
x1453
}) {
val x1455 = x1326
val x1456 = x1455.next
x1326 = x1456
val x1458 = x1326
val x1459 = x1458.key
val x1460 = x954.table
val x1472 = x1460.length
val x1461 = x1459.hashCode
val x1462 = x1461.toLong
val x1463 = x1462 >>> 20
val x1464 = x1462 >>> 12
val x1465 = x1463 ^ x1464
val x1466 = x1465 ^ x1462
val x1467 = x1466 >>> 7
val x1468 = x1466 ^ x1467
val x1469 = x1466 >>> 4
val x1470 = x1468 ^ x1469
val x1471 = x1470.toInt
val x1473 = x1472 - 1
val x1474 = x1471 & x1473
val x1475 = x1460(x1474)
var x1476: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1475
val x1477 = x954.size
val x1478 = x1476
val x1479 = x1478 == null
if (x1479) {
val x1480 = new Entry(x1459, 0)
x1460(x1474) = x1480
val x1482 = x1477 + 1
x954.size = x1482

} else {
while ({
val x1485 = x1476
val x1486 = x1485.hasNext
val x1492 = if (x1486) {
val x1487 = x1476
val x1488 = x1487.key
val x1489 = x1488 != x1459

x1489
} else false

x1492
}) {
val x1494 = x1476
val x1495 = x1494.next
x1476 = x1495
()
}
val x1499 = x1476
val x1500 = x1499.key
val x1501 = x1500 == x1459
if (x1501) {
val x1502 = x1499.value
x1499.value = 0

} else {
val x1505 = new Entry(x1459, 0)
val x1506 = x1499.next
val x1507 = x1499.hasNext
x1499.next = x1505
val x1482 = x1477 + 1
x954.size = x1482

}

}
val x1514 = x954.threshold
val x1515 = x954.MAXIMUM_CAPACITY
val x1516 = x954.size
val x1517 = x1516 >= x1514
if (x1517) {
val x1518 = x1460.length
val x1519 = x1518 == x1515
if (x1519) {
x954.threshold = x63

} else {
val x1522 = 2 * x1518
val x1523 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1522)
var x1524: Int = 0
val x1551 = x1522 - 1
while ({
val x1525 = x1524
val x1526 = x1460.length
val x1527 = x1525 < x1526
x1527
}) {
val x1529 = x1524
val x1530 = x1460(x1529)
var x1531: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1530
val x1532 = x1531
val x1533 = x1532 != null
if (x1533) {
x1460(x1529) = null
while ({
val x1535 = x1531
val x1536 = x1535 != null
x1536
}) {
val x1538 = x1531
val x1539 = x1538.key
val x1553 = x1538.next
val x1540 = x1539.hashCode
val x1541 = x1540.toLong
val x1542 = x1541 >>> 20
val x1543 = x1541 >>> 12
val x1544 = x1542 ^ x1543
val x1545 = x1544 ^ x1541
val x1546 = x1545 >>> 7
val x1547 = x1545 ^ x1546
val x1548 = x1545 >>> 4
val x1549 = x1547 ^ x1548
val x1550 = x1549.toInt
val x1552 = x1550 & x1551
val x1554 = x1523(x1552)
val x1555 = x1538.hasNext
x1538.next = x1554
x1523(x1552) = x1538
x1531 = x1553
()
}

} else {
()
}
val x1563 = x1529 + 1
x1524 = x1563
()
}
x954.table = x1523
val x1568 = x954.loadFactor
val x1569 = x1568 * x1522
val x1570 = x1569.asInstanceOf[Int]
x954.threshold = x1570

}

} else {
()
}

}

} else {
()
}
val x1580 = x1331 + 1
x1325 = x1580
()
}
var x1584: Int = 0
var x1585: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x369
while ({
val x1586 = x1584
val x1587 = x1297.length
val x1588 = x1586 < x1587
x1588
}) {
val x1590 = x1584
val x1591 = x1297(x1590)
val x1592 = x1591 != null
if (x1592) {
x1585 = x1591
println(x1591)
while ({
val x1595 = x1585
val x1596 = x1595.hasNext
x1596
}) {
val x1598 = x1585
val x1599 = x1598.next
x1585 = x1599
val x1601 = x1585
println(x1601)

}

} else {
()
}
val x1607 = x1590 + 1
x1584 = x1607
()
}
var x1611: Int = 0
var x1612: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x369
while ({
val x1613 = x1611
val x1614 = x1297.length
val x1615 = x1613 < x1614
x1615
}) {
val x1617 = x1611
val x1618 = x1297(x1617)
val x1619 = x1618 != null
if (x1619) {
x1612 = x1618
val x1621 = x1618.key
val x1622 = x954.table
val x1634 = x1622.length
var x1637: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x369
val x1623 = x1621.hashCode
val x1624 = x1623.toLong
val x1625 = x1624 >>> 20
val x1626 = x1624 >>> 12
val x1627 = x1625 ^ x1626
val x1628 = x1627 ^ x1624
val x1629 = x1628 >>> 7
val x1630 = x1628 ^ x1629
val x1631 = x1628 >>> 4
val x1632 = x1630 ^ x1631
val x1633 = x1632.toInt
val x1635 = x1634 - 1
val x1636 = x1633 & x1635
val x1638 = x1622(x1636)
var x1639: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1638
val x1640 = x1639
val x1641 = x1640 != null
if (x1641) {
while ({
val x1642 = x1639
val x1643 = x1642.hasNext
val x1649 = if (x1643) {
val x1644 = x1639
val x1645 = x1644.key
val x1646 = x1645 != x1621

x1646
} else false

x1649
}) {
val x1651 = x1639
x1637 = x1651
val x1653 = x1651.next
x1639 = x1653
()
}
val x1657 = x1637
val x1658 = x1657 == null
if (x1658) {
x1622(x1636) = null

} else {
val x1661 = x1639
val x1662 = x1661.key
val x1663 = x1662 == x1621
if (x1663) {
val x1664 = x1661.next
val x1665 = x1657.next
val x1666 = x1657.hasNext
x1657.next = x1664

} else {
()
}

}

} else {
()
}
while ({
val x1674 = x1612
val x1675 = x1674.hasNext
x1675
}) {
val x1677 = x1612
val x1678 = x1677.next
x1612 = x1678
val x1680 = x1612
val x1681 = x1680.key
val x1682 = x954.table
val x1694 = x1682.length
var x1697: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x369
val x1683 = x1681.hashCode
val x1684 = x1683.toLong
val x1685 = x1684 >>> 20
val x1686 = x1684 >>> 12
val x1687 = x1685 ^ x1686
val x1688 = x1687 ^ x1684
val x1689 = x1688 >>> 7
val x1690 = x1688 ^ x1689
val x1691 = x1688 >>> 4
val x1692 = x1690 ^ x1691
val x1693 = x1692.toInt
val x1695 = x1694 - 1
val x1696 = x1693 & x1695
val x1698 = x1682(x1696)
var x1699: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1698
val x1700 = x1699
val x1701 = x1700 != null
if (x1701) {
while ({
val x1702 = x1699
val x1703 = x1702.hasNext
val x1709 = if (x1703) {
val x1704 = x1699
val x1705 = x1704.key
val x1706 = x1705 != x1681

x1706
} else false

x1709
}) {
val x1711 = x1699
x1697 = x1711
val x1713 = x1711.next
x1699 = x1713
()
}
val x1717 = x1697
val x1718 = x1717 == null
if (x1718) {
x1682(x1696) = null

} else {
val x1721 = x1699
val x1722 = x1721.key
val x1723 = x1722 == x1681
if (x1723) {
val x1724 = x1721.next
val x1725 = x1717.next
val x1726 = x1717.hasNext
x1717.next = x1724

} else {
()
}

}

} else {
()
}

}

} else {
()
}
val x1738 = x1617 + 1
x1611 = x1738
()
}
val x1742 = x1297.length
val x813 = 3.hashCode
val x814 = x813.toLong
val x815 = x814 >>> 20
val x816 = x814 >>> 12
val x817 = x815 ^ x816
val x818 = x817 ^ x814
val x819 = x818 >>> 7
val x820 = x818 ^ x819
val x821 = x818 >>> 4
val x822 = x820 ^ x821
val x823 = x822.toInt
val x1743 = x1742 - 1
val x1744 = x823 & x1743
val x1745 = x1297(x1744)
var x1746: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1745
val x1747 = x1746
val x1748 = x1747 == null
val x1751 = x1238 + 1
if (x1748) {
val x1749 = new Entry(3, 4)
x1297(x1744) = x1749
x954.size = x1751

} else {
while ({
val x1754 = x1746
val x1755 = x1754.hasNext
val x1761 = if (x1755) {
val x1756 = x1746
val x1757 = x1756.key
val x1758 = x1757 != 3

x1758
} else false

x1761
}) {
val x1763 = x1746
val x1764 = x1763.next
x1746 = x1764
()
}
val x1768 = x1746
val x1769 = x1768.key
val x1770 = x1769 == 3
if (x1770) {
val x1771 = x1768.value
x1768.value = 4

} else {
val x1774 = new Entry(3, 4)
val x1775 = x1768.next
val x1776 = x1768.hasNext
x1768.next = x1774
x954.size = x1751

}

}
val x1783 = x954.threshold
val x1784 = x954.size
val x1785 = x1784 >= x1783
if (x1785) {
val x1786 = x1297.length
val x1787 = x1786 == x959
if (x1787) {
x954.threshold = x63

} else {
val x1790 = 2 * x1786
val x1791 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1790)
var x1792: Int = 0
val x1819 = x1790 - 1
while ({
val x1793 = x1792
val x1794 = x1297.length
val x1795 = x1793 < x1794
x1795
}) {
val x1797 = x1792
val x1798 = x1297(x1797)
var x1799: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1798
val x1800 = x1799
val x1801 = x1800 != null
if (x1801) {
x1297(x1797) = null
while ({
val x1803 = x1799
val x1804 = x1803 != null
x1804
}) {
val x1806 = x1799
val x1807 = x1806.key
val x1821 = x1806.next
val x1808 = x1807.hashCode
val x1809 = x1808.toLong
val x1810 = x1809 >>> 20
val x1811 = x1809 >>> 12
val x1812 = x1810 ^ x1811
val x1813 = x1812 ^ x1809
val x1814 = x1813 >>> 7
val x1815 = x1813 ^ x1814
val x1816 = x1813 >>> 4
val x1817 = x1815 ^ x1816
val x1818 = x1817.toInt
val x1820 = x1818 & x1819
val x1822 = x1791(x1820)
val x1823 = x1806.hasNext
x1806.next = x1822
x1791(x1820) = x1806
x1799 = x1821
()
}

} else {
()
}
val x1831 = x1797 + 1
x1792 = x1831
()
}
x954.table = x1791
val x1836 = x958 * x1790
val x1837 = x1836.asInstanceOf[Int]
x954.threshold = x1837

}

} else {
()
}
val x1843 = x954.table
var x1844: Int = 0
var x1845: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x369
while ({
val x1846 = x1844
val x1847 = x1843.length
val x1848 = x1846 < x1847
x1848
}) {
val x1850 = x1844
val x1851 = x1843(x1850)
val x1852 = x1851 != null
if (x1852) {
x1845 = x1851
println(x1851)
while ({
val x1855 = x1845
val x1856 = x1855.hasNext
x1856
}) {
val x1858 = x1845
val x1859 = x1858.next
x1845 = x1859
val x1861 = x1845
println(x1861)

}

} else {
()
}
val x1867 = x1850 + 1
x1844 = x1867
()
}
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
