/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapComplex extends ((Int)=>(Unit)) {
def apply(x943:Int): Unit = {
val x944 = new HashMap[Int,Int](1)
val x945 = x944.table
val x946 = x945(0)
val x947 = x944.size
val x948 = x944.loadFactor
val x949 = x944.MAXIMUM_CAPACITY
val x950 = x944.threshold
val x951 = x945.length
val x7 = 1.hashCode
val x8 = x7.toLong
val x9 = x8 >>> 20
val x10 = x8 >>> 12
val x11 = x9 ^ x10
val x12 = x11 ^ x8
val x13 = x12 >>> 7
val x14 = x12 ^ x13
val x15 = x12 >>> 4
val x16 = x14 ^ x15
val x17 = x16.toInt
val x952 = x951 - 1
val x953 = x17 & x952
val x954 = x945(x953)
var x955: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x954
val x956 = x955
val x957 = x956 == null
val x960 = x947 + 1
if (x957) {
val x958 = new Entry(1, 2)
x945(x953) = x958
x944.size = x960

} else {
while ({
val x963 = x955
val x964 = x963.hasNext
val x970 = if (x964) {
val x965 = x955
val x966 = x965.key
val x967 = x966 != 1

x967
} else false

x970
}) {
val x972 = x955
val x973 = x972.next
x955 = x973
()
}
val x977 = x955
val x978 = x977.key
val x979 = x978 == 1
if (x979) {
val x980 = x977.value
x977.value = 2

} else {
val x983 = new Entry(1, 2)
val x984 = x977.next
val x985 = x977.hasNext
x977.next = x983
x944.size = x960

}

}
val x992 = x944.size
val x993 = x992 >= x950
val x994 = x951 == x949
val x62 = scala.Int.MaxValue
val x997 = 2 * x951
val x1026 = x997 - 1
val x1043 = x948 * x997
val x1044 = x1043.asInstanceOf[Int]
if (x993) {
if (x994) {
x944.threshold = x62

} else {
val x998 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x997)
var x999: Int = 0
while ({
val x1000 = x999
val x1001 = x945.length
val x1002 = x1000 < x1001
x1002
}) {
val x1004 = x999
val x1005 = x945(x1004)
var x1006: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1005
val x1007 = x1006
val x1008 = x1007 != null
if (x1008) {
x945(x1004) = null
while ({
val x1010 = x1006
val x1011 = x1010 != null
x1011
}) {
val x1013 = x1006
val x1014 = x1013.key
val x1028 = x1013.next
val x1015 = x1014.hashCode
val x1016 = x1015.toLong
val x1017 = x1016 >>> 20
val x1018 = x1016 >>> 12
val x1019 = x1017 ^ x1018
val x1020 = x1019 ^ x1016
val x1021 = x1020 >>> 7
val x1022 = x1020 ^ x1021
val x1023 = x1020 >>> 4
val x1024 = x1022 ^ x1023
val x1025 = x1024.toInt
val x1027 = x1025 & x1026
val x1029 = x998(x1027)
val x1030 = x1013.hasNext
x1013.next = x1029
x998(x1027) = x1013
x1006 = x1028
()
}

} else {
()
}
val x1038 = x1004 + 1
x999 = x1038
()
}
x944.table = x998
x944.threshold = x1044

}

} else {
()
}
val x1050 = x944.table
val x1051 = x1050.length
val x119 = 2.hashCode
val x120 = x119.toLong
val x121 = x120 >>> 20
val x122 = x120 >>> 12
val x123 = x121 ^ x122
val x124 = x123 ^ x120
val x125 = x124 >>> 7
val x126 = x124 ^ x125
val x127 = x124 >>> 4
val x128 = x126 ^ x127
val x129 = x128.toInt
val x1052 = x1051 - 1
val x1053 = x129 & x1052
val x1054 = x1050(x1053)
var x1055: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1054
val x1056 = x1055
val x1057 = x1056 == null
val x1060 = x992 + 1
if (x1057) {
val x1058 = new Entry(2, 3)
x1050(x1053) = x1058
x944.size = x1060

} else {
while ({
val x1063 = x1055
val x1064 = x1063.hasNext
val x1070 = if (x1064) {
val x1065 = x1055
val x1066 = x1065.key
val x1067 = x1066 != 2

x1067
} else false

x1070
}) {
val x1072 = x1055
val x1073 = x1072.next
x1055 = x1073
()
}
val x1077 = x1055
val x1078 = x1077.key
val x1079 = x1078 == 2
if (x1079) {
val x1080 = x1077.value
x1077.value = 3

} else {
val x1083 = new Entry(2, 3)
val x1084 = x1077.next
val x1085 = x1077.hasNext
x1077.next = x1083
x944.size = x1060

}

}
val x1092 = x944.threshold
val x1093 = x944.size
val x1094 = x1093 >= x1092
val x1095 = x1051 == x949
val x1098 = 2 * x1051
val x1127 = x1098 - 1
val x1144 = x948 * x1098
val x1145 = x1144.asInstanceOf[Int]
if (x1094) {
if (x1095) {
x944.threshold = x62

} else {
val x1099 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1098)
var x1100: Int = 0
while ({
val x1101 = x1100
val x1102 = x1050.length
val x1103 = x1101 < x1102
x1103
}) {
val x1105 = x1100
val x1106 = x1050(x1105)
var x1107: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1106
val x1108 = x1107
val x1109 = x1108 != null
if (x1109) {
x1050(x1105) = null
while ({
val x1111 = x1107
val x1112 = x1111 != null
x1112
}) {
val x1114 = x1107
val x1115 = x1114.key
val x1129 = x1114.next
val x1116 = x1115.hashCode
val x1117 = x1116.toLong
val x1118 = x1117 >>> 20
val x1119 = x1117 >>> 12
val x1120 = x1118 ^ x1119
val x1121 = x1120 ^ x1117
val x1122 = x1121 >>> 7
val x1123 = x1121 ^ x1122
val x1124 = x1121 >>> 4
val x1125 = x1123 ^ x1124
val x1126 = x1125.toInt
val x1128 = x1126 & x1127
val x1130 = x1099(x1128)
val x1131 = x1114.hasNext
x1114.next = x1130
x1099(x1128) = x1114
x1107 = x1129
()
}

} else {
()
}
val x1139 = x1105 + 1
x1100 = x1139
()
}
x944.table = x1099
x944.threshold = x1145

}

} else {
()
}
val x1151 = x944.table
val x1152 = x1151.length
val x1153 = x1152 - 1
val x1154 = x17 & x1153
val x1155 = x1151(x1154)
var x1156: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1155
val x1157 = x1156
val x1158 = x1157 == null
val x238 = None
val x1181 = if (x1158) {
x238
} else {
while ({
val x1159 = x1156
val x1160 = x1159.hasNext
val x1166 = if (x1160) {
val x1161 = x1156
val x1162 = x1161.key
val x1163 = x1162 != 1

x1163
} else false

x1166
}) {
val x1168 = x1156
val x1169 = x1168.next
x1156 = x1169
()
}
val x1173 = x1156
val x1174 = x1173.key
val x1175 = x1174 == 1
val x1179 = if (x1175) {
val x1176 = x1173.value
val x1177 = Some(x1176)
x1177
} else {
x238
}
x1179
}
val x1182 = x1181.get
var x1184: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1155
val x1185 = x1184
val x1186 = x1185 == null
val x1183 = x1182 + 1
val x1189 = x1093 + 1
if (x1186) {
val x1187 = new Entry(1, x1183)
x1151(x1154) = x1187
x944.size = x1189

} else {
while ({
val x1192 = x1184
val x1193 = x1192.hasNext
val x1199 = if (x1193) {
val x1194 = x1184
val x1195 = x1194.key
val x1196 = x1195 != 1

x1196
} else false

x1199
}) {
val x1201 = x1184
val x1202 = x1201.next
x1184 = x1202
()
}
val x1206 = x1184
val x1207 = x1206.key
val x1208 = x1207 == 1
if (x1208) {
val x1209 = x1206.value
x1206.value = x1183

} else {
val x1212 = new Entry(1, x1183)
val x1213 = x1206.next
val x1214 = x1206.hasNext
x1206.next = x1212
x944.size = x1189

}

}
val x1221 = x944.threshold
val x1222 = x944.size
val x1223 = x1222 >= x1221
val x1224 = x1152 == x949
val x1227 = 2 * x1152
val x1256 = x1227 - 1
val x1273 = x948 * x1227
val x1274 = x1273.asInstanceOf[Int]
if (x1223) {
if (x1224) {
x944.threshold = x62

} else {
val x1228 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1227)
var x1229: Int = 0
while ({
val x1230 = x1229
val x1231 = x1151.length
val x1232 = x1230 < x1231
x1232
}) {
val x1234 = x1229
val x1235 = x1151(x1234)
var x1236: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1235
val x1237 = x1236
val x1238 = x1237 != null
if (x1238) {
x1151(x1234) = null
while ({
val x1240 = x1236
val x1241 = x1240 != null
x1241
}) {
val x1243 = x1236
val x1244 = x1243.key
val x1258 = x1243.next
val x1245 = x1244.hashCode
val x1246 = x1245.toLong
val x1247 = x1246 >>> 20
val x1248 = x1246 >>> 12
val x1249 = x1247 ^ x1248
val x1250 = x1249 ^ x1246
val x1251 = x1250 >>> 7
val x1252 = x1250 ^ x1251
val x1253 = x1250 >>> 4
val x1254 = x1252 ^ x1253
val x1255 = x1254.toInt
val x1257 = x1255 & x1256
val x1259 = x1228(x1257)
val x1260 = x1243.hasNext
x1243.next = x1259
x1228(x1257) = x1243
x1236 = x1258
()
}

} else {
()
}
val x1268 = x1234 + 1
x1229 = x1268
()
}
x944.table = x1228
x944.threshold = x1274

}

} else {
()
}
val x1280 = x944.table
var x1281: Int = 0
val x362 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.Entry[Int, Int]]
var x1282: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x362
while ({
val x1283 = x1281
val x1284 = x1280.length
val x1285 = x1283 < x1284
x1285
}) {
val x1287 = x1281
val x1288 = x1280(x1287)
val x1289 = x1288 != null
if (x1289) {
x1282 = x1288
println(x1288)
while ({
val x1292 = x1282
val x1293 = x1292.hasNext
x1293
}) {
val x1295 = x1282
val x1296 = x1295.next
x1282 = x1296
val x1298 = x1282
println(x1298)

}

} else {
()
}
val x1304 = x1287 + 1
x1281 = x1304
()
}
var x1308: Int = 0
var x1309: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x362
while ({
val x1310 = x1308
val x1311 = x1280.length
val x1312 = x1310 < x1311
x1312
}) {
val x1314 = x1308
val x1315 = x1280(x1314)
val x1316 = x1315 != null
if (x1316) {
x1309 = x1315
val x1318 = x1315.key
val x1319 = x944.table
val x1331 = x1319.length
val x1320 = x1318.hashCode
val x1321 = x1320.toLong
val x1322 = x1321 >>> 20
val x1323 = x1321 >>> 12
val x1324 = x1322 ^ x1323
val x1325 = x1324 ^ x1321
val x1326 = x1325 >>> 7
val x1327 = x1325 ^ x1326
val x1328 = x1325 >>> 4
val x1329 = x1327 ^ x1328
val x1330 = x1329.toInt
val x1332 = x1331 - 1
val x1333 = x1330 & x1332
val x1334 = x1319(x1333)
var x1335: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1334
val x1336 = x944.size
val x1337 = x1335
val x1338 = x1337 == null
if (x1338) {
val x1339 = new Entry(x1318, 0)
x1319(x1333) = x1339
val x1341 = x1336 + 1
x944.size = x1341

} else {
while ({
val x1344 = x1335
val x1345 = x1344.hasNext
val x1351 = if (x1345) {
val x1346 = x1335
val x1347 = x1346.key
val x1348 = x1347 != x1318

x1348
} else false

x1351
}) {
val x1353 = x1335
val x1354 = x1353.next
x1335 = x1354
()
}
val x1358 = x1335
val x1359 = x1358.key
val x1360 = x1359 == x1318
if (x1360) {
val x1361 = x1358.value
x1358.value = 0

} else {
val x1364 = new Entry(x1318, 0)
val x1365 = x1358.next
val x1366 = x1358.hasNext
x1358.next = x1364
val x1341 = x1336 + 1
x944.size = x1341

}

}
val x1373 = x944.threshold
val x1374 = x944.MAXIMUM_CAPACITY
val x1375 = x944.size
val x1376 = x1375 >= x1373
if (x1376) {
val x1377 = x1331 == x1374
if (x1377) {
x944.threshold = x62

} else {
val x1380 = 2 * x1331
val x1381 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1380)
var x1382: Int = 0
val x1409 = x1380 - 1
while ({
val x1383 = x1382
val x1384 = x1319.length
val x1385 = x1383 < x1384
x1385
}) {
val x1387 = x1382
val x1388 = x1319(x1387)
var x1389: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1388
val x1390 = x1389
val x1391 = x1390 != null
if (x1391) {
x1319(x1387) = null
while ({
val x1393 = x1389
val x1394 = x1393 != null
x1394
}) {
val x1396 = x1389
val x1397 = x1396.key
val x1411 = x1396.next
val x1398 = x1397.hashCode
val x1399 = x1398.toLong
val x1400 = x1399 >>> 20
val x1401 = x1399 >>> 12
val x1402 = x1400 ^ x1401
val x1403 = x1402 ^ x1399
val x1404 = x1403 >>> 7
val x1405 = x1403 ^ x1404
val x1406 = x1403 >>> 4
val x1407 = x1405 ^ x1406
val x1408 = x1407.toInt
val x1410 = x1408 & x1409
val x1412 = x1381(x1410)
val x1413 = x1396.hasNext
x1396.next = x1412
x1381(x1410) = x1396
x1389 = x1411
()
}

} else {
()
}
val x1421 = x1387 + 1
x1382 = x1421
()
}
x944.table = x1381
val x1426 = x944.loadFactor
val x1427 = x1426 * x1380
val x1428 = x1427.asInstanceOf[Int]
x944.threshold = x1428

}

} else {
()
}
while ({
val x1434 = x1309
val x1435 = x1434.hasNext
x1435
}) {
val x1437 = x1309
val x1438 = x1437.next
x1309 = x1438
val x1440 = x1309
val x1441 = x1440.key
val x1442 = x944.table
val x1454 = x1442.length
val x1443 = x1441.hashCode
val x1444 = x1443.toLong
val x1445 = x1444 >>> 20
val x1446 = x1444 >>> 12
val x1447 = x1445 ^ x1446
val x1448 = x1447 ^ x1444
val x1449 = x1448 >>> 7
val x1450 = x1448 ^ x1449
val x1451 = x1448 >>> 4
val x1452 = x1450 ^ x1451
val x1453 = x1452.toInt
val x1455 = x1454 - 1
val x1456 = x1453 & x1455
val x1457 = x1442(x1456)
var x1458: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1457
val x1459 = x944.size
val x1460 = x1458
val x1461 = x1460 == null
if (x1461) {
val x1462 = new Entry(x1441, 0)
x1442(x1456) = x1462
val x1464 = x1459 + 1
x944.size = x1464

} else {
while ({
val x1467 = x1458
val x1468 = x1467.hasNext
val x1474 = if (x1468) {
val x1469 = x1458
val x1470 = x1469.key
val x1471 = x1470 != x1441

x1471
} else false

x1474
}) {
val x1476 = x1458
val x1477 = x1476.next
x1458 = x1477
()
}
val x1481 = x1458
val x1482 = x1481.key
val x1483 = x1482 == x1441
if (x1483) {
val x1484 = x1481.value
x1481.value = 0

} else {
val x1487 = new Entry(x1441, 0)
val x1488 = x1481.next
val x1489 = x1481.hasNext
x1481.next = x1487
val x1464 = x1459 + 1
x944.size = x1464

}

}
val x1496 = x944.threshold
val x1497 = x944.MAXIMUM_CAPACITY
val x1498 = x944.size
val x1499 = x1498 >= x1496
if (x1499) {
val x1500 = x1454 == x1497
if (x1500) {
x944.threshold = x62

} else {
val x1503 = 2 * x1454
val x1504 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1503)
var x1505: Int = 0
val x1532 = x1503 - 1
while ({
val x1506 = x1505
val x1507 = x1442.length
val x1508 = x1506 < x1507
x1508
}) {
val x1510 = x1505
val x1511 = x1442(x1510)
var x1512: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1511
val x1513 = x1512
val x1514 = x1513 != null
if (x1514) {
x1442(x1510) = null
while ({
val x1516 = x1512
val x1517 = x1516 != null
x1517
}) {
val x1519 = x1512
val x1520 = x1519.key
val x1534 = x1519.next
val x1521 = x1520.hashCode
val x1522 = x1521.toLong
val x1523 = x1522 >>> 20
val x1524 = x1522 >>> 12
val x1525 = x1523 ^ x1524
val x1526 = x1525 ^ x1522
val x1527 = x1526 >>> 7
val x1528 = x1526 ^ x1527
val x1529 = x1526 >>> 4
val x1530 = x1528 ^ x1529
val x1531 = x1530.toInt
val x1533 = x1531 & x1532
val x1535 = x1504(x1533)
val x1536 = x1519.hasNext
x1519.next = x1535
x1504(x1533) = x1519
x1512 = x1534
()
}

} else {
()
}
val x1544 = x1510 + 1
x1505 = x1544
()
}
x944.table = x1504
val x1549 = x944.loadFactor
val x1550 = x1549 * x1503
val x1551 = x1550.asInstanceOf[Int]
x944.threshold = x1551

}

} else {
()
}

}

} else {
()
}
val x1561 = x1314 + 1
x1308 = x1561
()
}
var x1565: Int = 0
var x1566: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x362
while ({
val x1567 = x1565
val x1568 = x1280.length
val x1569 = x1567 < x1568
x1569
}) {
val x1571 = x1565
val x1572 = x1280(x1571)
val x1573 = x1572 != null
if (x1573) {
x1566 = x1572
println(x1572)
while ({
val x1576 = x1566
val x1577 = x1576.hasNext
x1577
}) {
val x1579 = x1566
val x1580 = x1579.next
x1566 = x1580
val x1582 = x1566
println(x1582)

}

} else {
()
}
val x1588 = x1571 + 1
x1565 = x1588
()
}
var x1592: Int = 0
var x1593: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x362
while ({
val x1594 = x1592
val x1595 = x1280.length
val x1596 = x1594 < x1595
x1596
}) {
val x1598 = x1592
val x1599 = x1280(x1598)
val x1600 = x1599 != null
if (x1600) {
x1593 = x1599
val x1602 = x1599.key
val x1603 = x944.table
val x1615 = x1603.length
var x1618: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x362
val x1604 = x1602.hashCode
val x1605 = x1604.toLong
val x1606 = x1605 >>> 20
val x1607 = x1605 >>> 12
val x1608 = x1606 ^ x1607
val x1609 = x1608 ^ x1605
val x1610 = x1609 >>> 7
val x1611 = x1609 ^ x1610
val x1612 = x1609 >>> 4
val x1613 = x1611 ^ x1612
val x1614 = x1613.toInt
val x1616 = x1615 - 1
val x1617 = x1614 & x1616
val x1619 = x1603(x1617)
var x1620: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1619
val x1621 = x1620
val x1622 = x1621 != null
if (x1622) {
while ({
val x1623 = x1620
val x1624 = x1623.hasNext
val x1630 = if (x1624) {
val x1625 = x1620
val x1626 = x1625.key
val x1627 = x1626 != x1602

x1627
} else false

x1630
}) {
val x1632 = x1620
x1618 = x1632
val x1634 = x1632.next
x1620 = x1634
()
}
val x1638 = x1618
val x1639 = x1638 == null
if (x1639) {
x1603(x1617) = null

} else {
val x1642 = x1620
val x1643 = x1642.key
val x1644 = x1643 == x1602
if (x1644) {
val x1645 = x1642.next
val x1646 = x1638.next
val x1647 = x1638.hasNext
x1638.next = x1645

} else {
()
}

}

} else {
()
}
while ({
val x1655 = x1593
val x1656 = x1655.hasNext
x1656
}) {
val x1658 = x1593
val x1659 = x1658.next
x1593 = x1659
val x1661 = x1593
val x1662 = x1661.key
val x1663 = x944.table
val x1675 = x1663.length
var x1678: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x362
val x1664 = x1662.hashCode
val x1665 = x1664.toLong
val x1666 = x1665 >>> 20
val x1667 = x1665 >>> 12
val x1668 = x1666 ^ x1667
val x1669 = x1668 ^ x1665
val x1670 = x1669 >>> 7
val x1671 = x1669 ^ x1670
val x1672 = x1669 >>> 4
val x1673 = x1671 ^ x1672
val x1674 = x1673.toInt
val x1676 = x1675 - 1
val x1677 = x1674 & x1676
val x1679 = x1663(x1677)
var x1680: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1679
val x1681 = x1680
val x1682 = x1681 != null
if (x1682) {
while ({
val x1683 = x1680
val x1684 = x1683.hasNext
val x1690 = if (x1684) {
val x1685 = x1680
val x1686 = x1685.key
val x1687 = x1686 != x1662

x1687
} else false

x1690
}) {
val x1692 = x1680
x1678 = x1692
val x1694 = x1692.next
x1680 = x1694
()
}
val x1698 = x1678
val x1699 = x1698 == null
if (x1699) {
x1663(x1677) = null

} else {
val x1702 = x1680
val x1703 = x1702.key
val x1704 = x1703 == x1662
if (x1704) {
val x1705 = x1702.next
val x1706 = x1698.next
val x1707 = x1698.hasNext
x1698.next = x1705

} else {
()
}

}

} else {
()
}

}

} else {
()
}
val x1719 = x1598 + 1
x1592 = x1719
()
}
val x1723 = x1280.length
val x804 = 3.hashCode
val x805 = x804.toLong
val x806 = x805 >>> 20
val x807 = x805 >>> 12
val x808 = x806 ^ x807
val x809 = x808 ^ x805
val x810 = x809 >>> 7
val x811 = x809 ^ x810
val x812 = x809 >>> 4
val x813 = x811 ^ x812
val x814 = x813.toInt
val x1724 = x1723 - 1
val x1725 = x814 & x1724
val x1726 = x1280(x1725)
var x1727: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1726
val x1728 = x1727
val x1729 = x1728 == null
val x1732 = x1222 + 1
if (x1729) {
val x1730 = new Entry(3, 4)
x1280(x1725) = x1730
x944.size = x1732

} else {
while ({
val x1735 = x1727
val x1736 = x1735.hasNext
val x1742 = if (x1736) {
val x1737 = x1727
val x1738 = x1737.key
val x1739 = x1738 != 3

x1739
} else false

x1742
}) {
val x1744 = x1727
val x1745 = x1744.next
x1727 = x1745
()
}
val x1749 = x1727
val x1750 = x1749.key
val x1751 = x1750 == 3
if (x1751) {
val x1752 = x1749.value
x1749.value = 4

} else {
val x1755 = new Entry(3, 4)
val x1756 = x1749.next
val x1757 = x1749.hasNext
x1749.next = x1755
x944.size = x1732

}

}
val x1764 = x944.threshold
val x1765 = x944.size
val x1766 = x1765 >= x1764
val x1767 = x1723 == x949
val x1770 = 2 * x1723
val x1799 = x1770 - 1
val x1816 = x948 * x1770
val x1817 = x1816.asInstanceOf[Int]
if (x1766) {
if (x1767) {
x944.threshold = x62

} else {
val x1771 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1770)
var x1772: Int = 0
while ({
val x1773 = x1772
val x1774 = x1280.length
val x1775 = x1773 < x1774
x1775
}) {
val x1777 = x1772
val x1778 = x1280(x1777)
var x1779: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x1778
val x1780 = x1779
val x1781 = x1780 != null
if (x1781) {
x1280(x1777) = null
while ({
val x1783 = x1779
val x1784 = x1783 != null
x1784
}) {
val x1786 = x1779
val x1787 = x1786.key
val x1801 = x1786.next
val x1788 = x1787.hashCode
val x1789 = x1788.toLong
val x1790 = x1789 >>> 20
val x1791 = x1789 >>> 12
val x1792 = x1790 ^ x1791
val x1793 = x1792 ^ x1789
val x1794 = x1793 >>> 7
val x1795 = x1793 ^ x1794
val x1796 = x1793 >>> 4
val x1797 = x1795 ^ x1796
val x1798 = x1797.toInt
val x1800 = x1798 & x1799
val x1802 = x1771(x1800)
val x1803 = x1786.hasNext
x1786.next = x1802
x1771(x1800) = x1786
x1779 = x1801
()
}

} else {
()
}
val x1811 = x1777 + 1
x1772 = x1811
()
}
x944.table = x1771
x944.threshold = x1817

}

} else {
()
}
val x1823 = x944.table
var x1824: Int = 0
var x1825: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x362
while ({
val x1826 = x1824
val x1827 = x1823.length
val x1828 = x1826 < x1827
x1828
}) {
val x1830 = x1824
val x1831 = x1823(x1830)
val x1832 = x1831 != null
if (x1832) {
x1825 = x1831
println(x1831)
while ({
val x1835 = x1825
val x1836 = x1835.hasNext
x1836
}) {
val x1838 = x1825
val x1839 = x1838.next
x1825 = x1839
val x1841 = x1825
println(x1841)

}

} else {
()
}
val x1847 = x1830 + 1
x1824 = x1847
()
}
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
