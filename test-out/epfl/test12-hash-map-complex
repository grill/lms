/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapComplex extends ((Int)=>(Unit)) {
def apply(x942:Int): Unit = {
val x943 = new HashMap[Int,Int](1)
val x944 = x943.table
val x945 = x943.size
val x946 = x943.loadFactor
val x947 = x943.MAXIMUM_CAPACITY
val x948 = x943.threshold
val x949 = x944.length
val x6 = 1.hashCode
val x7 = x6.toLong
val x8 = x7 >>> 20
val x9 = x7 >>> 12
val x10 = x8 ^ x9
val x11 = x10 ^ x7
val x12 = x11 >>> 7
val x13 = x11 ^ x12
val x14 = x11 >>> 4
val x15 = x13 ^ x14
val x16 = x15.toInt
val x950 = x949 - 1
val x951 = x16 & x950
val x952 = x944(x951)
var x953 = x952
val x954 = x953
val x955 = x954 == null
val x958 = x945 + 1
if (x955) {
val x956 = new Entry(1, 2)
x944(x951) = x956
x943.size = x958

} else {
while ({
val x961 = x953
val x962 = x961.hasNext
val x968 = if (x962) {
val x963 = x953
val x964 = x963.key
val x965 = x964 != 1

x965
} else false

x968
}) {
val x970 = x953
val x971 = x970.next
x953 = x971
()
}
val x975 = x953
val x976 = x975.key
val x977 = x976 == 1
if (x977) {
val x978 = x975.value
x975.value = 2

} else {
val x981 = new Entry(1, 2)
val x982 = x975.next
val x983 = x975.hasNext
x975.next = x981
x943.size = x958

}

}
val x990 = x943.size
val x991 = x990 >= x948
val x992 = x949 == x947
val x61 = scala.Int.MaxValue
val x995 = 2 * x949
val x1024 = x995 - 1
val x1041 = x946 * x995
val x1042 = x1041.asInstanceOf[Int]
if (x991) {
if (x992) {
x943.threshold = x61

} else {
val x996 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x995)
var x997 = 0
while ({
val x998 = x997
val x999 = x944.length
val x1000 = x998 < x999
x1000
}) {
val x1002 = x997
val x1003 = x944(x1002)
var x1004 = x1003
val x1005 = x1004
val x1006 = x1005 != null
if (x1006) {
x944(x1002) = null
while ({
val x1008 = x1004
val x1009 = x1008 != null
x1009
}) {
val x1011 = x1004
val x1012 = x1011.key
val x1026 = x1011.next
val x1013 = x1012.hashCode
val x1014 = x1013.toLong
val x1015 = x1014 >>> 20
val x1016 = x1014 >>> 12
val x1017 = x1015 ^ x1016
val x1018 = x1017 ^ x1014
val x1019 = x1018 >>> 7
val x1020 = x1018 ^ x1019
val x1021 = x1018 >>> 4
val x1022 = x1020 ^ x1021
val x1023 = x1022.toInt
val x1025 = x1023 & x1024
val x1027 = x996(x1025)
val x1028 = x1011.hasNext
x1011.next = x1027
x996(x1025) = x1011
x1004 = x1026
()
}

} else {
()
}
val x1036 = x1002 + 1
x997 = x1036
()
}
x943.table = x996
x943.threshold = x1042

}

} else {
()
}
val x1048 = x943.table
val x1049 = x1048.length
val x118 = 2.hashCode
val x119 = x118.toLong
val x120 = x119 >>> 20
val x121 = x119 >>> 12
val x122 = x120 ^ x121
val x123 = x122 ^ x119
val x124 = x123 >>> 7
val x125 = x123 ^ x124
val x126 = x123 >>> 4
val x127 = x125 ^ x126
val x128 = x127.toInt
val x1050 = x1049 - 1
val x1051 = x128 & x1050
val x1052 = x1048(x1051)
var x1053 = x1052
val x1054 = x1053
val x1055 = x1054 == null
val x1058 = x990 + 1
if (x1055) {
val x1056 = new Entry(2, 3)
x1048(x1051) = x1056
x943.size = x1058

} else {
while ({
val x1061 = x1053
val x1062 = x1061.hasNext
val x1068 = if (x1062) {
val x1063 = x1053
val x1064 = x1063.key
val x1065 = x1064 != 2

x1065
} else false

x1068
}) {
val x1070 = x1053
val x1071 = x1070.next
x1053 = x1071
()
}
val x1075 = x1053
val x1076 = x1075.key
val x1077 = x1076 == 2
if (x1077) {
val x1078 = x1075.value
x1075.value = 3

} else {
val x1081 = new Entry(2, 3)
val x1082 = x1075.next
val x1083 = x1075.hasNext
x1075.next = x1081
x943.size = x1058

}

}
val x1090 = x943.threshold
val x1091 = x943.size
val x1092 = x1091 >= x1090
val x1093 = x1049 == x947
val x1096 = 2 * x1049
val x1125 = x1096 - 1
val x1142 = x946 * x1096
val x1143 = x1142.asInstanceOf[Int]
if (x1092) {
if (x1093) {
x943.threshold = x61

} else {
val x1097 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1096)
var x1098 = 0
while ({
val x1099 = x1098
val x1100 = x1048.length
val x1101 = x1099 < x1100
x1101
}) {
val x1103 = x1098
val x1104 = x1048(x1103)
var x1105 = x1104
val x1106 = x1105
val x1107 = x1106 != null
if (x1107) {
x1048(x1103) = null
while ({
val x1109 = x1105
val x1110 = x1109 != null
x1110
}) {
val x1112 = x1105
val x1113 = x1112.key
val x1127 = x1112.next
val x1114 = x1113.hashCode
val x1115 = x1114.toLong
val x1116 = x1115 >>> 20
val x1117 = x1115 >>> 12
val x1118 = x1116 ^ x1117
val x1119 = x1118 ^ x1115
val x1120 = x1119 >>> 7
val x1121 = x1119 ^ x1120
val x1122 = x1119 >>> 4
val x1123 = x1121 ^ x1122
val x1124 = x1123.toInt
val x1126 = x1124 & x1125
val x1128 = x1097(x1126)
val x1129 = x1112.hasNext
x1112.next = x1128
x1097(x1126) = x1112
x1105 = x1127
()
}

} else {
()
}
val x1137 = x1103 + 1
x1098 = x1137
()
}
x943.table = x1097
x943.threshold = x1143

}

} else {
()
}
val x1149 = x943.table
val x1150 = x1149.length
val x1151 = x1150 - 1
val x1152 = x16 & x1151
val x1153 = x1149(x1152)
var x1154 = x1153
val x1155 = x1154
val x1156 = x1155 == null
val x237 = None
val x1179 = if (x1156) {
x237
} else {
while ({
val x1157 = x1154
val x1158 = x1157.hasNext
val x1164 = if (x1158) {
val x1159 = x1154
val x1160 = x1159.key
val x1161 = x1160 != 1

x1161
} else false

x1164
}) {
val x1166 = x1154
val x1167 = x1166.next
x1154 = x1167
()
}
val x1171 = x1154
val x1172 = x1171.key
val x1173 = x1172 == 1
val x1177 = if (x1173) {
val x1174 = x1171.value
val x1175 = Some(x1174)
x1175
} else {
x237
}
x1177
}
val x1180 = x1179.get
var x1182 = x1153
val x1183 = x1182
val x1184 = x1183 == null
val x1181 = x1180 + 1
val x1187 = x1091 + 1
if (x1184) {
val x1185 = new Entry(1, x1181)
x1149(x1152) = x1185
x943.size = x1187

} else {
while ({
val x1190 = x1182
val x1191 = x1190.hasNext
val x1197 = if (x1191) {
val x1192 = x1182
val x1193 = x1192.key
val x1194 = x1193 != 1

x1194
} else false

x1197
}) {
val x1199 = x1182
val x1200 = x1199.next
x1182 = x1200
()
}
val x1204 = x1182
val x1205 = x1204.key
val x1206 = x1205 == 1
if (x1206) {
val x1207 = x1204.value
x1204.value = x1181

} else {
val x1210 = new Entry(1, x1181)
val x1211 = x1204.next
val x1212 = x1204.hasNext
x1204.next = x1210
x943.size = x1187

}

}
val x1219 = x943.threshold
val x1220 = x943.size
val x1221 = x1220 >= x1219
val x1222 = x1150 == x947
val x1225 = 2 * x1150
val x1254 = x1225 - 1
val x1271 = x946 * x1225
val x1272 = x1271.asInstanceOf[Int]
if (x1221) {
if (x1222) {
x943.threshold = x61

} else {
val x1226 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1225)
var x1227 = 0
while ({
val x1228 = x1227
val x1229 = x1149.length
val x1230 = x1228 < x1229
x1230
}) {
val x1232 = x1227
val x1233 = x1149(x1232)
var x1234 = x1233
val x1235 = x1234
val x1236 = x1235 != null
if (x1236) {
x1149(x1232) = null
while ({
val x1238 = x1234
val x1239 = x1238 != null
x1239
}) {
val x1241 = x1234
val x1242 = x1241.key
val x1256 = x1241.next
val x1243 = x1242.hashCode
val x1244 = x1243.toLong
val x1245 = x1244 >>> 20
val x1246 = x1244 >>> 12
val x1247 = x1245 ^ x1246
val x1248 = x1247 ^ x1244
val x1249 = x1248 >>> 7
val x1250 = x1248 ^ x1249
val x1251 = x1248 >>> 4
val x1252 = x1250 ^ x1251
val x1253 = x1252.toInt
val x1255 = x1253 & x1254
val x1257 = x1226(x1255)
val x1258 = x1241.hasNext
x1241.next = x1257
x1226(x1255) = x1241
x1234 = x1256
()
}

} else {
()
}
val x1266 = x1232 + 1
x1227 = x1266
()
}
x943.table = x1226
x943.threshold = x1272

}

} else {
()
}
val x1278 = x943.table
var x1279 = 0
val x361 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.Entry[Int, Int]]
var x1280 = x361
while ({
val x1281 = x1279
val x1282 = x1278.length
val x1283 = x1281 < x1282
x1283
}) {
val x1285 = x1279
val x1286 = x1278(x1285)
val x1287 = x1286 != null
if (x1287) {
x1280 = x1286
println(x1286)
while ({
val x1290 = x1280
val x1291 = x1290.hasNext
x1291
}) {
val x1293 = x1280
val x1294 = x1293.next
x1280 = x1294
val x1296 = x1280
println(x1296)

}

} else {
()
}
val x1302 = x1285 + 1
x1279 = x1302
()
}
var x1306 = 0
var x1307 = x361
while ({
val x1308 = x1306
val x1309 = x1278.length
val x1310 = x1308 < x1309
x1310
}) {
val x1312 = x1306
val x1313 = x1278(x1312)
val x1314 = x1313 != null
if (x1314) {
x1307 = x1313
val x1316 = x1313.key
val x1317 = x943.table
val x1329 = x1317.length
val x1318 = x1316.hashCode
val x1319 = x1318.toLong
val x1320 = x1319 >>> 20
val x1321 = x1319 >>> 12
val x1322 = x1320 ^ x1321
val x1323 = x1322 ^ x1319
val x1324 = x1323 >>> 7
val x1325 = x1323 ^ x1324
val x1326 = x1323 >>> 4
val x1327 = x1325 ^ x1326
val x1328 = x1327.toInt
val x1330 = x1329 - 1
val x1331 = x1328 & x1330
val x1332 = x1317(x1331)
var x1333 = x1332
val x1334 = x943.size
val x1335 = x1333
val x1336 = x1335 == null
if (x1336) {
val x1337 = new Entry(x1316, 0)
x1317(x1331) = x1337
val x1339 = x1334 + 1
x943.size = x1339

} else {
while ({
val x1342 = x1333
val x1343 = x1342.hasNext
val x1349 = if (x1343) {
val x1344 = x1333
val x1345 = x1344.key
val x1346 = x1345 != x1316

x1346
} else false

x1349
}) {
val x1351 = x1333
val x1352 = x1351.next
x1333 = x1352
()
}
val x1356 = x1333
val x1357 = x1356.key
val x1358 = x1357 == x1316
if (x1358) {
val x1359 = x1356.value
x1356.value = 0

} else {
val x1362 = new Entry(x1316, 0)
val x1363 = x1356.next
val x1364 = x1356.hasNext
x1356.next = x1362
val x1339 = x1334 + 1
x943.size = x1339

}

}
val x1371 = x943.threshold
val x1372 = x943.MAXIMUM_CAPACITY
val x1373 = x943.size
val x1374 = x1373 >= x1371
if (x1374) {
val x1375 = x1329 == x1372
if (x1375) {
x943.threshold = x61

} else {
val x1378 = 2 * x1329
val x1379 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1378)
var x1380 = 0
val x1407 = x1378 - 1
while ({
val x1381 = x1380
val x1382 = x1317.length
val x1383 = x1381 < x1382
x1383
}) {
val x1385 = x1380
val x1386 = x1317(x1385)
var x1387 = x1386
val x1388 = x1387
val x1389 = x1388 != null
if (x1389) {
x1317(x1385) = null
while ({
val x1391 = x1387
val x1392 = x1391 != null
x1392
}) {
val x1394 = x1387
val x1395 = x1394.key
val x1409 = x1394.next
val x1396 = x1395.hashCode
val x1397 = x1396.toLong
val x1398 = x1397 >>> 20
val x1399 = x1397 >>> 12
val x1400 = x1398 ^ x1399
val x1401 = x1400 ^ x1397
val x1402 = x1401 >>> 7
val x1403 = x1401 ^ x1402
val x1404 = x1401 >>> 4
val x1405 = x1403 ^ x1404
val x1406 = x1405.toInt
val x1408 = x1406 & x1407
val x1410 = x1379(x1408)
val x1411 = x1394.hasNext
x1394.next = x1410
x1379(x1408) = x1394
x1387 = x1409
()
}

} else {
()
}
val x1419 = x1385 + 1
x1380 = x1419
()
}
x943.table = x1379
val x1424 = x943.loadFactor
val x1425 = x1424 * x1378
val x1426 = x1425.asInstanceOf[Int]
x943.threshold = x1426

}

} else {
()
}
while ({
val x1432 = x1307
val x1433 = x1432.hasNext
x1433
}) {
val x1435 = x1307
val x1436 = x1435.next
x1307 = x1436
val x1438 = x1307
val x1439 = x1438.key
val x1440 = x943.table
val x1452 = x1440.length
val x1441 = x1439.hashCode
val x1442 = x1441.toLong
val x1443 = x1442 >>> 20
val x1444 = x1442 >>> 12
val x1445 = x1443 ^ x1444
val x1446 = x1445 ^ x1442
val x1447 = x1446 >>> 7
val x1448 = x1446 ^ x1447
val x1449 = x1446 >>> 4
val x1450 = x1448 ^ x1449
val x1451 = x1450.toInt
val x1453 = x1452 - 1
val x1454 = x1451 & x1453
val x1455 = x1440(x1454)
var x1456 = x1455
val x1457 = x943.size
val x1458 = x1456
val x1459 = x1458 == null
if (x1459) {
val x1460 = new Entry(x1439, 0)
x1440(x1454) = x1460
val x1462 = x1457 + 1
x943.size = x1462

} else {
while ({
val x1465 = x1456
val x1466 = x1465.hasNext
val x1472 = if (x1466) {
val x1467 = x1456
val x1468 = x1467.key
val x1469 = x1468 != x1439

x1469
} else false

x1472
}) {
val x1474 = x1456
val x1475 = x1474.next
x1456 = x1475
()
}
val x1479 = x1456
val x1480 = x1479.key
val x1481 = x1480 == x1439
if (x1481) {
val x1482 = x1479.value
x1479.value = 0

} else {
val x1485 = new Entry(x1439, 0)
val x1486 = x1479.next
val x1487 = x1479.hasNext
x1479.next = x1485
val x1462 = x1457 + 1
x943.size = x1462

}

}
val x1494 = x943.threshold
val x1495 = x943.MAXIMUM_CAPACITY
val x1496 = x943.size
val x1497 = x1496 >= x1494
if (x1497) {
val x1498 = x1452 == x1495
if (x1498) {
x943.threshold = x61

} else {
val x1501 = 2 * x1452
val x1502 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1501)
var x1503 = 0
val x1530 = x1501 - 1
while ({
val x1504 = x1503
val x1505 = x1440.length
val x1506 = x1504 < x1505
x1506
}) {
val x1508 = x1503
val x1509 = x1440(x1508)
var x1510 = x1509
val x1511 = x1510
val x1512 = x1511 != null
if (x1512) {
x1440(x1508) = null
while ({
val x1514 = x1510
val x1515 = x1514 != null
x1515
}) {
val x1517 = x1510
val x1518 = x1517.key
val x1532 = x1517.next
val x1519 = x1518.hashCode
val x1520 = x1519.toLong
val x1521 = x1520 >>> 20
val x1522 = x1520 >>> 12
val x1523 = x1521 ^ x1522
val x1524 = x1523 ^ x1520
val x1525 = x1524 >>> 7
val x1526 = x1524 ^ x1525
val x1527 = x1524 >>> 4
val x1528 = x1526 ^ x1527
val x1529 = x1528.toInt
val x1531 = x1529 & x1530
val x1533 = x1502(x1531)
val x1534 = x1517.hasNext
x1517.next = x1533
x1502(x1531) = x1517
x1510 = x1532
()
}

} else {
()
}
val x1542 = x1508 + 1
x1503 = x1542
()
}
x943.table = x1502
val x1547 = x943.loadFactor
val x1548 = x1547 * x1501
val x1549 = x1548.asInstanceOf[Int]
x943.threshold = x1549

}

} else {
()
}

}

} else {
()
}
val x1559 = x1312 + 1
x1306 = x1559
()
}
var x1563 = 0
var x1564 = x361
while ({
val x1565 = x1563
val x1566 = x1278.length
val x1567 = x1565 < x1566
x1567
}) {
val x1569 = x1563
val x1570 = x1278(x1569)
val x1571 = x1570 != null
if (x1571) {
x1564 = x1570
println(x1570)
while ({
val x1574 = x1564
val x1575 = x1574.hasNext
x1575
}) {
val x1577 = x1564
val x1578 = x1577.next
x1564 = x1578
val x1580 = x1564
println(x1580)

}

} else {
()
}
val x1586 = x1569 + 1
x1563 = x1586
()
}
var x1590 = 0
var x1591 = x361
while ({
val x1592 = x1590
val x1593 = x1278.length
val x1594 = x1592 < x1593
x1594
}) {
val x1596 = x1590
val x1597 = x1278(x1596)
val x1598 = x1597 != null
if (x1598) {
x1591 = x1597
val x1600 = x1597.key
val x1601 = x943.table
val x1613 = x1601.length
var x1616 = x361
val x1602 = x1600.hashCode
val x1603 = x1602.toLong
val x1604 = x1603 >>> 20
val x1605 = x1603 >>> 12
val x1606 = x1604 ^ x1605
val x1607 = x1606 ^ x1603
val x1608 = x1607 >>> 7
val x1609 = x1607 ^ x1608
val x1610 = x1607 >>> 4
val x1611 = x1609 ^ x1610
val x1612 = x1611.toInt
val x1614 = x1613 - 1
val x1615 = x1612 & x1614
val x1617 = x1601(x1615)
var x1618 = x1617
val x1619 = x1618
val x1620 = x1619 != null
if (x1620) {
while ({
val x1621 = x1618
val x1622 = x1621.hasNext
val x1628 = if (x1622) {
val x1623 = x1618
val x1624 = x1623.key
val x1625 = x1624 != x1600

x1625
} else false

x1628
}) {
val x1630 = x1618
x1616 = x1630
val x1632 = x1630.next
x1618 = x1632
()
}
val x1636 = x1616
val x1637 = x1636 == null
if (x1637) {
x1601(x1615) = null

} else {
val x1640 = x1618
val x1641 = x1640.key
val x1642 = x1641 == x1600
if (x1642) {
val x1643 = x1640.next
val x1644 = x1636.next
val x1645 = x1636.hasNext
x1636.next = x1643

} else {
()
}

}

} else {
()
}
while ({
val x1653 = x1591
val x1654 = x1653.hasNext
x1654
}) {
val x1656 = x1591
val x1657 = x1656.next
x1591 = x1657
val x1659 = x1591
val x1660 = x1659.key
val x1661 = x943.table
val x1673 = x1661.length
var x1676 = x361
val x1662 = x1660.hashCode
val x1663 = x1662.toLong
val x1664 = x1663 >>> 20
val x1665 = x1663 >>> 12
val x1666 = x1664 ^ x1665
val x1667 = x1666 ^ x1663
val x1668 = x1667 >>> 7
val x1669 = x1667 ^ x1668
val x1670 = x1667 >>> 4
val x1671 = x1669 ^ x1670
val x1672 = x1671.toInt
val x1674 = x1673 - 1
val x1675 = x1672 & x1674
val x1677 = x1661(x1675)
var x1678 = x1677
val x1679 = x1678
val x1680 = x1679 != null
if (x1680) {
while ({
val x1681 = x1678
val x1682 = x1681.hasNext
val x1688 = if (x1682) {
val x1683 = x1678
val x1684 = x1683.key
val x1685 = x1684 != x1660

x1685
} else false

x1688
}) {
val x1690 = x1678
x1676 = x1690
val x1692 = x1690.next
x1678 = x1692
()
}
val x1696 = x1676
val x1697 = x1696 == null
if (x1697) {
x1661(x1675) = null

} else {
val x1700 = x1678
val x1701 = x1700.key
val x1702 = x1701 == x1660
if (x1702) {
val x1703 = x1700.next
val x1704 = x1696.next
val x1705 = x1696.hasNext
x1696.next = x1703

} else {
()
}

}

} else {
()
}

}

} else {
()
}
val x1717 = x1596 + 1
x1590 = x1717
()
}
val x1721 = x1278.length
val x803 = 3.hashCode
val x804 = x803.toLong
val x805 = x804 >>> 20
val x806 = x804 >>> 12
val x807 = x805 ^ x806
val x808 = x807 ^ x804
val x809 = x808 >>> 7
val x810 = x808 ^ x809
val x811 = x808 >>> 4
val x812 = x810 ^ x811
val x813 = x812.toInt
val x1722 = x1721 - 1
val x1723 = x813 & x1722
val x1724 = x1278(x1723)
var x1725 = x1724
val x1726 = x1725
val x1727 = x1726 == null
val x1730 = x1220 + 1
if (x1727) {
val x1728 = new Entry(3, 4)
x1278(x1723) = x1728
x943.size = x1730

} else {
while ({
val x1733 = x1725
val x1734 = x1733.hasNext
val x1740 = if (x1734) {
val x1735 = x1725
val x1736 = x1735.key
val x1737 = x1736 != 3

x1737
} else false

x1740
}) {
val x1742 = x1725
val x1743 = x1742.next
x1725 = x1743
()
}
val x1747 = x1725
val x1748 = x1747.key
val x1749 = x1748 == 3
if (x1749) {
val x1750 = x1747.value
x1747.value = 4

} else {
val x1753 = new Entry(3, 4)
val x1754 = x1747.next
val x1755 = x1747.hasNext
x1747.next = x1753
x943.size = x1730

}

}
val x1762 = x943.threshold
val x1763 = x943.size
val x1764 = x1763 >= x1762
val x1765 = x1721 == x947
val x1768 = 2 * x1721
val x1797 = x1768 - 1
val x1814 = x946 * x1768
val x1815 = x1814.asInstanceOf[Int]
if (x1764) {
if (x1765) {
x943.threshold = x61

} else {
val x1769 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x1768)
var x1770 = 0
while ({
val x1771 = x1770
val x1772 = x1278.length
val x1773 = x1771 < x1772
x1773
}) {
val x1775 = x1770
val x1776 = x1278(x1775)
var x1777 = x1776
val x1778 = x1777
val x1779 = x1778 != null
if (x1779) {
x1278(x1775) = null
while ({
val x1781 = x1777
val x1782 = x1781 != null
x1782
}) {
val x1784 = x1777
val x1785 = x1784.key
val x1799 = x1784.next
val x1786 = x1785.hashCode
val x1787 = x1786.toLong
val x1788 = x1787 >>> 20
val x1789 = x1787 >>> 12
val x1790 = x1788 ^ x1789
val x1791 = x1790 ^ x1787
val x1792 = x1791 >>> 7
val x1793 = x1791 ^ x1792
val x1794 = x1791 >>> 4
val x1795 = x1793 ^ x1794
val x1796 = x1795.toInt
val x1798 = x1796 & x1797
val x1800 = x1769(x1798)
val x1801 = x1784.hasNext
x1784.next = x1800
x1769(x1798) = x1784
x1777 = x1799
()
}

} else {
()
}
val x1809 = x1775 + 1
x1770 = x1809
()
}
x943.table = x1769
x943.threshold = x1815

}

} else {
()
}
val x1821 = x943.table
var x1822 = 0
var x1823 = x361
while ({
val x1824 = x1822
val x1825 = x1821.length
val x1826 = x1824 < x1825
x1826
}) {
val x1828 = x1822
val x1829 = x1821(x1828)
val x1830 = x1829 != null
if (x1830) {
x1823 = x1829
println(x1829)
while ({
val x1833 = x1823
val x1834 = x1833.hasNext
x1834
}) {
val x1836 = x1823
val x1837 = x1836.next
x1823 = x1837
val x1839 = x1823
println(x1839)

}

} else {
()
}
val x1845 = x1828 + 1
x1822 = x1845
()
}
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
