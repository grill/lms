/*****************************************
  Emitting Generated Code                  
*******************************************/
class IntHashMapGetAndUpdateOptVar extends ((Int)=>(Unit)) {
def apply(x375:Int): Unit = {
val x376 = new HashMap[Int,Int](1)
val x377 = x376.table
val x378 = x377(0)
val x379 = x376.size
val x380 = x376.loadFactor
val x381 = x376.MAXIMUM_CAPACITY
val x382 = x376.threshold
var x383: Int = 1
x383 = 2
val x385 = x383
val x386 = x377.length
val x10 = 2.hashCode
val x11 = x10.toLong
val x12 = x11 >>> 20
val x13 = x11 >>> 12
val x14 = x12 ^ x13
val x15 = x14 ^ x11
val x16 = x15 >>> 7
val x17 = x15 ^ x16
val x18 = x15 >>> 4
val x19 = x17 ^ x18
val x20 = x19.toInt
val x387 = x386 - 1
val x388 = x20 & x387
val x389 = x377(x388)
var x390: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x389
val x391 = x390
val x392 = x391 == null
val x395 = x379 + 1
if (x392) {
val x393 = new Entry(2, x385)
x377(x388) = x393
x376.size = x395

} else {
while ({
val x398 = x390
val x399 = x398.hasNext
val x405 = if (x399) {
val x400 = x390
val x401 = x400.key
val x402 = x401 != 2

x402
} else false

x405
}) {
val x407 = x390
val x408 = x407.next
x390 = x408
()
}
val x412 = x390
val x413 = x412.key
val x414 = x413 == 2
if (x414) {
val x415 = x412.value
x412.value = x385

} else {
val x418 = new Entry(2, x385)
val x419 = x412.next
val x420 = x412.hasNext
x412.next = x418
x376.size = x395

}

}
val x427 = x376.size
val x428 = x427 >= x382
val x66 = scala.Int.MaxValue
if (x428) {
val x429 = x377.length
val x430 = x429 == x381
if (x430) {
x376.threshold = x66

} else {
val x433 = 2 * x429
val x434 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x433)
var x435: Int = 0
val x462 = x433 - 1
while ({
val x436 = x435
val x437 = x377.length
val x438 = x436 < x437
x438
}) {
val x440 = x435
val x441 = x377(x440)
var x442: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x441
val x443 = x442
val x444 = x443 != null
if (x444) {
x377(x440) = null
while ({
val x446 = x442
val x447 = x446 != null
x447
}) {
val x449 = x442
val x450 = x449.key
val x464 = x449.next
val x451 = x450.hashCode
val x452 = x451.toLong
val x453 = x452 >>> 20
val x454 = x452 >>> 12
val x455 = x453 ^ x454
val x456 = x455 ^ x452
val x457 = x456 >>> 7
val x458 = x456 ^ x457
val x459 = x456 >>> 4
val x460 = x458 ^ x459
val x461 = x460.toInt
val x463 = x461 & x462
val x465 = x434(x463)
val x466 = x449.hasNext
x449.next = x465
x434(x463) = x449
x442 = x464
()
}

} else {
()
}
val x474 = x440 + 1
x435 = x474
()
}
x376.table = x434
val x479 = x380 * x433
val x480 = x479.asInstanceOf[Int]
x376.threshold = x480

}

} else {
()
}
val x486 = x376.table
val x498 = x486.length
val x487 = x385.hashCode
val x488 = x487.toLong
val x489 = x488 >>> 20
val x490 = x488 >>> 12
val x491 = x489 ^ x490
val x492 = x491 ^ x488
val x493 = x492 >>> 7
val x494 = x492 ^ x493
val x495 = x492 >>> 4
val x496 = x494 ^ x495
val x497 = x496.toInt
val x499 = x498 - 1
val x500 = x497 & x499
val x501 = x486(x500)
var x502: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x501
val x503 = x502
val x504 = x503 == null
val x141 = None
val x527 = if (x504) {
x141
} else {
while ({
val x505 = x502
val x506 = x505.hasNext
val x512 = if (x506) {
val x507 = x502
val x508 = x507.key
val x509 = x508 != x385

x509
} else false

x512
}) {
val x514 = x502
val x515 = x514.next
x502 = x515
()
}
val x519 = x502
val x520 = x519.key
val x521 = x520 == x385
val x525 = if (x521) {
val x522 = x519.value
val x523 = Some(x522)
x523
} else {
x141
}
x525
}
val x528 = x527.get
val x530 = x486.length
val x167 = 3.hashCode
val x168 = x167.toLong
val x169 = x168 >>> 20
val x170 = x168 >>> 12
val x171 = x169 ^ x170
val x172 = x171 ^ x168
val x173 = x172 >>> 7
val x174 = x172 ^ x173
val x175 = x172 >>> 4
val x176 = x174 ^ x175
val x177 = x176.toInt
val x531 = x530 - 1
val x532 = x177 & x531
val x533 = x486(x532)
var x534: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x533
val x535 = x534
val x536 = x535 == null
val x529 = x528 + 1
val x539 = x427 + 1
if (x536) {
val x537 = new Entry(3, x529)
x486(x532) = x537
x376.size = x539

} else {
while ({
val x542 = x534
val x543 = x542.hasNext
val x549 = if (x543) {
val x544 = x534
val x545 = x544.key
val x546 = x545 != 3

x546
} else false

x549
}) {
val x551 = x534
val x552 = x551.next
x534 = x552
()
}
val x556 = x534
val x557 = x556.key
val x558 = x557 == 3
if (x558) {
val x559 = x556.value
x556.value = x529

} else {
val x562 = new Entry(3, x529)
val x563 = x556.next
val x564 = x556.hasNext
x556.next = x562
x376.size = x539

}

}
val x571 = x376.threshold
val x572 = x376.size
val x573 = x572 >= x571
if (x573) {
val x574 = x486.length
val x575 = x574 == x381
if (x575) {
x376.threshold = x66

} else {
val x578 = 2 * x574
val x579 = new Array[scala.virtualization.lms.epfl.test12.Entry[Int, Int]](x578)
var x580: Int = 0
val x607 = x578 - 1
while ({
val x581 = x580
val x582 = x486.length
val x583 = x581 < x582
x583
}) {
val x585 = x580
val x586 = x486(x585)
var x587: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x586
val x588 = x587
val x589 = x588 != null
if (x589) {
x486(x585) = null
while ({
val x591 = x587
val x592 = x591 != null
x592
}) {
val x594 = x587
val x595 = x594.key
val x609 = x594.next
val x596 = x595.hashCode
val x597 = x596.toLong
val x598 = x597 >>> 20
val x599 = x597 >>> 12
val x600 = x598 ^ x599
val x601 = x600 ^ x597
val x602 = x601 >>> 7
val x603 = x601 ^ x602
val x604 = x601 >>> 4
val x605 = x603 ^ x604
val x606 = x605.toInt
val x608 = x606 & x607
val x610 = x579(x608)
val x611 = x594.hasNext
x594.next = x610
x579(x608) = x594
x587 = x609
()
}

} else {
()
}
val x619 = x585 + 1
x580 = x619
()
}
x376.table = x579
val x624 = x380 * x578
val x625 = x624.asInstanceOf[Int]
x376.threshold = x625

}

} else {
()
}
val x631 = x376.table
var x632: Int = 0
val x281 = null.asInstanceOf[scala.virtualization.lms.epfl.test12.Entry[Int, Int]]
var x633: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x281
while ({
val x634 = x632
val x635 = x631.length
val x636 = x634 < x635
x636
}) {
val x638 = x632
val x639 = x631(x638)
val x640 = x639 != null
if (x640) {
x633 = x639
println(x639)
while ({
val x643 = x633
val x644 = x643.hasNext
x644
}) {
val x646 = x633
val x647 = x646.next
x633 = x647
val x649 = x633
println(x649)

}

} else {
()
}
val x655 = x638 + 1
x632 = x655
()
}
val x659 = x631.length
var x662: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x281
val x660 = x659 - 1
val x661 = x20 & x660
val x663 = x631(x661)
var x664: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x663
val x665 = x664
val x666 = x665 != null
if (x666) {
while ({
val x667 = x664
val x668 = x667.hasNext
val x674 = if (x668) {
val x669 = x664
val x670 = x669.key
val x671 = x670 != 2

x671
} else false

x674
}) {
val x676 = x664
x662 = x676
val x678 = x676.next
x664 = x678
()
}
val x682 = x662
val x683 = x682 == null
if (x683) {
x631(x661) = null

} else {
val x686 = x664
val x687 = x686.key
val x688 = x687 == 2
if (x688) {
val x689 = x686.next
val x690 = x682.next
val x691 = x682.hasNext
x682.next = x689

} else {
()
}

}

} else {
()
}
var x699: Int = 0
var x700: scala.virtualization.lms.epfl.test12.Entry[Int, Int] = x281
while ({
val x701 = x699
val x702 = x631.length
val x703 = x701 < x702
x703
}) {
val x705 = x699
val x706 = x631(x705)
val x707 = x706 != null
if (x707) {
x700 = x706
println(x706)
while ({
val x710 = x700
val x711 = x710.hasNext
x711
}) {
val x713 = x700
val x714 = x713.next
x700 = x714
val x716 = x700
println(x716)

}

} else {
()
}
val x722 = x705 + 1
x699 = x722
()
}
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
