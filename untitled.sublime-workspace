{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"reflectWr",
				"reflectWriteMutable"
			],
			[
				"eq",
				"equalReadOperation"
			]
		]
	},
	"buffers":
	[
		{
			"file": "test-src/epfl/test12-collections/TestArrayOps.scala",
			"settings":
			{
				"buffer_size": 43513,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/CastingOps.scala",
			"settings":
			{
				"buffer_size": 2769,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/ArrayOps.scala",
			"settings":
			{
				"buffer_size": 18826,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/internal/Effects.scala",
			"settings":
			{
				"buffer_size": 32516,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/Variables.scala",
			"settings":
			{
				"buffer_size": 14608,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/While.scala",
			"settings":
			{
				"buffer_size": 6465,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/Base.scala",
			"settings":
			{
				"buffer_size": 3417,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "package scala.virtualization.lms\npackage internal\n\nimport scala.reflect.SourceContext\nimport scala.annotation.unchecked.uncheckedVariance\nimport scala.collection.mutable.ListBuffer\nimport java.lang.{StackTraceElement,Thread}\n\n\n/**\n * The Expressions trait houses common AST nodes. It also manages a list of encountered Definitions which\n * allows for common sub-expression elimination (CSE).  \n * \n * @since 0.1\n */\ntrait Expressions extends Utils {\n\n  abstract class Exp[+T:Manifest] { // constants/symbols (atomic)\n    def tp: Manifest[T @uncheckedVariance] = manifest[T] //invariant position! but hey...\n    def pos: List[SourceContext] = Nil\n  }\n\n  case class Const[+T:Manifest](x: T) extends Exp[T] {\n    /**\n    * equals implementation in Const can not simply rely on default\n    * implementation for a case class, because we should check the \n    * type of Const for equality test.\n    * Otherwise, we might end-up generating code with wrong typing,\n    * specially upon CSE.\n    *\n    * For example, have a look at test1-arith/TestConstCSE:\n    * \n    * trait Prog extends ScalaOpsPkg {\n    *   def test1(test_param: Rep[Boolean], acc: Rep[Long]): Rep[Long] = {\n    *     val dblVal = if(test_param) unit(1.0) else unit(0.0)\n    *     val lngVal = if(test_param) unit(1L) else unit(0L)\n    *     auxMethod(acc + lngVal, dblVal)\n    *   }\n    *\n    *   def auxMethod(val1: Rep[Long], val2: Rep[Double]): Rep[Long] = {\n    *     val1 + unit(133L) + rep_asinstanceof[Double, Long](val2,manifest[Double],manifest[Long])\n    *   }\n    * }\n    *\n    * That would generate a code containing a compile error:\n    * \n    *       class test1 extends ((Boolean, Long)=>(Long)) {\n    *         def apply(x0:Boolean, x1:Long): Long = {\n    *           val x2 = if (x0) {\n    *             1.0\n    *           } else {\n    *             0.0\n    *           }\n    *           val x3 = x1 + x2\n    *           val x4 = x3 + 133L\n    *           val x5 = x2.asInstanceOf[Long]\n    *           val x6 = x4 + x5\n    *           x6\n    *         }\n    *       }\n    *\n    *       <stdin>:15: error: type mismatch;\n    *        found   : Double\n    *        required: Long\n    *       x6\n    *       ^\n    *       one error found\n    *       compilation: had errors\n    *\n    * But, by introducing this new implementation for equals, the\n    * correct code will be generated:\n    *\n    *       class test1 extends ((Boolean, Long)=>(Long)) {\n    *         def apply(x0:Boolean, x1:Long): Long = {\n    *           val x3 = if (x0) {\n    *             1L\n    *           } else {\n    *             0L\n    *           }\n    *           val x4 = x1 + x3\n    *           val x5 = x4 + 133L\n    *           val x2 = if (x0) {\n    *             1.0\n    *           } else {\n    *             0.0\n    *           }\n    *           val x6 = x2.asInstanceOf[Long]\n    *           val x7 = x5 + x6\n    *           x7\n    *         }\n    *       }\n    *\n    *       compilation: ok\n    */\n    override def equals(that: Any) = that match {\n      case c@Const(y) => if(y == x) {\n        val thisTp = tp\n        //val thatTp = c.tp\n        if (Const.isNumeric[T](thisTp) /*&& isNumeric(thatTp)*/)\n          thisTp == c.tp //thatTp\n        else\n          true\n      } else false\n      case _ => false \n    }\n  }\n\n  object Const {\n    val doubleManifest: Manifest[Double] = manifest[Double]\n    val floatManifest: Manifest[Float] = manifest[Float]\n    val longManifest: Manifest[Long] = manifest[Long]\n    val intManifest: Manifest[Int] = manifest[Int]\n    val shortManifest: Manifest[Short] = manifest[Short]\n    val byteManifest: Manifest[Byte] = manifest[Byte]\n\n    def isNumeric[T:Manifest](m: Manifest[T]) = m == doubleManifest ||\n                                                m == floatManifest ||\n                                                m == longManifest ||\n                                                m == intManifest ||\n                                                m == shortManifest ||\n                                                m == byteManifest\n  }\n\n  case class Sym[+T:Manifest](val id: Int) extends Exp[T] {\n    val attributes: scala.collection.mutable.Map[Any,Any] = scala.collection.mutable.ListMap.empty\n    var sourceInfo = Thread.currentThread.getStackTrace // will go away\n    var sourceContexts: List[SourceContext] = Nil\n    override def pos = sourceContexts\n    def withPos(pos: List[SourceContext]) = { sourceContexts :::= pos; this }\n  }\n\n  case class Variable[+T](val e: Exp[Variable[T]]) {\n     var emitted = false;\n  } // TODO: decide whether it should stay here ... FIXME: should be invariant\n\n  var nVars = 0\n  def fresh[T:Manifest]: Sym[T] = Sym[T] { \n    nVars += 1;  \n    //if (nVars%1000 == 0) println(\"nVars=\"+nVars);  \n    nVars - 1 \n  }\n\n  def fresh[T:Manifest](pos: List[SourceContext]): Sym[T] = fresh[T].withPos(pos)\n\n  def quotePos(e: Exp[Any]): String = e.pos match {\n    case Nil => \"<unknown>\"\n    case cs => \n      def all(cs: SourceContext): List[SourceContext] = cs.parent match {\n        case None => List(cs)\n        case Some(p) => cs::all(p)\n      }\n    cs.map(c => all(c).reverse.map(c => c.fileName.split(\"/\").last + \":\" + c.line).mkString(\"//\")).mkString(\";\")\n  }\n\n/*\n  def fresh[T:Manifest] = {\n    val (name, id, nameId) = nextName(\"x\")\n    val sym = Sym[T](id)\n    sym.name = name\n    sym.nameId = nameId\n    sym\n  }\n\n  def fresh[T:Manifest](d: Def[T], ctx: Option[SourceContext]) = {\n    def enclosingNamedContext(sc: SourceContext): Option[SourceContext] = sc.bindings match {\n      case (null, _) :: _ =>\n        if (!sc.parent.isEmpty) enclosingNamedContext(sc.parent.get)\n        else None\n      case (name, line) :: _ =>\n        Some(sc)\n    }\n\n    // create base name from source context\n    val (basename, line, srcCtx) = if (!ctx.isEmpty) {\n      enclosingNamedContext(ctx.get) match {\n        case None =>\n          // no enclosing context has variable assignment\n          var outermost = ctx.get\n          while (!outermost.parent.isEmpty) {\n            outermost = outermost.parent.get\n          }\n          (\"x\", 0, Some(outermost))\n        case Some(sc) => sc.bindings match {\n          case (n, l) :: _ =>\n            (n, l, Some(sc))\n        }\n      }\n    } else (\"x\", 0, None)\n    val (name, id, nameId) = nextName(basename)\n    val sym = Sym[T](id)\n    sym.name = name\n    sym.nameId = nameId\n    sym.sourceContext = srcCtx\n    sym\n  }\n*/\n\n  abstract class Def[+T] { // operations (composite)\n    override final lazy val hashCode = scala.runtime.ScalaRunTime._hashCode(this.asInstanceOf[Product])\n  }\n\n  abstract class Stm // statement (links syms and definitions)\n  \n  def infix_lhs(stm: Stm): List[Sym[Any]] = stm match {\n    case TP(sym, rhs) => sym::Nil\n  }\n  \n  def infix_rhs(stm: Stm): Any = stm match { // clients use syms(e.rhs), boundSyms(e.rhs) etc.\n    case TP(sym, rhs) => rhs\n  }\n\n  def infix_defines[A](stm: Stm, sym: Sym[A]): Option[Def[A]] = stm match {\n    case TP(`sym`, rhs: Def[A]) => Some(rhs)\n    case _ => None\n  }\n\n  def infix_defines[A](stm: Stm, rhs: Def[A]): Option[Sym[A]] = stm match {\n    case TP(sym: Sym[A], `rhs`) => Some(sym)\n    case _ => None\n  }\n  \n  case class TP[+T](sym: Sym[T], rhs: Def[T]) extends Stm\n\n  // graph construction state\n  \n  var globalDefs: List[Stm] = Nil\n  var localDefs: List[Stm] = Nil\n  var globalDefsCache: Map[Sym[Any],Stm] = Map.empty\n\n  def reifySubGraph[T](b: =>T): (T, List[Stm]) = {\n    val saveLocal = localDefs\n    val saveGlobal = globalDefs\n    val saveGlobalCache = globalDefsCache\n    localDefs = Nil\n    val r = b\n    val defs = localDefs\n    localDefs = saveLocal\n    globalDefs = saveGlobal\n    globalDefsCache = saveGlobalCache\n    (r, defs)\n  }\n\n  def reflectSubGraph(ds: List[Stm]): Unit = {\n    val lhs = ds.flatMap(_.lhs)\n    assert(lhs.length == lhs.distinct.length, \"multiple defs: \" + ds)\n    val existing = lhs flatMap (globalDefsCache get _)//globalDefs filter (_.lhs exists (lhs contains _))\n    assert(existing.isEmpty, \"already defined: \" + existing + \" for \" + ds)\n    localDefs = localDefs ::: ds\n    globalDefs = globalDefs ::: ds\n    for (stm <- ds; s <- stm.lhs) {      \n      globalDefsCache += (s->stm)\n    }\n  }\n\n  def findDefinition[T](s: Sym[T]): Option[Stm] =\n    globalDefsCache.get(s)\n    //globalDefs.find(x => x.defines(s).nonEmpty)\n\n  def findDefinition[T](d: Def[T]): Option[Stm] =\n    globalDefs.find(x => x.defines(d).nonEmpty)\n\n  def findOrCreateDefinition[T:Manifest](d: Def[T], pos: List[SourceContext]): Stm =\n    findDefinition[T](d) map { x => x.defines(d).foreach(_.withPos(pos)); x } getOrElse {\n      createDefinition(fresh[T](pos), d)\n    }\n\n  def findOrCreateDefinitionExp[T:Manifest](d: Def[T], pos: List[SourceContext]): Exp[T] =\n    findOrCreateDefinition(d, pos).defines(d).get\n\n  def createDefinition[T](s: Sym[T], d: Def[T]): Stm = {\n    val f = TP(s, d)\n    reflectSubGraph(List(f))\n    f\n  }\n  \n\n  protected implicit def toAtom[T:Manifest](d: Def[T])(implicit pos: SourceContext): Exp[T] = {\n    findOrCreateDefinitionExp(d, List(pos)) // TBD: return Const(()) if type is Unit??\n  }\n\n  object Def {\n    def unapply[T](e: Exp[T]): Option[Def[T]] = e match { // really need to test for sym?\n      case s @ Sym(_) =>\n        findDefinition(s).flatMap(_.defines(s))\n      case _ =>\n        None\n    }\n  }\n\n\n  // depenfindOrCreateDefinitiondencies\n\n  // regular data (and effect) dependencies\n  def syms(e: Any): List[Sym[Any]] = e match {\n    case s: Sym[Any] => List(s)\n    case ss: Iterable[Any] => ss.toList.flatMap(syms(_))\n    // All case classes extend Product!\n    case p: Product => \n      //return p.productIterator.toList.flatMap(syms(_))\n      /* performance hotspot */\n      val iter = p.productIterator\n      val out = new ListBuffer[Sym[Any]]\n      while (iter.hasNext) {\n        val e = iter.next()\n        out ++= syms(e)\n      }\n      out.result\n    case _ => Nil\n  }\n\n  // symbols which are bound in a definition\n  def boundSyms(e: Any): List[Sym[Any]] = e match {\n    case ss: Iterable[Any] => ss.toList.flatMap(boundSyms(_))\n    case p: Product => p.productIterator.toList.flatMap(boundSyms(_))\n    case _ => Nil\n  }\n\n  // symbols which are bound in a definition, but also defined elsewhere\n  def tunnelSyms(e: Any): List[Sym[Any]] = e match {\n    case ss: Iterable[Any] => ss.toList.flatMap(tunnelSyms(_))\n    case p: Product => p.productIterator.toList.flatMap(tunnelSyms(_))\n    case _ => Nil\n  }\n\n  // symbols of effectful components of a definition\n  def effectSyms(x: Any): List[Sym[Any]] = x match {\n    case ss: Iterable[Any] => ss.toList.flatMap(effectSyms(_))\n    case p: Product => p.productIterator.toList.flatMap(effectSyms(_))\n    case _ => Nil\n  }\n\n  // soft dependencies: they are not required but if they occur, \n  // they must be scheduled before\n  def softSyms(e: Any): List[Sym[Any]] = e match {\n    // empty by default\n    //case s: Sym[Any] => List(s)\n    case ss: Iterable[Any] => ss.toList.flatMap(softSyms(_))\n    case p: Product => p.productIterator.toList.flatMap(softSyms(_))\n    case _ => Nil\n  }\n\n\n  def rsyms[T](e: Any)(f: Any=>List[T]): List[T] = e match {\n    case s: Sym[Any] => f(s)\n    case ss: Iterable[Any] => ss.toList.flatMap(f)\n    case p: Product => p.productIterator.toList.flatMap(f)\n    case _ => Nil\n  }\n\n  // frequency information for dependencies: used/computed\n  // often (hot) or not often (cold). used to drive code motion.\n  def symsFreq(e: Any): List[(Sym[Any], Double)] = e match {\n    case s: Sym[Any] => List((s,1.0))\n    case ss: Iterable[Any] => ss.toList.flatMap(symsFreq(_))\n    case p: Product => p.productIterator.toList.flatMap(symsFreq(_))\n    //case _ => rsyms(e)(symsFreq)\n    case _ => Nil\n  }\n\n  def freqNormal(e: Any) = symsFreq(e)\n  def freqHot(e: Any) = symsFreq(e).map(p=>(p._1,p._2*1000.0))\n  def freqCold(e: Any) = symsFreq(e).map(p=>(p._1,p._2*0.5))\n\n\n\n/*\n  def symsFreq(e: Any): List[(Sym[Any], Double)] = e match {\n    case s: Sym[Any] => List((s,1.0))\n    case p: Product => p.productIterator.toList.flatMap(symsFreq(_))\n    case _ => Nil\n  }\n*/\n\n/*\n  def symsShare(e: Any): List[(Sym[Any], Int)] = {\n    case s: Sym[Any] => List(s)\n    case p: Product => p.productIterator.toList.flatMap(symsShare(_))\n    case _ => Nil\n  }\n*/\n\n\n\n  // bookkeeping\n\n  def reset { // used by delite?\n    nVars = 0\n    globalDefs = Nil\n    localDefs = Nil\n    globalDefsCache = Map.empty\n  }\n\n}\n",
			"file": "src/internal/Expressions.scala",
			"file_size": 12343,
			"file_write_time": 1398956527000000,
			"settings":
			{
				"buffer_size": 12365,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/Packages.scala",
			"settings":
			{
				"buffer_size": 4901,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"console":
	{
		"height": 0.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/home/gabriel/workspace/lms/src/internal/ScalaCodegen.scala",
		"/home/gabriel/workspace/lms/src/common/MiscOps.scala",
		"/home/gabriel/workspace/lms/src/common/Packages.scala",
		"/home/gabriel/workspace/lms/src/common/CastingOps.scala"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"AliasRep",
			"Option",
			"def quote",
			"def emitVarDef",
			"ScalaGenVariablesNested",
			"assignmen"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 3,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "test-src/epfl/test12-collections/TestArrayOps.scala",
					"settings":
					{
						"buffer_size": 43513,
						"regions":
						{
						},
						"selection":
						[
							[
								5794,
								5794
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4410.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/common/CastingOps.scala",
					"settings":
					{
						"buffer_size": 2769,
						"regions":
						{
						},
						"selection":
						[
							[
								324,
								324
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 975.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/common/ArrayOps.scala",
					"settings":
					{
						"buffer_size": 18826,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 135.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/internal/Effects.scala",
					"settings":
					{
						"buffer_size": 32516,
						"regions":
						{
						},
						"selection":
						[
							[
								20967,
								20967
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 11904.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/common/Variables.scala",
					"settings":
					{
						"buffer_size": 14608,
						"regions":
						{
						},
						"selection":
						[
							[
								13437,
								13437
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/common/While.scala",
					"settings":
					{
						"buffer_size": 6465,
						"regions":
						{
						},
						"selection":
						[
							[
								764,
								764
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 585.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/common/Base.scala",
					"settings":
					{
						"buffer_size": 3417,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 180.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/internal/Expressions.scala",
					"settings":
					{
						"buffer_size": 12365,
						"regions":
						{
						},
						"selection":
						[
							[
								2881,
								2881
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1319.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/common/Packages.scala",
					"settings":
					{
						"buffer_size": 4901,
						"regions":
						{
						},
						"selection":
						[
							[
								1486,
								1486
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 225.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"replace":
	{
		"height": 0.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"while",
				"src/common/While.scala"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 344.0,
	"status_bar_visible": true
}
