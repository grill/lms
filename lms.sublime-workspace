{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"acc",
				"acctype"
			],
			[
				"paren",
				"parentSym"
			],
			[
				"print",
				"printlog"
			],
			[
				"array",
				"array_update"
			],
			[
				"Max",
				"MAX_VALUE"
			]
		]
	},
	"buffers":
	[
		{
			"file": "test-src/epfl/test12-collections/TestArrayOps.scala",
			"settings":
			{
				"buffer_size": 32057,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/Variables.scala",
			"settings":
			{
				"buffer_size": 14608,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/internal/Effects.scala",
			"settings":
			{
				"buffer_size": 26992,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 88 files for \"aliasSyms\"\n\n/home/gabriel/workspace/lms/src/common/IfThenElse.scala:\n   87  \n   88  \n   89:   override def aliasSyms(e: Any): List[Sym[Any]] = e match {\n   90      case IfThenElse(c,a,b) => syms(a):::syms(b)\n   91:     case _ => super.aliasSyms(e)\n   92    }\n   93  \n   ..\n  103  \n  104    override def copySyms(e: Any): List[Sym[Any]] = e match {\n  105:     case IfThenElse(c,a,b) => Nil // could return a,b but implied by aliasSyms\n  106      case _ => super.copySyms(e)\n  107    }\n  ...\n  161    // aliasing / sharing\n  162    \n  163:   override def aliasSyms(e: Any): List[Sym[Any]] = e match {\n  164      case SimpleFatIfThenElse(c,a,b) => syms(a):::syms(b)\n  165:     case _ => super.aliasSyms(e)\n  166    }\n  167  \n  ...\n  177  \n  178    override def copySyms(e: Any): List[Sym[Any]] = e match {\n  179:     case SimpleFatIfThenElse(c,a,b) => Nil // could return a,b but implied by aliasSyms\n  180      case _ => super.copySyms(e)\n  181    }\n\n/home/gabriel/workspace/lms/src/common/Loops.scala:\n   56    // aliases and sharing\n   57  \n   58:   override def aliasSyms(e: Any): List[Sym[Any]] = e match {\n   59:     case e: AbstractLoop[_] => aliasSyms(e.body)\n   60:     case _ => super.aliasSyms(e)\n   61    }\n   62  \n   ..\n  111    // aliases and sharing\n  112  \n  113:   override def aliasSyms(e: Any): List[Sym[Any]] = e match {\n  114:     case e: AbstractFatLoop => aliasSyms(e.body)\n  115:     case _ => super.aliasSyms(e)\n  116    }\n  117  \n\n/home/gabriel/workspace/lms/src/common/ObjectOps.scala:\n   56    // aliases and sharing\n   57  \n   58:   override def aliasSyms(e: Any): List[Sym[Any]] = e match {\n   59      case ObjectUnsafeImmutable(a) => Nil\n   60:     case _ => super.aliasSyms(e)\n   61    }\n   62  \n\n/home/gabriel/workspace/lms/src/common/Variables.scala:\n  128    }\n  129  \n  130:   override def aliasSyms(e: Any): List[Sym[Any]] = e match {\n  131      case NewVar(a) => Nil\n  132      case ReadVar(Variable(a)) => Nil\n  ...\n  136      case VarTimesEquals(Variable(a),b) => Nil\n  137      case VarDivideEquals(Variable(a),b) => Nil\n  138:     case _ => super.aliasSyms(e)\n  139    }\n  140  \n\n/home/gabriel/workspace/lms/src/internal/Effects.scala:\n  172    x should be returned in the following cases:\n  173  \n  174:   x in aliasSyms(y)      if y = x      // if then else\n  175    x in containSyms(y)    if *y = x     // array update\n  176    x in extractSyms(y)    if y = *x     // array apply\n  ...\n  183    */\n  184  \n  185:   def aliasSyms(e: Any): List[Sym[Any]] = e match {\n  186:     case Reflect(x, u, es) => aliasSyms(x)\n  187      case Reify(x, u, es) => syms(x)\n  188      case s: Sym[_] => List(s)\n  189:     case p: Product => p.productIterator.toList.flatMap(aliasSyms(_))\n  190      case _ => Nil\n  191    }\n  ...\n  227        globalDefs.filter(st1 contains _.sym)\n  228      }\n  229:     GraphUtil.stronglyConnectedComponents[TP[Any]](deps(aliasSyms(start)), t => deps(aliasSyms(t.rhs))).flatten.reverse\n  230    }\n  231  */\n  ...\n  246  \n  247    def shallowAliases(start: Any): List[Sym[Any]] = {\n  248:     val alias = noPrim(aliasSyms(start)) flatMap { a => a::shallowAliasCache.getOrElseUpdate(a, shallowAliases(utilLoadSym(a))) }\n  249      val extract = noPrim(extractSyms(start)) flatMap { a => deepAliasCache.getOrElseUpdate(a, deepAliases(utilLoadSym(a))) }\n  250      //println(\"shallowAliases(\"+start+\") = \"+alias+\" ++ \"+extract)\n  ...\n  253  \n  254    def deepAliases(start: Any): List[Sym[Any]] = {\n  255:     val alias = noPrim(aliasSyms(start)) flatMap { a => deepAliasCache.getOrElseUpdate(a, deepAliases(utilLoadSym(a))) }\n  256      val copy = noPrim(copySyms(start)) flatMap { a => deepAliasCache.getOrElseUpdate(a, deepAliases(utilLoadSym(a))) }\n  257      val contain = noPrim(containSyms(start)) flatMap { a => a::allAliasCache.getOrElseUpdate(a, allAliases(utilLoadSym(a))) }\n  258:     //println(\"aliasSyms(\"+start+\") = \"+aliasSyms(start) + \"/\" + noPrim(aliasSyms(start)))\n  259      //println(\"copySyms(\"+start+\") = \"+copySyms(start) + \"/\" + noPrim(copySyms(start)))\n  260      //println(\"containSyms(\"+start+\") = \"+containSyms(start) + \"/\" + noPrim(containSyms(start)))\n\n27 matches across 5 files\n\n\nSearching 88 files for \"EffectExp\"\n\n/home/gabriel/workspace/lms/src/common/ArrayBufferOps.scala:\n   45  }\n   46  \n   47: trait ArrayBufferOpsExp extends ArrayBufferOps with EffectExp {\n   48    case class ArrayBufferNew[A:Manifest](xs: Seq[Exp[A]]) extends Def[ArrayBuffer[A]]  {\n   49      val mA = manifest[A]\n\n/home/gabriel/workspace/lms/src/common/ArrayOps.scala:\n   66  }\n   67  \n   68: trait ArrayOpsExp extends ArrayOps with EffectExp with VariablesExp {\n   69    case class ArrayNew[T:Manifest](n: Exp[Int], specializedType: Rep[String] = unit(\"\")) extends Def[Array[T]] {\n   70      val m = manifest[T]\n\n/home/gabriel/workspace/lms/src/common/Base.scala:\n   53  */\n   54  \n   55: trait EffectExp extends BaseExp with Effects {\n   56  \n   57    def mapOver(t: Transformer, u: Summary) = { // TODO: move to effects class?\n\n/home/gabriel/workspace/lms/src/common/BooleanOps.scala:\n   36  }\n   37  \n   38: trait BooleanOpsExp extends BooleanOps with BaseExp with EffectExp {\n   39    case class BooleanNegate(lhs: Exp[Boolean]) extends Def[Boolean]\n   40    case class BooleanAnd(lhs: Exp[Boolean], rhs: Block[Boolean]) extends\n\n/home/gabriel/workspace/lms/src/common/DSLOps.scala:\n   10  //TODO rename this to something more meaningful\n   11  \n   12: trait DSLOpsExp extends EffectExp {\n   13    // representation must be reified! this places the burden on the caller, but allows the caller to avoid the\n   14    // use of function values (which can be uglier).\n\n/home/gabriel/workspace/lms/src/common/DynamicRecord.scala:\n   57  }\n   58  \n   59: trait DynamicRecordExp extends DynamicRecord with BaseExp with EffectExp {\n   60      case class NewDynamicRecordObj(n: String) extends Def[DynamicRecord]\n   61  	case class DynamicRecordGet(x: Rep[DynamicRecord], field: Rep[Any]) extends Def[Any]\n   ..\n  283  }\n  284  \n  285: trait DynamicRecordHashMapExp extends DynamicRecordHashMap with EffectExp with HashMapOpsExp with DynamicRecordExp {\n  286    abstract class DynamicRecordHashMapDef[K:Manifest,V:Manifest,R:Manifest] extends Def[R] {\n  287      val mK = manifest[K]\n\n/home/gabriel/workspace/lms/src/common/ExceptionOps.scala:\n   15  }\n   16  \n   17: trait ExceptionOpsExp extends ExceptionOps with EffectExp {\n   18    case class ThrowException(m: Rep[String]) extends Def[Nothing]\n   19    \n\n/home/gabriel/workspace/lms/src/common/ForwardTransformer.scala:\n    6  \n    7  trait ForwardTransformer extends internal.AbstractSubstTransformer with internal.FatBlockTraversal { self =>\n    8:   val IR: BaseFatExp with EffectExp //LoopsFatExp with IfThenElseFatExp\n    9    import IR._\n   10    \n\n/home/gabriel/workspace/lms/src/common/Functions.scala:\n   63  }\n   64  \n   65: trait FunctionsExp extends Functions with EffectExp {\n   66    case class Lambda[A:Manifest,B:Manifest](f: Exp[A] => Exp[B], x: Exp[A], y: Block[B]) extends Def[A => B] { val mA = manifest[A]; val mB = manifest[B] }\n   67    case class Apply[A:Manifest,B:Manifest](f: Exp[A => B], arg: Exp[A]) extends Def[B]\n\n/home/gabriel/workspace/lms/src/common/GeneratorOps.scala:\n  250  }\n  251  \n  252: trait GeneratorOpsExp extends GeneratorOps with EffectExp with VariablesExp with IfThenElseExp with EqualExp with TupleOpsExp with ListOpsExp with ObjectOpsExp with StringOpsExp with HashMapOpsExp with ListBufferExp with HashMultiMapOpsExp with SetOpsExp with ArrayOpsExp {\n  253  \n  254    case class GeneratorContainer[T: Manifest,U:Manifest](gen: Generator[U]) extends Def[T]\n\n/home/gabriel/workspace/lms/src/common/HashCodeOps.scala:\n    9  }\n   10  \n   11: trait HashCodeOpsExp extends BaseExp with EffectExp {\n   12      case class HashCode(x: Rep[Any]) extends Def[Int]\n   13      def __hashCode(x: Rep[Any]) = HashCode(x)\n\n/home/gabriel/workspace/lms/src/common/HashMapOps.scala:\n   56  }\n   57  \n   58: trait HashMapOpsExp extends HashMapOps with EffectExp with TupleOpsExp with UninlinedFunctionsExp with Functions {\n   59    abstract class HashMapDef[K:Manifest,V:Manifest,R:Manifest] extends Def[R] {\n   60      val mK = manifest[K]\n\n/home/gabriel/workspace/lms/src/common/IfThenElse.scala:\n   27  \n   28  \n   29: trait IfThenElseExp extends IfThenElse with EffectExp {\n   30  \n   31    abstract class AbstractIfThenElse[T] extends Def[T] {\n\n/home/gabriel/workspace/lms/src/common/IterableOps.scala:\n   23  }\n   24  \n   25: trait IterableOpsExp extends IterableOps with EffectExp with VariablesExp {\n   26  \n   27    case class IterableForeach[T:Manifest](a: Exp[Iterable[T]], x: Sym[T], block: Block[Unit]) extends Def[Unit]\n\n/home/gabriel/workspace/lms/src/common/ListBuffer.scala:\n   26  }\n   27  \n   28: trait ListBufferExp extends ListBuffer with BaseExp with EffectExp with Effects {\n   29  	case class ListBufferAdd[A:Manifest](x: Rep[mutable.ListBuffer[A]], v: Rep[Any]) extends Def[Unit]\n   30  	case class ListBufferRemove[A:Manifest](x: Rep[mutable.ListBuffer[A]], v: Rep[Int]) extends Def[A]\n\n/home/gabriel/workspace/lms/src/common/ListOps.scala:\n   56  }\n   57  \n   58: trait ListOpsExp extends ListOps with EffectExp with VariablesExp {\n   59    case class ListNew[A:Manifest](xs: Seq[Rep[A]]) extends Def[List[A]] {\n   60    	val m = manifest[A]\n\n/home/gabriel/workspace/lms/src/common/Loops.scala:\n   11  }\n   12  \n   13: trait LoopsExp extends Loops with BaseExp with EffectExp {\n   14  \n   15    abstract class AbstractLoop[A] extends Def[A] {\n\n/home/gabriel/workspace/lms/src/common/MathOps.scala:\n   45  }\n   46  \n   47: trait MathOpsExp extends MathOps with EffectExp {\n   48    case class MathCeil(x: Exp[Double]) extends Def[Double]\n   49    case class MathFloor(x: Exp[Double]) extends Def[Double]\n\n/home/gabriel/workspace/lms/src/common/MiscOps.scala:\n   26  \n   27  \n   28: trait MiscOpsExp extends MiscOps with EffectExp {\n   29    case class Print(x: Exp[Any]) extends Def[Unit]\n   30    case class PrintLn(x: Exp[Any]) extends Def[Unit]\n\n/home/gabriel/workspace/lms/src/common/MultiMap.scala:\n   36  }\n   37  \n   38: trait HashMultiMapOpsExp extends HashMultiMapOps with EffectExp {\n   39    abstract class HashMultiMapDef[K:Manifest,V:Manifest,R:Manifest] extends Def[R] {\n   40      val mK = manifest[K]\n\n/home/gabriel/workspace/lms/src/common/SeqOps.scala:\n   26  }\n   27  \n   28: trait SeqOpsExp extends SeqOps with EffectExp {\n   29    case class SeqNew[A:Manifest](xs: List[Rep[A]]) extends Def[Seq[A]]\n   30    case class SeqLength[T:Manifest](a: Exp[Seq[T]]) extends Def[Int]\n\n/home/gabriel/workspace/lms/src/common/SetOps.scala:\n   41  }\n   42  \n   43: trait SetOpsExp extends SetOps with ArrayOps with EffectExp {\n   44    case class SetNew[A:Manifest](xs: Seq[Exp[A]], mA: Manifest[A]) extends Def[Set[A]]\n   45    case class SetContains[A:Manifest](s: Exp[Set[A]], i: Exp[A]) extends Def[Boolean]\n\n/home/gabriel/workspace/lms/src/common/SplitEffects.scala:\n  155  \n  156  \n  157: trait PreviousIterationDummyExp extends BaseFatExp with EffectExp {\n  158  \n  159    case class PreviousIteration(k: Exp[Nothing]) extends Def[Unit]\n\n/home/gabriel/workspace/lms/src/common/StaticData.scala:\n   10  }\n   11  \n   12: trait StaticDataExp extends EffectExp {\n   13    case class StaticData[T](x: T) extends Def[T]\n   14    def staticData[T:Manifest](x: T): Exp[T] = StaticData(x)\n\n/home/gabriel/workspace/lms/src/common/Structs.scala:\n   31  }\n   32  \n   33: trait StructExp extends Structs with BaseExp with EffectExp {\n   34  \n   35    // TODO: structs should take Def parameters that define how to generate constructor and accessor calls\n\n/home/gabriel/workspace/lms/src/common/TupleOps.scala:\n  352  }\n  353  \n  354: trait TupleOpsExp extends TupleOps with EffectExp {\n  355  \n  356    implicit def make_tuple2[A1:Manifest,A2:Manifest](t: (Exp[A1],Exp[A2]))(implicit pos: SourceContext) : Exp[(A1,A2)] = ETuple2(t._1, t._2)\n\n/home/gabriel/workspace/lms/src/common/Unchecked.scala:\n   30  }\n   31  \n   32: trait UncheckedOpsExp extends EffectExp {\n   33    \n   34    // TODO: use reifyEffects\n\n/home/gabriel/workspace/lms/src/common/UninlinedFunctions.scala:\n   32  }\n   33  \n   34: trait UninlinedFunctionsExp extends UninlinedFunctions with BaseExp with EffectExp { \n   35    val functionList0 = new scala.collection.mutable.ListBuffer[UninlinedFunc0[_]]()\n   36    val functionList1 = new scala.collection.mutable.ListBuffer[UninlinedFunc1[_,_]]()\n\n/home/gabriel/workspace/lms/src/common/Variables.scala:\n   24  }\n   25  \n   26: trait ReadVarImplicitExp extends EffectExp {\n   27    this: VariablesExp =>\n   28  \n\n/home/gabriel/workspace/lms/src/common/While.scala:\n   12  \n   13  \n   14: trait WhileExp extends While with EffectExp {\n   15    case class While(cond: Block[Boolean], body: Block[Unit]) extends Def[Unit]\n   16    case class DoWhile(body: Block[Unit], cond: Block[Boolean]) extends Def[Unit]\n\n/home/gabriel/workspace/lms/src/util/Timing.scala:\n    9  }\n   10  \n   11: trait TimingExp extends BaseExp with EffectExp {\n   12    case class TimeGeneratedCode[A: Manifest](start: Exp[Long], end: Exp[Long], f: Block[A], msg: Rep[String] = unit(\"\")) extends Def[A]\n   13  \n\n32 matches across 31 files\n\n\nSearching 88 files for \"Block\"\n\n/home/gabriel/workspace/lms/src/common/ArrayOps.scala:\n   29      def update(n: Rep[Int], y: Rep[T])(implicit pos: SourceContext) = array_update(a,n,y)\n   30      def length(implicit pos: SourceContext) = array_length(a)\n   31:     def foreach(block: Rep[T] => Rep[Unit])(implicit pos: SourceContext) = array_foreach(a, block)\n   32      //def filter(f: Rep[T] => Rep[Boolean]) = array_filter(a, f)\n   33  	  // def groupBy[B: Manifest](f: Rep[T] => Rep[B]) = array_group_by(a,f)\n   ..\n   50    def array_unsafe_update[T:Manifest](x: Rep[Array[T]], n: Rep[Int], y: Rep[T])(implicit pos: SourceContext): Rep[Unit]\n   51    def array_length[T:Manifest](x: Rep[Array[T]])(implicit pos: SourceContext) : Rep[Int]\n   52:   def array_foreach[T:Manifest](x: Rep[Array[T]], block: Rep[T] => Rep[Unit])(implicit pos: SourceContext): Rep[Unit]\n   53    def array_filter[T : Manifest](l: Rep[Array[T]], f: Rep[T] => Rep[Boolean])(implicit pos: SourceContext): Rep[Array[T]]\n   54    def array_group_by[T : Manifest, B: Manifest](l: Rep[Array[T]], f: Rep[T] => Rep[B])(implicit pos: SourceContext): Rep[HashMap[B, Array[T]]]\n   ..\n   78      val m = manifest[T]\n   79    }\n   80:   case class ArrayForeach[T](a: Exp[Array[T]], x: Sym[T], block: Block[Unit]) extends Def[Unit]\n   81:   case class ArrayFilter[T : Manifest](l: Exp[Array[T]], x: Sym[T], block: Block[Boolean]) extends Def[Array[T]]\n   82:   case class ArrayGroupBy[T: Manifest, B: Manifest](l: Exp[Array[T]], x: Sym[T], block: Block[B]) extends Def[HashMap[B, Array[T]]]\n   83    case class ArrayCopy[T:Manifest](src: Exp[Array[T]], srcPos: Exp[Int], dest: Exp[Array[T]], destPos: Exp[Int], len: Exp[Int]) extends Def[Unit] {\n   84      val m = manifest[T]\n   ..\n   87      val m = manifest[T]\n   88    }\n   89:   case class ArrayMap[A:Manifest,B:Manifest](a: Exp[Array[A]], x: Sym[A], block: Block[B]) extends Def[Array[B]] {\n   90      val array = NewArray[B](a.length)\n   91    }\n   ..\n  103    def array_unsafe_update[T:Manifest](x: Rep[Array[T]], n: Rep[Int], y: Rep[T])(implicit pos: SourceContext) = ArrayUpdate(x,n,y)\n  104    def array_length[T:Manifest](a: Exp[Array[T]])(implicit pos: SourceContext) : Rep[Int] = ArrayLength(a)\n  105:   def array_foreach[T:Manifest](a: Exp[Array[T]], block: Exp[T] => Exp[Unit])(implicit pos: SourceContext): Exp[Unit] = {\n  106      val x = fresh[T]\n  107:     val b = reifyEffects(block(x))\n  108      reflectEffect(ArrayForeach(a, x, b), summarizeEffects(b).star)\n  109    }\n  ...\n  251              \"def x\" + sym.id + \"_\" + i + \"=Array(\" + (start until end).map{xs(_)} + \")\\nArray.copy(x\" + sym.id + \"_\" + i + \",0,buf,\" + start + \",\" + size + \")\\n\"\n  252            }\n  253:           val numBlocks = Math.ceil(xs.size / ARRAY_LITERAL_MAX_SIZE).intValue\n  254:           \"{val buf=new Array[\" + remap(e.mt) + \"](\" + xs.size + \")\\n\" + ((0 until numBlocks).map(append)).mkString(\"\\n\") + \"buf}\" */\n  255            \"{import scala.io.Source;(Source.fromFile(\\\"\" + symDataPath(sym) + \"\\\").getLines.map{Integer.parseInt(_)}).toArray}\"\n  256          }\n  ...\n  263      case ArrayUpdate(x,n,y) => emitAssignment(sym, src\"$x($n)\", quote(y))\n  264      case ArrayLength(x) => emitValDef(sym, src\"$x.length\")\n  265:     case ArrayForeach(a,x,block) => \n  266        emitValDef(sym, src\"$a.foreach{\")    \n  267        gen\"\"\"$x => \n  268:            |${nestedBlock(block)}\n  269:            |$block\n  270             |}\"\"\"\n  271      case ArrayCopy(src,srcPos,dest,destPos,len) => emitValDef(sym, src\"System.arraycopy($src,$srcPos,$dest,$destPos,$len)\")\n  ...\n  293               |while (i < in.length) {\n  294               |val $x = in(i)\n  295:              |${nestedBlock(blk)}\n  296               |out(i) = $blk\n  297               |i += 1\n  ...\n  304        // stream.println(\"val \" + quote(sym) + \" = \" + quote(a) + \".map{\")\n  305        // stream.println(quote(x) + \" => \")\n  306:       // emitBlock(blk)\n  307:       // stream.println(quote(getBlockResult(blk)))\n  308        // stream.println(\"}\")  \n  309  	case ArrayFilter(a,x,blk) =>\n  310  		stream.println(\"// FILTER\")\n  311  		emitValDef(sym, quote(a) + \".filter(\" + quote(x) + \"=> {\")\n  312: 		emitBlock(blk)\n  313: 		emitBlockResult(blk)\n  314  		stream.println(\"})\") \n  315  		stream.println(\"// END OF FILTER\")\n  ...\n  317  		stream.println(\"// GROUPBY\")\n  318  		emitValDef(sym, quote(a) + \".groupBy(\" + quote(x) + \"=> {\")\n  319: 		emitBlock(blk)\n  320: 		emitBlockResult(blk)\n  321  		stream.println(\"})\") \n  322  		stream.println(\"// END OF GROUPBY\")\n\n/home/gabriel/workspace/lms/src/common/Base.scala:\n   35   * @since 0.1\n   36   */\n   37: trait BaseExp extends Base with Expressions with Blocks with Transforming {\n   38    type Rep[+T] = Exp[T]\n   39  \n   ..\n   41  }\n   42  \n   43: trait BlockExp extends BaseExp\n   44  \n   45  /*\n   46: trait BlockExp extends BaseExp with Blocks {\n   47    \n   48:   implicit object CanTransformBlock extends CanTransform[Block] {\n   49:     def transform[A](x: Block[A], t: Transformer): Block[A] = Block(t(x.res))\n   50    }\n   51    \n\n/home/gabriel/workspace/lms/src/common/BooleanOps.scala:\n   38  trait BooleanOpsExp extends BooleanOps with BaseExp with EffectExp {\n   39    case class BooleanNegate(lhs: Exp[Boolean]) extends Def[Boolean]\n   40:   case class BooleanAnd(lhs: Exp[Boolean], rhs: Block[Boolean]) extends\n   41  Def[Boolean] {\n   42  	val c = fresh[Boolean] // used in c code generation\n   ..\n   93        	withStream(localStream) {\n   94        	  gen\"\"\"if ($lhs) {\n   95:       	       |${nestedBlock(rhs)}\n   96        	       |$rhs\n   97        	       |} else false\"\"\"\n   ..\n  113  			emitValDef(b.c, quote(lhs))\n  114          	stream.println(\"if (\" + quote(lhs) + \") {\")\n  115: 			emitBlock(rhs)\n  116:     	    stream.println(quote(b.c) + \" = \" + quote(getBlockResult(rhs)) + \";\")\n  117          	stream.println(\"}\")\n  118  			emitValDef(sym, quote(b.c))\n\n/home/gabriel/workspace/lms/src/common/DSLOps.scala:\n   13    // representation must be reified! this places the burden on the caller, but allows the caller to avoid the\n   14    // use of function values (which can be uglier).\n   15:   class DSLOp[A](val representation: Block[A]) extends Def[A]\n   16  }\n   17  \n   ..\n   32        withStream(localStream) {\n   33          gen\"\"\"{ \n   34:              |${nestedBlock(b)}\n   35               |$b\n   36               |}\"\"\"\n\n/home/gabriel/workspace/lms/src/common/DynamicRecord.scala:\n   61  	case class DynamicRecordGet(x: Rep[DynamicRecord], field: Rep[Any]) extends Def[Any]\n   62  	case class DynamicRecordSet(x: Rep[DynamicRecord], field: Rep[Any], value: Rep[Any]) extends Def[Unit]\n   63:     case class DynamicRecordForEach(l: Rep[DynamicRecord], x: Sym[DynamicRecord], block: Block[Unit]) extends Def[Unit]\n   64  \n   65      def newDynamicRecord(name: String, reuse: Boolean = false) = \n   ..\n  117  		    case DynamicRecordSet(x, field, value) =>\n  118                  stream.println(quote(x) + \".\" + quote(field).replaceAll(\"\\\"\",\"\") + \" = \" + quote(value))\n  119:             case DynamicRecordForEach(x, init, block) => \n  120                  stream.println(\"val x\" + sym.toString.replace(\"Sym(\",\"\").replace(\")\",\"\") + \" = {\")\n  121                  stream.println(\"\\tvar \" + quote(init) + \"=\" + quote(x))\n  122                  stream.println(\"\\twhile (\" + quote(init) + \" != null) {\")\n  123:                 emitBlock(block)\n  124                  stream.println(\"\\t\\t\" + quote(init) + \"=\" + quote(init) + \".next\")\n  125                  stream.println(\"\\t}\")\n  ...\n  223  			case DynamicRecordSet(x, field, value) =>\n  224          	    stream.println(quote(x) + \"->\" + quote(field).replaceAll(\"\\\"\",\"\") + \" = \" + quote(value) + \";\")\n  225: 	        case DynamicRecordForEach(x, init, block) => \n  226      	        stream.println(\"val x\" + sym.toString.replace(\"Sym(\",\"\").replace(\")\",\"\") + \" = {\")\n  227          	    stream.println(\"\\tvar \" + quote(init) + \"=\" + quote(x))\n  228              	stream.println(\"\\twhile (\" + quote(init) + \" != null) {\")\n  229: 	            emitBlock(block)\n  230      	        stream.println(\"\\t\\t\" + quote(init) + \"=\" + quote(init) + \".next\")\n  231          	    stream.println(\"\\t}\")\n  ...\n  292    case class DynamicRecordHashMapSize[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]]) extends DynamicRecordHashMapDef[K,V,Int]\n  293    case class DynamicRecordHashMapRemoveHead[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]]) extends DynamicRecordHashMapDef[K,V,(K,V)]\n  294:   case class DynamicRecordHashMapGetOrElseUpdate[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]], k: Exp[K], v: Block[V], h: Block[Int], e: Block[Boolean], d: Sym[DynamicRecord]) extends DynamicRecordHashMapDef[K,V,V]\n  295    case class DynamicRecordHashMapMkString[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]], v:Rep[String]) extends DynamicRecordHashMapDef[K,V,String]\n  296  \n  ...\n  363          stream.println(\"bc = bc + (bc >>> 16);\")\n  364          stream.println(\"bc = bc & 0x3f;\")\n  365:         emitBlock(h)\n  366:         stream.println(\"var hc = \" + quote(getBlockResult(h)) + \" * 0x9e3775cd\")\n  367          stream.println(\"hc = ((hc >>> 24)           ) |\")\n  368          stream.println(\"     ((hc >>   8) &   0xFF00) |\")\n  ...\n  378          val newSource = new StringWriter()\n  379          stream = new PrintWriter(newSource)\n  380:         emitBlock(e)\n  381          stream = savedStream\n  382          val outStream = newSource.toString.replaceAll(quote(d), \"e\")\n  383          stream.println(outStream)\n  384:         emitBlockResult(e)\n  385          stream.println(\"}) e = e.next\")\n  386          stream.println(\"var \" + quote(sym) + \" = e\")\n  387          stream.println(\"if (e eq null) {\")\n  388:         emitBlock(v)\n  389:         stream.println(quote(sym) + \" = \" + quote(getBlockResult(v)))\n  390          stream.println(quote(sym) + \".next = \" + quote(m) + \"(h)\")\n  391          stream.println(quote(m) + \"(h) = \" + quote(sym))\n\n/home/gabriel/workspace/lms/src/common/ExceptionOps.scala:\n    7  \n    8  trait ExceptionOps extends Variables {\n    9:   // TODO: support virtualization of try-catch-finally blocks\n   10    // for now, we only allow fatal errors (the exception will never be caught in generated code)\n   11    \n\n/home/gabriel/workspace/lms/src/common/ForwardTransformer.scala:\n    5  import scala.reflect.SourceContext\n    6  \n    7: trait ForwardTransformer extends internal.AbstractSubstTransformer with internal.FatBlockTraversal { self =>\n    8    val IR: BaseFatExp with EffectExp //LoopsFatExp with IfThenElseFatExp\n    9    import IR._\n   10    \n   11:   def transformBlock[A:Manifest](block: Block[A]): Block[A] = {\n   12      reifyEffects {\n   13:       reflectBlock(block)\n   14      }\n   15    }\n   ..\n   17    override def hasContext = true\n   18    \n   19:   override def apply[A:Manifest](xs: Block[A]): Block[A] = transformBlock(xs)\n   20  \n   21    // perform only one step of lookup, otherwise we confuse things: \n   ..\n   35    }\n   36    \n   37:   override def reflectBlock[A](block: Block[A]): Exp[A] = {\n   38      withSubstScope {\n   39:       traverseBlock(block)\n   40:       apply(getBlockResult(block))\n   41      }\n   42    }\n   ..\n   67      case TP(sym,rhs) =>\n   68        /*\n   69:        TBD: optimization from MirrorRetainBlockTransformer in TestMiscTransform -- is it worth doing??        \n   70         // we want to skip those statements that don't have symbols that need substitution\n   71:        // however we need to recurse into any blocks\n   72:        if (!syms(rhs).exists(subst contains _) && blocks(rhs).isEmpty) {\n   73         if (!globalDefs.contains(stm)) reflectSubGraph(List(stm))\n   74         return sym\n   ..\n   97    import IR._\n   98  \n   99:   def run[A:Manifest](s: Block[A]): Block[A] = {\n  100:     transformBlock(s)\n  101    }\n  102  \n  103    def transformDef[A](lhs: Sym[A], rhs: Def[A]): Option[() => Def[A]] = None\n  104  \n  105:   override def traverseStmsInBlock[A](stms: List[Stm]): Unit = {\n  106      for (sym <- recursive) {\n  107        subst += (sym -> fresh(mtype(sym.tp)))\n  108      }\n  109:     super.traverseStmsInBlock(stms)\n  110    }\n  111  \n  ...\n  148    }\n  149    def isDone = nextSubst.isEmpty\n  150:   def runOnce[A:Manifest](s: Block[A]): Block[A] = {\n  151      subst = Map.empty\n  152      curSubst = nextSubst\n  153      nextSubst = Map.empty\n  154:     transformBlock(s)\n  155    }\n  156:   def run[A:Manifest](s: Block[A]): Block[A] = {\n  157      if (isDone) s else run(runOnce(s))\n  158    }\n  ...\n  163            printdbg(\"install replacement for \" + sym)\n  164            //val b = reifyEffects(replace())\n  165:           //reflectBlock(b)\n  166            replace()\n  167          case None => \n\n/home/gabriel/workspace/lms/src/common/FunctionBlocks.scala:\n    4  import java.io.PrintWriter\n    5  import scala.reflect.SourceContext\n    6: import scala.virtualization.lms.internal.{Blocks, Effects, AbstractTransformer}\n    7  import scala.virtualization.lms.util.OverloadHack\n    8  \n    9  /*\n   10   * This trait allows functions to be stored as case class parameters in a way that works correctly\n   11:  * with transformers. Pre-transformation, they are converted from lambdas to BlockN classes,\n   12:  * and then post transformation they are converted from BlockN classes back to lambdas (with the\n   13   * correctly transformed free and bound vars).\n   14   */\n   15: trait FunctionBlocksExp extends BaseExp with Blocks with Effects with OverloadHack {\n   16    /*\n   17:    * BlockN definitions\n   18     */\n   19:   implicit def lambdaToBlock0[R:Manifest](f: () => Exp[R]) = Block0(reifyEffects(f()))\n   20:   case class Block0[R:Manifest](blockRes: Block[R])\n   21       \n   22:   implicit def lambdaToBlock1[T1:Manifest,R:Manifest](f: Exp[T1] => Exp[R]) = {\n   23      val x1 = fresh[T1]\n   24:     Block1(x1,reifyEffects(f(x1)))\n   25    }    \n   26:   case class Block1[T1:Manifest,R:Manifest](blockArg1: Sym[T1], blockRes: Block[R]) \n   27    \n   28:   implicit def lambdaToBlock2[T1:Manifest,T2:Manifest,R:Manifest](f: (Exp[T1],Exp[T2]) => Exp[R]) = {\n   29      val (x1,x2) = (fresh[T1],fresh[T2])\n   30:     Block2(x1,x2,reifyEffects(f(x1,x2)))\n   31    }\n   32:   case class Block2[T1:Manifest,T2:Manifest,R:Manifest](blockArg1: Sym[T1], blockArg2: Sym[T2], blockRes: Block[R]) \n   33   \n   34   \n   35    /*\n   36:    * boundSyms override required for all BlockNs\n   37     */\n   38    override def boundSyms(e: Any): List[Sym[Any]] = e match {\n   39:     case Block0(blk) => effectSyms(blk)\n   40:     case Block1(b1,blk) => scala.List(b1) ::: effectSyms(blk)\n   41:     case Block2(b1,b2,blk) => scala.List(b1,b2) ::: effectSyms(blk)\n   42      case _ => super.boundSyms(e)\n   43    }\n   ..\n   45    \n   46    /*\n   47:    * Enable transformation of BlockN types back to lambdas\n   48     */\n   49     \n   50:    def transformBlockWithBound[A](t: ForwardTransformer{val IR: FunctionBlocksExp.this.type}, f: Block[A], boundVars: List[(Exp[Any],Exp[Any])]) = {\n   51       t.withSubstScope(boundVars: _*) {\n   52:        t.reflectBlock(f)\n   53       }\n   54     }\n   55     \n   56:   implicit def transformerToBlockTransformer(t: ForwardTransformer{val IR: FunctionBlocksExp.this.type}) = new {\n   57:     def apply[R](x: Block0[R]): (() => Exp[R]) =  { () => t.reflectBlock(x.blockRes) }\n   58:     def apply[T1,R](x: Block1[T1,R]): Exp[T1] => Exp[R] = { a => transformBlockWithBound(t, x.blockRes, List(x.blockArg1 -> a)) }\n   59:     def apply[T1,T2,R](x: Block2[T1,T2,R]): (Exp[T1],Exp[T2]) => Exp[R] = { (a,b) => transformBlockWithBound(t, x.blockRes, List(x.blockArg1 -> a, x.blockArg2 -> b)) }\n   60    }  \n   61    \n   62    /*\n   63:    * For mirroring of BlockN types without conversion to lambdas\n   64     */\n   65:    def copyBlock0[R:Manifest](b: Block0[R], t: Transformer) = Block0(t(b.blockRes))\n   66:    def copyBlock1[T1:Manifest,R:Manifest](b: Block1[T1,R], t: Transformer) = Block1(t(b.blockArg1).asInstanceOf[Sym[T1]], t(b.blockRes))\n   67:    def copyBlock2[T1:Manifest,T2:Manifest,R:Manifest](b: Block2[T1,T2,R], t: Transformer) = Block2(t(b.blockArg1).asInstanceOf[Sym[T1]], t(b.blockArg2).asInstanceOf[Sym[T2]], t(b.blockRes))  \n   68  }\n   69    \n\n/home/gabriel/workspace/lms/src/common/Functions.scala:\n   64  \n   65  trait FunctionsExp extends Functions with EffectExp {\n   66:   case class Lambda[A:Manifest,B:Manifest](f: Exp[A] => Exp[B], x: Exp[A], y: Block[B]) extends Def[A => B] { val mA = manifest[A]; val mB = manifest[B] }\n   67    case class Apply[A:Manifest,B:Manifest](f: Exp[A => B], arg: Exp[A]) extends Def[B]\n   68  \n   ..\n  256      case e@Lambda(fun, x, y) =>\n  257        emitValDef(sym, \"{\" + quote(x, true) + \": (\" + x.tp + \") => \")\n  258:       emitBlock(y)\n  259:       if (y.tp != manifest[Unit]) stream.println(quote(getBlockResult(y)) + \": \" + y.tp)\n  260        stream.println(\"}\")\n  261  \n  ...\n  279      case Lambda(fun, UnboxedTuple(xs), y) =>\n  280        emitValDef(sym, \"{\" + xs.map(s=>quote(s, true)+\":\"+remap(s.tp)).mkString(\"(\",\",\",\")\") + \" => \")\n  281:       emitBlock(y)\n  282        var ytp = remap(y.tp).toString;\n  283:       if (ytp != manifest[Unit]) stream.println(quote(getBlockResult(y)) + \": \" + ytp )\n  284        stream.println(\"}\")\n  285  \n  ...\n  316          // The version for inlined device function\n  317          stream.println(addTab() + \"%s %s = %s;\".format(remap(x.tp), quote(x), quote(sym)+\"_1\"))\n  318:         emitBlock(y)\n  319:         stream.println(addTab() + \"%s %s = %s;\".format(remap(y.tp), quote(sym), quote(getBlockResult(y))))\n  320  \n  321          // The version for separate device function\n  ...\n  324          val freeVars = buildScheduleForResult(y).filter(scope.contains(_)).map(_.sym)\n  325          stream.println(\"__device__ %s %s(%s %s) {\".format(e.mB, quote(sym), e.mA, quote(x)))\n  326:         emitBlock(y)\n  327:         stream.println(\"%s %s = %s;\".format(e.mB, quote(sym), quote(getBlockResult(y))))\n  328:         stream.println(\"return %s;\".format(quote(getBlockResult(y))))\n  329          stream.println(\"}\")\n  330          */\n  ...\n  361      case e@Lambda(fun, x, y) =>\n  362        stream.println(remap(y.tp)+\" \"+quote(sym)+\"(\"+remap(x.tp)+\" \"+quote(x)+\") {\")\n  363:       emitBlock(y)\n  364:       val z = getBlockResult(y)\n  365        if (remap(z.tp) != \"void\")\n  366          stream.println(\"return \" + quote(z) + \";\")\n  ...\n  384      case Lambda(fun, UnboxedTuple(xs), y) =>\n  385        stream.println(remap(y.tp)+\" \"+quote(sym)+\"(\"+xs.map(s=>remap(s.tp)+\" \"+quote(s)).mkString(\",\")+\") {\")\n  386:       emitBlock(y)\n  387:       val z = getBlockResult(y)\n  388        if (remap(z.tp) != \"void\")\n  389          stream.println(\"return \" + quote(z) + \";\")\n\n/home/gabriel/workspace/lms/src/common/HashMapOps.scala:\n   27      def values(implicit pos: SourceContext) = hashmap_values(m)\n   28      def map[B:Manifest](f: Rep[(K,V)] => Rep[B]) = hashmap_map(m,f)\n   29:     def foreach(block: Rep[(K,V)] => Rep[Unit])(implicit pos: SourceContext) = hashmap_foreach(m, block)\n   30      def clear()(implicit pos: SourceContext) = hashmap_clear(m)\n   31      def keySet(implicit pos: SourceContext) = hashmap_keyset(m)\n   ..\n   46    def hashmap_values[K:Manifest,V:Manifest](m: Rep[HashMap[K,V]])(implicit pos: SourceContext): Rep[Iterable[V]]\n   47    def hashmap_map[K:Manifest,V:Manifest,B:Manifest](m: Rep[HashMap[K,V]], f: Rep[(K,V)]=>Rep[B]): Rep[HashMap[K,B]]\n   48:   def hashmap_foreach[K:Manifest,V:Manifest](x: Rep[HashMap[K,V]], block: Rep[(K,V)] => Rep[Unit])(implicit pos: SourceContext): Rep[Unit]\n   49    def hashmap_clear[K:Manifest,V:Manifest](m: Rep[HashMap[K,V]])(implicit pos: SourceContext): Rep[Unit]\n   50    def hashmap_keyset[K:Manifest,V:Manifest](m: Rep[HashMap[K,V]])(implicit pos: SourceContext): Rep[Set[K]]\n   ..\n   68    case class HashMapSize[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]]) extends HashMapDef[K,V,Int]\n   69    case class HashMapValues[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]]) extends HashMapDef[K,V,Iterable[V]]\n   70:   case class HashMapMap[K:Manifest,V:Manifest,B:Manifest](m: Exp[HashMap[K,V]], s: Sym[(K,V)], v:Block[B]) extends HashMapDef[K,V,HashMap[K,B]]\n   71:   case class HashMapForeach[K:Manifest, V:Manifest](a: Exp[HashMap[K,V]], x: Sym[(K,V)], block: Block[Unit], fun:Exp[(K,V)]=>Rep[Unit]) extends Def[Unit] \n   72    case class HashMapClear[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]]) extends HashMapDef[K,V,Unit]\n   73    case class HashMapKeySet[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]]) extends HashMapDef[K,V,Set[K]]\n   ..\n   76    case class HashMapRemove[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]], v:Rep[K]) extends HashMapDef[K,V,Unit]\n   77    case class HashMapGetOrElseUpdate[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]],\n   78: k: Exp[K], v: Block[V]) extends HashMapDef[K,V,V]\n   79    case class HashMapMkString[K:Manifest,V:Manifest](m: Exp[HashMap[K,V]], v:Rep[String]) extends HashMapDef[K,V,String]\n   80  \n   ..\n   94      reflectEffect(HashMapMap(m, a, b))//, summarizeEffects(b).star)\n   95    }\n   96:   def hashmap_foreach[K:Manifest,V:Manifest](x: Rep[HashMap[K,V]], block: Rep[(K,V)] => Rep[Unit])(implicit pos: SourceContext) = {\n   97      val k = fresh[(K,V)]\n   98:     val b = reifyEffects(block(k))\n   99: 	reflectEffect(HashMapForeach(x, k, b, block), summarizeEffects(b).star)\n  100    }\n  101  \n  ...\n  188      case HashMapMap(m,k,v)  => {\n  189  		 emitValDef(sym, quote(m) + \".map(\" + quote(k) + \"=> {\")\n  190:          emitBlock(v)\n  191: 	     emitBlockResult(v)\n  192           stream.println(\"})\")\n  193      }\n  194      case HashMapForeach(m,k,v,f)  => {\n  195  		 emitValDef(sym, quote(m) + \".foreach(\" + quote(k) + \"=> {\")\n  196:          emitBlock(v)\n  197: 	     emitBlockResult(v)\n  198           stream.println(\"})\")\n  199      }\n  200      case HashMapGetOrElseUpdate(m,k,v)  => {\n  201  	 	emitValDef(sym, quote(m) + \".getOrElseUpdate(\" + quote(k) + \",{\")\n  202:         emitBlock(v)\n  203: 	    emitBlockResult(v)\n  204          stream.println(\"})\")\n  205      }\n  ...\n  237  		emitValDef(sym, \"g_hash_table_lookup(\" + quote(m) + \",\" + quote(k) + \")\")\n  238  		stream.println(\"if (\" + quote(sym) + \"== NULL) {\")\n  239: 		emitBlock(v)\n  240: 		stream.println(\"g_hash_table_insert(\" + quote(m) + \",\" + quote(k) + \",\" + quote(getBlockResult(v)) + \");\")\n  241: 		stream.println(quote(sym) + \" = \" + quote(getBlockResult(v)) + \";\")\n  242  		stream.println(\"}\")\n  243  	}\n\n/home/gabriel/workspace/lms/src/common/IfThenElse.scala:\n   31    abstract class AbstractIfThenElse[T] extends Def[T] {\n   32      val cond: Exp[Boolean]\n   33:     val thenp: Block[T]\n   34:     val elsep: Block[T]\n   35    }\n   36    \n   37:   case class IfThenElse[T:Manifest](cond: Exp[Boolean], thenp: Block[T], elsep: Block[T]) extends AbstractIfThenElse[T]\n   38  \n   39    override def __ifThenElse[T:Manifest](cond: Rep[Boolean], thenp: => Rep[T], elsep: => Rep[T])(implicit pos: SourceContext) = {\n   ..\n   44    }\n   45  \n   46:   def ifThenElse[T:Manifest](cond: Rep[Boolean], thenp: Block[T], elsep: Block[T])(implicit pos: SourceContext) = {\n   47      val ae = summarizeEffects(thenp)\n   48      val be = summarizeEffects(elsep)\n   ..\n   66      case Reflect(IfThenElse(c,a,b), u, es) => \n   67        if (f.hasContext)\n   68:         __ifThenElse(f(c),f.reflectBlock(a),f.reflectBlock(b))\n   69        else\n   70          reflectMirrored(Reflect(IfThenElse(f(c),f(a),f(b)), mapOver(f,u), f(es)))(mtype(manifest[A]))\n   71      case IfThenElse(c,a,b) => \n   72        if (f.hasContext)\n   73:         __ifThenElse(f(c),f.reflectBlock(a),f.reflectBlock(b))\n   74        else\n   75          IfThenElse(f(c),f(a),f(b)) // FIXME: should apply pattern rewrites (ie call smart constructor)\n   ..\n   80    override def mirror[A:Manifest](e: Def[A], f: Transformer): Exp[A] = e match {\n   81      case Reflect(IfThenElse(c,a,b), u, es) => mirror(IfThenElse(c,a,b)) // discard reflect\n   82:     case IfThenElse(c,a,b) => ifThenElse(f(c),f(a),f(b)) // f.apply[A](a: Block[A]): Exp[A] mirrors the block into the current context\n   83      case _ => super.mirror(e,f)\n   84    }  \n   ..\n  131    abstract class AbstractFatIfThenElse extends FatDef {\n  132      val cond: Exp[Boolean]\n  133:     val thenp: List[Block[Any]]\n  134:     val elsep: List[Block[Any]]\n  135      \n  136      var extradeps: List[Exp[Any]] = Nil //HACK\n  137    }\n  138  \n  139:   case class SimpleFatIfThenElse(cond: Exp[Boolean], thenp: List[Block[Any]], elsep: List[Block[Any]]) extends AbstractFatIfThenElse\n  140  \n  141  /* HACK */\n  ...\n  188  \n  189    // it would be nice to handle rewrites in method ifThenElse but we'll need to\n  190:   // 'de-reify' blocks in case we rewrite if(true) to thenp. \n  191    // TODO: make reflect(Reify(..)) do the right thing\n  192    \n  ...\n  240        withStream(localStream) {\n  241          stream.println(\"if (\" + quote(c) + \") {\")\n  242:         emitBlock(a)\n  243: 		emitBlockResult(a)\n  244          stream.println(\"} else {\")\n  245:         emitBlock(b)\n  246: 		emitBlockResult(b)\n  247          stream.print(\"}\")\n  248        }\n  ...\n  268          stream.println(\"if (\" + quote(c) + \") {\")\n  269        } else stream.println(\"val \" + symList.map(quote).mkString + \" = if (\" + quote(c) + \") {\")\n  270:       emitFatBlock(as)\n  271:       if (symList.length > 1) emitRetAssignments(symList, as.map(getBlockResult))\n  272:       else stream.println(as.map(a => quote(getBlockResult(a))).mkString)\n  273        stream.println(\"} else {\")\n  274:       emitFatBlock(bs)\n  275:       if (symList.length > 1) emitRetAssignments(symList, bs.map(getBlockResult))\n  276:       else stream.println(bs.map(b => quote(getBlockResult(b))).mkString)\n  277        stream.println(\"}\")\n  278      */\n  ...\n  280        if (symList.length > 1) stream.println(\"// TODO: use vars instead of tuples to return multiple values\")\n  281        stream.println(\"val \" + quoteList(symList) + \" = if (\" + quote(c) + \") {\")\n  282:       emitFatBlock(as)\n  283:       stream.println(quoteList(as.map(getBlockResult)))\n  284        stream.println(\"} else {\")\n  285:       emitFatBlock(bs)\n  286:       stream.println(quoteList(bs.map(getBlockResult)))\n  287        stream.println(\"}\")\n  288      case _ => super.emitFatNode(symList, rhs)\n  ...\n  313                stream.println(addTab() + \"if (\" + quote(c) + \") {\")\n  314                tabWidth += 1\n  315:               emitBlock(a)\n  316                tabWidth -= 1\n  317                stream.println(addTab() + \"} else {\")\n  318                tabWidth += 1\n  319:               emitBlock(b)\n  320                tabWidth -= 1\n  321                stream.println(addTab()+\"}\")\n  ...\n  324                stream.println(addTab() + \"if (\" + quote(c) + \") {\")\n  325                tabWidth += 1\n  326:               emitBlock(a)\n  327:               stream.println(addTab() + \"%s = %s;\".format(quote(sym),quote(getBlockResult(a))))\n  328                tabWidth -= 1\n  329                stream.println(addTab() + \"} else {\")\n  330                tabWidth += 1\n  331:               emitBlock(b)\n  332:               stream.println(addTab() + \"%s = %s;\".format(quote(sym),quote(getBlockResult(b))))\n  333                tabWidth -= 1\n  334                stream.println(addTab()+\"}\")\n  ...\n  365                stream.println(addTab() + \"if (\" + quote(c) + \") {\")\n  366                tabWidth += 1\n  367:               emitBlock(a)\n  368                tabWidth -= 1\n  369                stream.println(addTab() + \"} else {\")\n  370                tabWidth += 1\n  371:               emitBlock(b)\n  372                tabWidth -= 1\n  373                stream.println(addTab()+\"}\")\n  ...\n  376                stream.println(addTab() + \"if (\" + quote(c) + \") {\")\n  377                tabWidth += 1\n  378:               emitBlock(a)\n  379:               stream.println(addTab() + \"%s = %s;\".format(quote(sym),quote(getBlockResult(a))))\n  380                tabWidth -= 1\n  381                stream.println(addTab() + \"} else {\")\n  382                tabWidth += 1\n  383:               emitBlock(b)\n  384:               stream.println(addTab() + \"%s = %s;\".format(quote(sym),quote(getBlockResult(b))))\n  385                tabWidth -= 1\n  386                stream.println(addTab()+\"}\")\n  ...\n  411            case true =>\n  412              stream.println(\"if (\" + quote(c) + \") {\")\n  413:             emitBlock(a)\n  414              stream.println(\"} else {\")\n  415:             emitBlock(b)\n  416              stream.println(\"}\")\n  417            case false =>\n  418              stream.println(\"%s %s;\".format(remap(sym.tp),quote(sym)))\n  419              stream.println(\"if (\" + quote(c) + \") {\")\n  420:             emitBlock(a)\n  421:             stream.println(\"%s = %s;\".format(quote(sym),quote(getBlockResult(a))))\n  422              stream.println(\"} else {\")\n  423:             emitBlock(b)\n  424:             stream.println(\"%s = %s;\".format(quote(sym),quote(getBlockResult(b))))\n  425              stream.println(\"}\")\n  426          }\n  ...\n  430            stream.println(\"%s %s;\".format(remap(sym.tp),quote(sym)))\n  431            stream.println(\"if (\" + quote(c) + \") {\")\n  432:           emitBlock(a)\n  433:           stream.println(\"%s = %s;\".format(quote(sym),quote(getBlockResult(a))))\n  434            stream.println(\"} else {\")\n  435:           emitBlock(b)\n  436:           stream.println(\"%s = %s;\".format(quote(sym),quote(getBlockResult(b))))\n  437            stream.println(\"}\")\n  438          }\n  439          else {\n  440            stream.println(\"if (\" + quote(c) + \") {\")\n  441:           emitBlock(a)\n  442            stream.println(\"} else {\")\n  443:           emitBlock(b)\n  444            stream.println(\"}\")\n  445          }\n  ...\n  458        if (symList.length > 1) stream.println(\"// TODO: use vars instead of tuples to return multiple values\")\n  459        stream.println(\"if (\" + quote(c) + \") {\")\n  460:       emitFatBlock(as)\n  461:       stream.println(quoteList(as.map(getBlockResult)))\n  462        stream.println(\"} else {\")\n  463:       emitFatBlock(bs)\n  464:       stream.println(quoteList(bs.map(getBlockResult)))\n  465        stream.println(\"}\")\n  466  \n\n/home/gabriel/workspace/lms/src/common/IterableOps.scala:\n   15  \n   16    class IterableOpsCls[T:Manifest](a: Rep[Iterable[T]]){\n   17:     def foreach(block: Rep[T] => Rep[Unit])(implicit pos: SourceContext) = iterable_foreach(a, block)\n   18      def toArray(implicit pos: SourceContext) = iterable_toarray(a)\n   19    }\n   20  \n   21:   def iterable_foreach[T:Manifest](x: Rep[Iterable[T]], block: Rep[T] => Rep[Unit])(implicit pos: SourceContext): Rep[Unit]\n   22    def iterable_toarray[T:Manifest](x: Rep[Iterable[T]])(implicit pos: SourceContext): Rep[Array[T]]\n   23  }\n   ..\n   25  trait IterableOpsExp extends IterableOps with EffectExp with VariablesExp {\n   26  \n   27:   case class IterableForeach[T:Manifest](a: Exp[Iterable[T]], x: Sym[T], block: Block[Unit]) extends Def[Unit]\n   28    case class IterableToArray[T:Manifest](a: Exp[Iterable[T]]) extends Def[Array[T]] {\n   29      val m = manifest[T]\n   30    }\n   31    \n   32:   def iterable_foreach[T:Manifest](a: Exp[Iterable[T]], block: Exp[T] => Exp[Unit])(implicit pos: SourceContext): Exp[Unit] = {\n   33      val x = fresh[T]\n   34:     val b = reifyEffects(block(x))\n   35      reflectEffect(IterableForeach(a, x, b), summarizeEffects(b).star)\n   36    }\n   ..\n   73  \n   74    override def emitNode(sym: Sym[Any], rhs: Def[Any]) = rhs match {\n   75:     case IterableForeach(a,x,block) =>\n   76        gen\"\"\"$a.foreach{\n   77             |$x => \n   78:            |${nestedBlock(block)}\n   79:            |$block\n   80             |}\"\"\"\n   81      case IterableToArray(a) => emitValDef(sym, src\"$a.toArray\")\n\n/home/gabriel/workspace/lms/src/common/ListBuffer.scala:\n   35  	}\n   36      case class ListmkString[A:Manifest](x: Rep[mutable.ListBuffer[A]], y: Rep[String]) extends Def[String]\n   37:     case class ListBufferForeach[A:Manifest, B:Manifest](l: Exp[mutable.ListBuffer[A]], x: Sym[A], block: Block[B]) extends Def[Unit]\n   38  \n   39  	def newListBuffer[A:Manifest](x: Rep[String] = unit(\"\")) = reflectEffect(NewListBuffer[A](x))\n   ..\n   80          case ListBufferForeach(l,x,blk) => {\n   81              stream.println(\"val \" + quote(sym) + \" = \" + quote(l) + \".foreach { \"+ quote(x) + \" => \")\n   82:             emitBlock(blk)\n   83:             stream.println(quote(getBlockResult(blk)))\n   84              stream.println(\"}\")\n   85          }\n\n/home/gabriel/workspace/lms/src/common/ListOps.scala:\n   61    }\n   62    case class ListFromSeq[A:Manifest](xs: Rep[Seq[A]]) extends Def[List[A]]\n   63:   case class ListMap[A:Manifest,B:Manifest](l: Exp[List[A]], x: Sym[A], block: Block[B]) extends Def[List[B]]\n   64:   case class ListForeach[A:Manifest](l: Exp[List[A]], x: Sym[A], block: Block[Unit]) extends Def[Unit]\n   65:   case class ListFlatMap[A:Manifest, B:Manifest](l: Exp[List[A]], x: Sym[A], block: Block[List[B]]) extends Def[List[B]]\n   66:   case class ListFilter[A : Manifest](l: Exp[List[A]], x: Sym[A], block: Block[Boolean]) extends Def[List[A]]\n   67:   case class ListSortBy[A:Manifest,B:Manifest:Ordering](l: Exp[List[A]], x: Sym[A], block: Block[B]) extends Def[List[A]]\n   68    case class ListPrepend[A:Manifest](x: Exp[List[A]], e: Exp[A]) extends Def[List[A]]\n   69    case class ListToArray[A:Manifest](x: Exp[List[A]]) extends Def[Array[A]]\n   ..\n  183        withStream(localStream) {\n  184          gen\"\"\"$l.map { $x => \n  185:              |${nestedBlock(blk)}\n  186               |$blk\n  187               |}\"\"\"\n  ...\n  190      case ListForeach(l,x,blk) => {\n  191        gen\"\"\"$l.foreach { $x => \n  192:            |${nestedBlock(blk)}\n  193             |}\"\"\"\n  194      }\n  ...\n  198        withStream(localStream) {\n  199          gen\"\"\"$l.flatMap { $x => \n  200:              |${nestedBlock(b)}\n  201               |$b\n  202               |}\"\"\"\n  ...\n  209        withStream(localStream) {\n  210          gen\"\"\"$l.filter { $x => \n  211:              |${nestedBlock(b)}\n  212               |$b\n  213               |}\"\"\"\n  ...\n  220        withStream(localStream) {\n  221          gen\"\"\"$l.sortBy { $x => \n  222:              |${nestedBlock(blk)}\n  223               |$blk\n  224               |}\"\"\"\n\n/home/gabriel/workspace/lms/src/common/LivenessOpt.scala:\n    3  \n    4  import java.io.PrintWriter\n    5: import scala.virtualization.lms.internal.NestedBlockTraversal\n    6  \n    7  import scala.collection.mutable\n    8  \n    9: trait LivenessOpt extends NestedBlockTraversal {\n   10    import IR._  \n   11    \n   ..\n   34  \n   35  \n   36:   override def focusBlock[A](result: Block[Any])(body: => A): A = {\n   37:     super.focusBlock(result) {\n   38  \n   39:       printlog(\"gathering liveness info for block \" + result)\n   40  \n   41        val used = new mutable.HashSet[Sym[Any]]\n   ..\n   53  \n   54  \n   55: trait DefUseAnalysis extends NestedBlockTraversal {\n   56    import IR._  \n   57    \n   58    var defUseMap: Map[Exp[Any], Set[Exp[Any]]] = _\n   59  \n   60:   override def focusBlock[A](result: Block[Any])(body: => A): A = {\n   61:     super.focusBlock(result) {\n   62        val saveDefUseMap = defUseMap\n   63        defUseMap \n\n/home/gabriel/workspace/lms/src/common/LoopFusionOpt.scala:\n    8    current fusion algorithm:\n    9  \n   10:     - start with a given scope, as obtained by focusBlock\n   11  \n   12      - find top level statements (using code motion algorithm)\n   ..\n   77    unrelated question: can we separate loop fusion and code motion?\n   78  \n   79:     a1 = SimpleLoop(s, i1, ArrayElem(Block(e1)))\n   80  \n   81:     a2 = SimpleLoop(s, i2, ArrayElem(Block(e2)))\n   82  \n   83    becomes:\n   84  \n   85:     a1,a2 = SimpleFatLoop(s, i12, ArrayElem(Block(e1)), ArrayElem(Block(e2)))\n   86  \n   87:   we still have separate blocks for the ArrayElems.\n   88  \n   89:   currently, calling emitFatBlock on the list of all embedded blocks List(e1,e2)\n   90:   will effectively combine the blocks during the descent, triggering\n   91    fusion of inner loops and other optimizations.\n   92  \n   93    if we descend separately we miss opportunities.\n   94  \n   95:   an isolated fusion pass will need to physically merge the blocks. a yield\n   96    based version may achieve this:\n   97  \n   98:     a1,a2 = SimpleFatLoop(s, i12, y1=ArrayElem, y2=ArrayElem, Block(e12)))\n   99  \n  100    where e12 invokes y1 and y2 internally.\n  101  \n  102:   RULE: isolated passes need to merge blocks\n  103  */\n  104  \n  105  \n  106  /*\n  107:   another idea: make block results staging time values\n  108  \n  109:     case class Block[T](res: T)\n  110  \n  111:   and use syms(res) to get the block result expressions.\n  112  \n  113:   this would allow moving arbitrary stuff inside blocks:\n  114  \n  115:     a1,a2 = SimpleFatLoop(s, i12, Block((ArrayElem(e1), ArrayElem(e2))))\n  116  \n  117  */\n  ...\n  172  \n  173  \n  174: trait LoopFusionOpt extends internal.FatBlockTraversal with LoopFusionCore {\n  175    val IR: LoopsFatExp with IfThenElseFatExp\n  176    import IR._\n  ...\n  178  \n  179  \n  180:   override def focusExactScopeFat[A](resultB: List[Block[Any]])(body: List[Stm] => A): A = {\n  181:     val result0 = resultB.map(getBlockResultFull) flatMap { case Combine(xs) => xs case x => List(x) }\n  182      val (scope,result) = fuseTopLevelLoops(innerScope)(result0)\n  183      innerScope = scope\n  ...\n  185      // we don't currently propagate a modified result to the parent\n  186  \n  187:     // the caller of traverseBlock will quite likely call getBlockResult afterwards,\n  188      // and if we change the result here, the caller will emit a reference to a sym\n  189      // that doesn't exist (because it was replaced)\n  ...\n  195          case (r0 @ Def(Reify(x, _, _)),Def(Reify(y, u, es))) =>\n  196            if (!x.isInstanceOf[Sym[_]])\n  197:             printlog(\"non-sym block result: \" + x + \" to \" + y)\n  198            else if (x != y)\n  199              innerScope = innerScope :+ TP(x.asInstanceOf[Sym[Any]], Forward(y))\n  ...\n  205      }\n  206  \n  207:     super.focusExactScopeFat(result0.map(Block(_)))(body)\n  208    }\n  209  \n  ...\n  304          //println(\"Wloops \" + Wloops)\n  305  \n  306:         // find negative dependencies (those that block fusion)\n  307  \n  308          // might be costly: resolve and traverse complete input deps for each loop body\n  ...\n  554      println(\"Wloops \" + Wloops)\n  555  \n  556:         // find negative dependencies (those that block fusion)\n  557  \n  558          // might be costly: resolve and traverse complete input deps for each loop body\n\n/home/gabriel/workspace/lms/src/common/Loops.scala:\n    4  import java.io.PrintWriter\n    5  import scala.reflect.SourceContext\n    6: import scala.virtualization.lms.internal.{FatBlockTraversal,GenericNestedCodegen,GenericFatCodegen}\n    7  import scala.reflect.SourceContext\n    8  \n    .\n  133  \n  134  \n  135: trait BaseLoopsTraversalFat extends FatBlockTraversal {\n  136    val IR: LoopsFatExp\n  137    import IR._\n\n/home/gabriel/workspace/lms/src/common/MultiMap.scala:\n   20      def update(k: Rep[K], v: Rep[V])(implicit pos: SourceContext) = hashmultimap_update(m,k,v)\n   21      def contains(k: Rep[K])(implicit pos: SourceContext) = hashmultimap_contains(m, k)\n   22:     def foreach(block: Rep[(K,Set[V])] => Rep[Unit])(implicit pos: SourceContext) = hashmultimap_foreach(m, block)\n   23      def mkString(delimiter: Rep[String]) = hashmultimap_mkString(m, delimiter)\n   24      def getOrElseEmpty(k: Rep[K])(implicit pos: SourceContext) = hashmultimap_getorelseempty(m,k)\n   ..\n   30    def hashmultimap_update[K:Manifest,V:Manifest](m: Rep[HashMap[K,Set[V]]], k: Rep[K], v: Rep[V])(implicit pos: SourceContext): Rep[Unit]\n   31    def hashmultimap_contains[K:Manifest,V:Manifest](m: Rep[HashMap[K,Set[V]]], i: Rep[K])(implicit pos: SourceContext): Rep[Boolean]\n   32:   def hashmultimap_foreach[K:Manifest,V:Manifest](x: Rep[HashMap[K,Set[V]]], block: Rep[(K,Set[V])] => Rep[Unit])(implicit pos: SourceContext): Rep[Unit]\n   33    def hashmultimap_mkString[K: Manifest, V: Manifest](m: Rep[HashMap[K,Set[V]]], v: Rep[String])(implicit pos: SourceContext): Rep[String]\n   34    def hashmultimap_getorelseempty[K:Manifest,V:Manifest](m: Rep[HashMap[K,Set[V]]], k: Rep[K])(implicit pos: SourceContext): Rep[Set[V]]\n   ..\n   45    case class HashMultiMapUpdate[K:Manifest,V:Manifest](m: Exp[HashMap[K,Set[V]]], k: Exp[K], v: Exp[V]) extends HashMultiMapDef[K,V,Unit]\n   46    case class HashMultiMapContains[K:Manifest,V:Manifest](m: Exp[HashMap[K,Set[V]]], i: Exp[K]) extends HashMultiMapDef[K,V,Boolean]\n   47:   case class HashMultiMapForeach[K:Manifest, V:Manifest](a: Exp[HashMap[K,Set[V]]], x: Sym[(K,Set[V])], block: Block[Unit]) extends Def[Unit]\n   48    case class HashMultiMapMkString[K:Manifest,V:Manifest](m: Exp[HashMap[K,Set[V]]], v:Rep[String]) extends HashMultiMapDef[K,V,String]\n   49    case class HashMultiMapGetOrElseEmpty[K:Manifest,V:Manifest](m: Exp[HashMap[K,Set[V]]], k: Exp[K]) extends HashMultiMapDef[K,V,Set[V]]\n   ..\n   54    def hashmultimap_update[K:Manifest,V:Manifest](m: Exp[HashMap[K,Set[V]]], k: Exp[K], v: Exp[V])(implicit pos: SourceContext) = reflectEffect(HashMultiMapUpdate[K,V](m,k,v))\n   55    def hashmultimap_contains[K:Manifest,V:Manifest](m: Exp[HashMap[K,Set[V]]], i: Exp[K])(implicit pos: SourceContext) = HashMultiMapContains(m, i)\n   56:   def hashmultimap_foreach[K:Manifest,V:Manifest](x: Rep[HashMap[K,Set[V]]], block: Rep[(K,Set[V])] => Rep[Unit])(implicit pos: SourceContext) = {\n   57      val k = fresh[(K,Set[V])]\n   58:     val b = reifyEffects(block(k))\n   59  	reflectEffect(HashMultiMapForeach(x, k, b), summarizeEffects(b).star)\n   60    }\n   ..\n   96      case HashMultiMapContains(m,i) => emitValDef(sym, quote(m) + \".contains(\" + quote(i) + \")\")\n   97      case HashMultiMapForeach(m,k,v) => emitValDef(sym, quote(m) + \".foreach(\" + quote(k) + \"=>{\")\n   98: 		emitBlock(v)\n   99: 		emitBlockResult(v)\n  100  		stream.println(\"})\")\n  101      case HashMultiMapMkString(m,k) => emitValDef(sym, quote(m) + \".mkString(\" + quote(k) + \")\")\n\n/home/gabriel/workspace/lms/src/common/RangeOps.scala:\n   33    case class RangeEnd(r: Exp[Range]) extends Def[Int]\n   34    //case class RangeForeach(r: Exp[Range], i: Exp[Int], body: Exp[Unit]) extends Def[Unit]\n   35:   case class RangeForeach(start: Exp[Int], end: Exp[Int], i: Sym[Int], body: Block[Unit]) extends Def[Unit]\n   36  \n   37    def range_until(start: Exp[Int], end: Exp[Int])(implicit pos: SourceContext) : Exp[Range] = Until(start, end)\n   ..\n   45      case _ => RangeEnd(r)\n   46    }\n   47:   def range_foreach(r: Exp[Range], block: Exp[Int] => Exp[Unit])(implicit pos: SourceContext) : Exp[Unit] = {\n   48      val i = fresh[Int]\n   49:     val a = reifyEffects(block(i))\n   50      reflectEffect(RangeForeach(r.start, r.end, i, a), summarizeEffects(a).star)\n   51    }\n   ..\n   90      case RangeForeach(r, i, body) => {\n   91        stream.println(\"val \" + quote(sym) + \" = \" + quote(r) + \".foreach{ \" + quote(i) + \": Int =>\")\n   92:       emitBlock(body)\n   93:       stream.println(quote(getBlockResult(body)))\n   94        stream.println(\"}\")\n   95      }\n   ..\n   98      case RangeForeach(start, end, i, body) => {\n   99        // do not need to print unit result\n  100:       //stream.println(quote(getBlockResult(body)))\n  101        gen\"var $i : Int = $start\"\n  102        emitValDef(sym, src\"while ($i < $end) {\")\n  103:       gen\"\"\"${nestedBlock(body)}\n  104             |$i = $i + 1\n  105             |}\"\"\"\n  ...\n  124        /*\n  125          //var freeVars = buildScheduleForResult(body).filter(scope.contains(_)).map(_.sym)\n  126:         val freeVars = getFreeVarBlock(body,List(i.asInstanceOf[Sym[Any]]))\n  127          // Add the variables of range to the free variable list if necessary\n  128          var paramList = freeVars\n  ...\n  135          gen\"${addTab()}for(int $i=$start; $i < $end; $i++) {\"\n  136          tabWidth += 1\n  137:         emitBlock(body)\n  138          tabWidth -= 1\n  139          gen\"${addTab()}}\"\n  ...\n  152      case RangeForeach(start, end, i, body) =>\n  153        gen\"\"\"for(int $i=$start; $i < $end; $i++) {\n  154:            |${nestedBlock(body)}\n  155             |}\"\"\"\n  156  \n  ...\n  169  	  stream.println(remap(i.tp) + \" \" + quote(i) + \";\") // Some compilers don't like the initialization inside for\n  170        gen\"\"\"for($i=$start; $i < $end; $i++) {\n  171:            |${nestedBlock(body)}\n  172             |}\"\"\"\n  173  \n\n/home/gabriel/workspace/lms/src/common/SetOps.scala:\n   25      def toArray(implicit pos: SourceContext) = set_toarray(s)\n   26      def map[B:Manifest](f: Rep[A] => Rep[B]) = set_map(s,f)\n   27:     def foreach(block: Rep[A] => Rep[Unit])(implicit pos: SourceContext) = set_foreach(s, block)\n   28    }\n   29  \n   ..\n   37    def set_toseq[A:Manifest](s: Rep[Set[A]])(implicit pos: SourceContext): Rep[Seq[A]]\n   38    def set_toarray[A:Manifest](s: Rep[Set[A]])(implicit pos: SourceContext): Rep[Array[A]]\n   39:   def set_foreach[T:Manifest](x: Rep[Set[T]], block: Rep[T] => Rep[Unit])(implicit pos: SourceContext): Rep[Unit]\n   40    def set_empty[T:Manifest]() : Rep[Set[T]]\n   41  }\n   ..\n   53      val array = NewArray[A](s.size)\n   54    }\n   55:   case class SetMap[A:Manifest,B:Manifest](a: Exp[Set[A]], x: Sym[A], block: Block[B]) extends Def[Set[B]]\n   56:   case class SetForeach[T](a: Exp[Set[T]], x: Sym[T], block: Block[Unit]) extends Def[Unit]\n   57    case class SetEmpty[T:Manifest]() extends Def[Set[T]] {\n   58  	val m = manifest[T]\n   ..\n   67    def set_toseq[A:Manifest](s: Exp[Set[A]])(implicit pos: SourceContext) = SetToSeq(s)\n   68    def set_toarray[A:Manifest](s: Exp[Set[A]])(implicit pos: SourceContext) = SetToArray(s)\n   69:   def set_foreach[T:Manifest](a: Exp[Set[T]], block: Exp[T] => Exp[Unit])(implicit pos: SourceContext): Exp[Unit] = {\n   70      val x = fresh[T]\n   71:     val b = reifyEffects(block(x))\n   72      reflectEffect(SetForeach(a, x, b), summarizeEffects(b).star)\n   73    }\n   ..\n  129        src\"\\nout\" +\n  130        src\"\\n}\")\n  131:     case SetForeach(a,x,block) => \n  132        emitValDef(sym, src\"$a.foreach{\")    \n  133        gen\"\"\"$x => \n  134:            |${nestedBlock(block)}\n  135:            |$block\n  136             |}\"\"\"\n  137: 	case SetMap(a,x,block) => \n  138        emitValDef(sym, src\"$a.map{\")    \n  139        gen\"\"\"$x => \n  140:            |${nestedBlock(block)}\n  141:            |$block\n  142             |}\"\"\"\n  143  	case s@SetEmpty() => emitValDef(sym, \"scala.collection.mutable.HashSet.empty\")\n\n/home/gabriel/workspace/lms/src/common/SimplifyTransform.scala:\n   90      mirrorFatDef(x, t)\n   91    }\n   92:   def transformIfBody[A](s: Sym[A], x: Block[A], t: SubstTransformer): Block[A] = {\n   93      implicit val m: Manifest[A] = s.tp.asInstanceOf[Manifest[A]]\n   94      //transformOne(s,x,t)\n\n/home/gabriel/workspace/lms/src/common/SplitEffects.scala:\n   46          val TP(loopSym, Reflect(While(_,_),_,_)) = globalDefs.last\n   47  \n   48:         def xtract(b:Block[Any]) = b match {\n   49:           case Block(Def(Reify(_,_,es: List[Sym[Any]] @unchecked))) =>\n   50              es map (e=>findDefinition(e)) collect {\n   51                case Some(t@TP(s1,Reflect(PreviousIteration(_),u,_))) if mayWrite(u,List(s)) => t }}\n   ..\n   94      Pure().copy(mayRead = projectL(u.mayRead,s), mstRead = projectL(u.mstRead,s),\n   95             mayWrite = projectL(u.mayWrite,s), mstWrite = projectL(u.mstWrite,s))\n   96:   def projectB(b: Block[Any], s: List[Sym[Any]]): Block[Unit] = b match {\n   97:     case Block(Def(Reify(x, u, es))) =>\n   98:       //println(\"project block \" + s + \": \" + es.map(e=>findDefinition(e.asInstanceOf[Sym[Any]])))\n   99        val deps = calculateDependencies(es, Write(s), false)\n  100        //println(\"deps: \" + deps.map(e=>findDefinition(e.asInstanceOf[Sym[Any]])))\n  101  \n  102:       Block(Reify(Const(), projectS(u,s), deps))\n  103:     case _ => Block(Const(()))\n  104    }\n  105  \n  106    def projectSimpleS(u: Summary) =\n  107      Pure().copy(maySimple = u.maySimple, mstSimple = u.mstSimple)\n  108:   def projectSimpleB(b: Block[Any]): Block[Unit] = b match {\n  109:     case Block(Def(Reify(x, u, es))) => Block(Reify(Const(), projectSimpleS(u), calculateDependencies(es, Simple(), false)))\n  110:     case _ => Block(Const(()))\n  111    }\n  112  \n  113    def projectPureS(u: Summary) = Pure()\n  114:   def projectPureB[A](b: Block[A]): Block[A] = b match {\n  115:     case Block(Def(Reify(x, u, es))) => Block(x)\n  116      case _ => b\n  117    }\n  118  \n  119:   def projectPureWithB[A:Manifest](b: Block[A], s: List[Sym[Any]]): Block[A] = {\n  120      (projectPureB(b), projectB(b,s)) match {\n  121:       case (Block(x), Block(Def(Reify(Const(()), u, es)))) => Block(Reify(x, u, es))\n  122        case (a,_) => a\n  123      }\n  124    }\n  125:   def projectPureWithSimpleB[A:Manifest](b: Block[A]): Block[A] = {\n  126      (projectPureB(b), projectSimpleB(b)) match {\n  127:       case (Block(x), Block(Def(Reify(Const(()), u, es)))) => Block(Reify(x, u, es))\n  128        case (a,_) => a\n  129      }\n  ...\n  133  \n  134  \n  135: case class SimpleFatWhile(cond: Block[Boolean], body: List[Block[Any]]) extends FatDef {\n  136    var extradeps: List[Sym[Any]] = Nil //HACK\n  137  }\n  ...\n  174    import IR._\n  175  \n  176:   override def reifyBlock[T: Manifest](x: => Exp[T]): Block[T] = {\n  177:     val sup = super.reifyBlock(x)\n  178      projectPureWithSimpleB(sup)\n  179    }\n  ...\n  210      val m = e2 groupBy {\n  211        case t@TTP(lhs, mhs, p @ SimpleFatIfThenElse(c,as,bs)) => (c, \"if\")\n  212:       case t@TTP(lhs, mhs, p @ SimpleFatWhile(Block(Def(Reify(c,_,_))),b)) => (c, \"while\")\n  213        case t@TTP(lhs, mhs, p @ SimpleFatPrevious(k,es)) => (k,\"prev\")\n  214      }\n  ...\n  224            wls.flatMap(_.rhs.asInstanceOf[SimpleFatWhile].body))\n  225          x.extradeps = wls.flatMap(_.rhs.asInstanceOf[SimpleFatWhile].extradeps) diff wls.flatMap(_.lhs)\n  226:         TTP(wls.flatMap(_.lhs), wls.flatMap(_.mhs), // TODO: merge cond blocks!\n  227          x)\n  228        case ((k:Exp[Nothing] @unchecked,\"prev\"), pvs: List[TTP]) =>\n  ...\n  241        //if (symList.length > 1) stream.println(\"// TODO: use vars instead of tuples to return multiple values\")\n  242        stream.println(\"while ({ // \" + symList)\n  243:       emitFatBlock(List(c))\n  244:       stream.println(quoteList(List(c).map(getBlockResult)))\n  245        stream.println(\"}) {\")\n  246:       emitFatBlock(b)\n  247:       //stream.println(quoteList(b.map(getBlockResult)))\n  248        stream.println(\"}\")\n  249      case _ => super.emitFatNode(symList, rhs)\n\n/home/gabriel/workspace/lms/src/common/StaticData.scala:\n   34    }\n   35    \n   36:   override def getFreeDataBlock[A](start: Block[A]): List[(Sym[Any],Any)] = {\n   37:     focusBlock(start) {\n   38        innerScope flatMap {\n   39          case TP(sym, rhs) =>\n\n/home/gabriel/workspace/lms/src/common/Structs.scala:\n  141  \n  142  \n  143:   override def ifThenElse[T:Manifest](cond: Rep[Boolean], a: Block[T], b: Block[T])(implicit pos: SourceContext) = (a,b) match {\n  144:     case (Block(Def(Struct(tagA,elemsA))), Block(Def(Struct(tagB, elemsB)))) =>\n  145        assert(tagA == tagB)\n  146        assert(elemsA.keySet == elemsB.keySet)\n  147:       val elemsNew = for (k <- elemsA.keySet) yield (k -> ifThenElse(cond, Block(elemsA(k)), Block(elemsB(k)))(elemsB(k).tp, pos))\n  148        struct[T](tagA, elemsNew.toMap)\n  149      case _ => super.ifThenElse(cond,a,b)\n  ...\n  192    // Phi nodes:\n  193    // created by splitting an IfThenElse node\n  194:   // a1 and b1 will be the effects of the original IfThenElse, packaged into blocks with a unit result\n  195  \n  196:   case class Phi[T](cond: Exp[Boolean], a1: Block[Unit], val thenp: Block[T], b1: Block[Unit], val elsep: Block[T])(val parent: Exp[Unit]) extends AbstractIfThenElse[T] // parent points to conditional\n  197:   def phi[T:Manifest](c: Exp[Boolean], a1: Block[Unit], a2: Exp[T], b1: Block[Unit], b2: Exp[T])(parent: Exp[Unit]): Exp[T] = if (a2 == b2) a2 else Phi(c,a1,Block(a2),b1,Block(b2))(parent)\n  198:   def phiB[T:Manifest](c: Exp[Boolean], a1: Block[Unit], a2: Block[T], b1: Block[Unit], b2: Block[T])(parent: Exp[Unit]): Exp[T] = if (a2 == b2) a2.res else Phi(c,a1,a2,b1,b2)(parent) // FIXME: duplicate\n  199  \n  200    override def syms(x: Any): List[Sym[Any]] = x match {\n  ...\n  218    }\n  219  \n  220:   def deReify[T:Manifest](a: Block[T]): (Block[Unit], Rep[T]) = a match { // take Reify(stms, e) and return Reify(stms, ()), e\n  221:     case Block(Def(Reify(x,es,u))) => (Block(Reify(Const(()), es, u)), x)\n  222:     case Block(x) => (Block(Const(())), x)\n  223    }\n  224  \n  225  \n  226:   override def ifThenElse[T:Manifest](cond: Rep[Boolean], a: Block[T], b: Block[T])(implicit pos: SourceContext) = (deReify(a),deReify(b)) match {\n  227      case ((u, Def(Struct(tagA,elemsA))), (v, Def(Struct(tagB, elemsB)))) =>\n  228        assert(tagA == tagB)\n  ...\n  381        TTP(ss, phis map (_.rhs), SimpleFatIfThenElse(c,us,vs))\n  382      }\n  383:     def fatif(s:Sym[Unit],o:Def[Unit],c:Exp[Boolean],a:Block[Unit],b:Block[Unit]) = fatphi(s) match {\n  384        case Some(TTP(ss, oo, SimpleFatIfThenElse(c2,us,vs))) =>\n  385          assert(c == c2)\n  ...\n  393      val r = e.flatMap {\n  394        case TP(sym, p@Phi(c,a,u,b,v)) => Nil\n  395:       case TP(sym:Sym[Unit] @unchecked, o@IfThenElse(c,a:Block[Unit] @unchecked,b:Block[Unit] @unchecked)) => List(fatif(sym,o.asInstanceOf[Def[Unit]],c,a,b))\n  396:       case TP(sym:Sym[Unit] @unchecked, o@Reflect(IfThenElse(c,a:Block[Unit] @unchecked,b:Block[Unit] @unchecked),_,_)) => List(fatif(sym,o.asInstanceOf[Def[Unit]],c,a,b))\n  397        case t => List(fatten(t))\n  398      } ++ orphans.map { case s: Sym[Unit] @unchecked => fatphi(s).get } // be fail-safe here?\n\n/home/gabriel/workspace/lms/src/common/TreeSet.scala:\n   23  \n   24  trait TreeSetExp extends TreeSet with BaseExp with Effects {\n   25: 	case class NewTreeSet[M: Manifest](x: Block[Int], sType: String = \"\", o1: Sym[M], o2: Sym[M]) extends Def[mutable.TreeSet[M]] {\n   26          val m = manifest[M]\n   27      }\n   ..\n   58              stream.println(\"new Ordering[\" + treeType + \"] {\")\n   59              stream.println(\" def compare(\" + quote(o1) + \": \" + treeType + \", \" + quote(o2) +\": \" + treeType + \") = { \")\n   60:             emitBlock(x)\n   61:             stream.println(quote(getBlockResult(x)))\n   62              stream.println(\"}})\")\n   63  		}\n\n/home/gabriel/workspace/lms/src/common/UninlinedFunctions.scala:\n   90      if (si != null) {\n   91          val state = reifyEffects(si())\n   92:         emitBlock(state)\n   93      }\n   94    }\n   ..\n  102    }\n  103  \n  104:   private def printUninlinedFuncBody[T:Manifest](b: Block[T]) {\n  105:     emitBlock(b)\n  106:     stream.println(quote(getBlockResult(b)))\n  107      stream.println(\"}\")\n  108      stream.println(\"}\")\n  ...\n  193      if (si != null) {\n  194          val state = reifyEffects(si())\n  195:         emitBlock(state)\n  196      }\n  197    }\n  ...\n  205    }\n  206  \n  207:   private def printUninlinedFuncBody[T:Manifest](b: Block[T]) = {\n  208  	val sw = new StringWriter()\n  209  	val pw = new PrintWriter(sw)\n  210  	withStream(pw) {\n  211:     	emitBlock(b)\n  212: 	    stream.println(\"return \" + quote(getBlockResult(b)) + \";\")\n  213      	stream.println(\"}\")\n  214  	    stream.println()\n\n/home/gabriel/workspace/lms/src/common/While.scala:\n   13  \n   14  trait WhileExp extends While with EffectExp {\n   15:   case class While(cond: Block[Boolean], body: Block[Unit]) extends Def[Unit]\n   16:   case class DoWhile(body: Block[Unit], cond: Block[Boolean]) extends Def[Unit]\n   17  \n   18    override def __whileDo(cond: => Exp[Boolean], body: => Rep[Unit])(implicit pos: SourceContext) = {\n   ..\n  122  //<<<<<<< HEAD\n  123        emitValDef(sym, \"while ({\")\n  124:       emitBlock(c)\n  125:       stream.println(quote(getBlockResult(c)))\n  126        stream.println(\"}) {\")\n  127:       emitBlock(b)\n  128:       stream.println(quote(getBlockResult(b)))\n  129        stream.println(\"}\")\n  130  /*=======\n  ...\n  134        withStream(localStream) {\n  135          stream.print(\"while ({\")\n  136:         emitBlock(c)\n  137:         stream.print(quote(getBlockResult(c)))\n  138          stream.println(\"}) {\")\n  139:         emitBlock(b)\n  140:         stream.println(quote(getBlockResult(b)))\n  141          stream.print(\"}\")\n  142        }\n  ...\n  148        withStream(localStream) {\n  149          stream.print(\"do {\")\n  150:         emitBlock(b)\n  151:         stream.println(quote(getBlockResult(b)))\n  152          stream.println(\"} while ({\")\n  153:         emitBlock(c)\n  154:         stream.print(quote(getBlockResult(c)))\n  155          stream.print(\"})\")\n  156        }\n  ...\n  172      case While(c,b) =>\n  173        stream.println(\"for (;;) {\")\n  174:       emitBlock(c)\n  175:       stream.println(\"if (!\"+quote(getBlockResult(c))+\") break;\")\n  176:       emitBlock(b)\n  177        stream.println(\"}\")\n  178      case DoWhile(b, c) =>\n  179        stream.println(\"{\")\n  180:       emitBlock(b)\n  181        stream.println(\"}\")\n  182        stream.println(\"for (;;) {\")\n  183:       emitBlock(c)\n  184:       stream.println(\"if (!\"+quote(getBlockResult(c))+\") break;\")\n  185:       emitBlock(b)\n  186        stream.println(\"}\")\n  187      case _ => super.emitNode(sym, rhs)\n\n/home/gabriel/workspace/lms/src/internal/BlockTraversal.scala:\n    6  \n    7  \n    8: trait BlockTraversal extends GraphTraversal {\n    9    val IR: Expressions\n   10    import IR._\n   11  \n   12:   type Block[+T]\n   13    \n   14:   def reifyBlock[T: Manifest](x: => Exp[T]): Block[T]\n   15  \n   16:   def compactize(start: Block[Any], local: List[Sym[Any]]): List[Sym[Any]] = { throw new Exception(\"Method compactize should be overriden.\") }\n   17  \n   18:   def getFreeVarBlock(start: Block[Any], local: List[Sym[Any]]): List[Sym[Any]] = Nil\n   19  \n   20:   def getFreeDataBlock[A](start: Block[A]): List[(Sym[Any],Any)] = Nil // TODO: Nil or Exception??\n   21  \n   22:   def getBlockResult[A](s: Block[A]): Exp[A] = getBlockResultFull(s) // = s.res\n   23:   def getBlockResultFull[A](s: Block[A]): Exp[A] // = s.res\n   24    \n   25:   def traverseBlock[A](block: Block[A]): Unit\n   26    def traverseStm(stm: Stm): Unit\n   27    \n   ..\n   32  \n   33  \n   34: trait NestedBlockTraversal extends BlockTraversal with NestedGraphTraversal {\n   35    val IR: Expressions with Effects\n   36    import IR._\n   37  \n   38:   // ----- block definition\n   39  \n   40:   type Block[+T] = IR.Block[T]\n   41:   def reifyBlock[T: Manifest](x: => Exp[T]): Block[T] = IR.reifyEffects(x)\n   42  \n   43:   override def getBlockResultFull[A](s: Block[A]): Exp[A] = s.res\n   44    \n   45:   override def getBlockResult[A](s: Block[A]): Exp[A] = s match {\n   46:     case Block(Def(Reify(x, _, _))) => x\n   47:     case Block(x) => x\n   48    }\n   49  \n   50    \n   51:   def focusBlock[A](result: Block[Any])(body: => A): A = \n   52:     focusFatBlock(List(result))(body)\n   53      \n   54:   def focusFatBlock[A](result: List[Block[Any]])(body: => A): A = \n   55:     focusSubGraph[A](result.map(getBlockResultFull))(body)\n   56  \n   57  \n   58:   def focusExactScope[A](resultB: Block[Any])(body: List[Stm] => A): A = \n   59      focusExactScopeFat(List(resultB))(body)\n   60    \n   61:   def focusExactScopeFat[A](resultB: List[Block[Any]])(body: List[Stm] => A): A = \n   62:     focusExactScopeSubGraph[A](resultB.map(getBlockResultFull))(body)\n   63    \n   64    // ---- bound and free vars\n   ..\n   90  \n   91    // TODO: remove\n   92:   override def getFreeVarBlock(start: Block[Any], local: List[Sym[Any]]): List[Sym[Any]] = {\n   93:     focusBlock(start) {\n   94:       freeInScope(local, List(getBlockResultFull(start)))\n   95      }\n   96    }\n   97  \n   98:   override def getFreeDataBlock[A](start: Block[A]): List[(Sym[Any],Any)] = Nil // FIXME: should have generic impl\n   99  \n  100  \n  ...\n  102    // ----- high level api\n  103  \n  104:   def traverseBlock[A](block: Block[A]): Unit = {\n  105:     focusBlock(block) {\n  106:       traverseBlockFocused(block)\n  107      }\n  108    }\n  109  \n  110:   def traverseBlockFocused[A](block: Block[A]): Unit = {\n  111:     focusExactScope(block) { levelScope =>\n  112:       traverseStmsInBlock(levelScope)\n  113      }\n  114    }\n  115  \n  116:   def traverseStmsInBlock[A](stms: List[Stm]): Unit = {\n  117      stms foreach traverseStm\n  118    }\n  119  \n  120    def traverseStm(stm: Stm): Unit = { // override this to implement custom traversal\n  121:     blocks(stm.rhs) foreach traverseBlock\n  122    }\n  123  \n\n/home/gabriel/workspace/lms/src/internal/CCodegen.scala:\n  121    }\n  122   \n  123:   def emitSource[A:Manifest](args: List[Sym[_]], body: Block[A], functionName: String, out: PrintWriter, dynamicReturnType: String = null, serializable: Boolean = false) = {\n  124  \n  125      val sA = if (dynamicReturnType != null) dynamicReturnType else remap(manifest[A])\n  ...\n  140        tempWriter.println(sA+\" \"+functionName+\"(\"+args.map(a => remap(a.tp)+\" \"+quote(a)).mkString(\", \")+\") {\")\n  141        withStream(tempWriter) { \n  142: 	  	emitBlock(body) \n  143  	  }\n  144: 	  val y = getBlockResult(body)\n  145        if (remap(y.tp) != \"void\")\n  146          tempWriter.println(\"return \" + quote(y) + \";\")\n\n/home/gabriel/workspace/lms/src/internal/CLikeCodegen.scala:\n   79    import IR._\n   80  \n   81:   def emitMultiLoopCond(sym: Sym[Any], funcs:List[Block[Any]], idx: Sym[Int], postfix: String=\"\", stream:PrintWriter):(String,List[Exp[Any]])\n   82  \n   83  }\n\n/home/gabriel/workspace/lms/src/internal/CudaCodegen.scala:\n  126    }\n  127  \n  128:   def emitSource[A : Manifest](args: List[Sym[_]], body: Block[A], className: String, out: PrintWriter) = {\n  129  \n  130      val sB = remap(manifest[A])\n  ...\n  140        stream.println(\"int main(int argc, char** argv) {\")\n  141  \n  142:       emitBlock(body)\n  143:       //stream.println(quote(getBlockResult(y)))\n  144  \n  145        stream.println(\"}\")\n  ...\n  200    import IR._\n  201  \n  202:   def emitMultiLoopCond(sym: Sym[Any], funcs:List[Block[Any]], idx: Sym[Int], postfix: String=\"\", stream:PrintWriter):(String,List[Exp[Any]]) = {\n  203      isNestedNode = true\n  204      devFuncIdx += 1\n  ...\n  212      tabWidth = 1\n  213      withStream(tempStream) {\n  214:       emitFatBlock(funcs)\n  215      }\n  216      tabWidth = currentTab\n  217  \n  218:     val inputs = getFreeVarBlock(Block(Combine(funcs.map(getBlockResultFull))),Nil).filterNot(quote(_)==quote(idx)).distinct\n  219      val paramStr = (inputs++List(idx)).map(ele=>remap(ele.tp)+\" \"+quote(ele)).mkString(\",\")\n  220      header.append(devFuncPrefix + \" bool dev_%s(%s) {\\n\".format(postfix,paramStr))\n  221:     footer.append(\"\\treturn %s;\\n\".format(funcs.map(f=>quote(getBlockResult(f))).mkString(\"&&\")))\n  222      footer.append(\"}\\n\")\n  223      stream.print(header)\n\n/home/gabriel/workspace/lms/src/internal/Effects.scala:\n    7  import scala.annotation.unchecked.uncheckedVariance\n    8  \n    9: trait Blocks extends Expressions {\n   10  \n   11:   case class Block[+T](val res: Exp[T]) { def tp: Manifest[T @uncheckedVariance] = res.tp } // variance ...\n   12  \n   13:   def blocks(e: Any): List[Block[Any]] = e match {\n   14:     case b: Block[Any] => List(b)\n   15:     case p: Product => p.productIterator.toList.flatMap(blocks(_))\n   16      case _ => Nil\n   17    }\n   ..\n   20  \n   21  \n   22: trait Effects extends Expressions with Blocks with Utils {\n   23  \n   24    // TODO: transform over Summary currently lives in common/Base.scala. move it here?\n   ..\n   33    //captures side-effectful statements in the context\n   34    case class Reflect[+A](x:Def[A], summary: Summary, deps: List[Exp[Any]]) extends Def[A]\n   35:   //opens a context (a block)\n   36    case class Reify[A](x: Exp[A], summary: Summary, effects: List[Exp[Any]]) extends Def[A]\n   37  \n   ..\n  107  \n  108  \n  109:   def summarizeEffects(e: Block[Any]) = e match {\n  110:     case Block(Def(Reify(_,u,_))) => u\n  111  //    case Def(Reflect(_,u,_)) => u\n  112      case _ => Pure()\n  ...\n  140      case Reflect(x, u, es) => readSyms(x) // ignore effect deps (they are not read!)\n  141      case Reify(x, u, es) =>\n  142:       // in general: the result of a block is not read but passed through.\n  143        // FIXME this piece of logic is not clear. is it a special case for unit??\n  144        // it looks like this was introduced to prevent the Reify to be reflected\n  145:       // if x is a mutable object defined within the block.\n  146        // TODO the globalMutableSyms part was added later (June 2012) -- make sure it does the right thing\n  147        if ((es contains x) || (globalMutableSyms contains x)) Nil\n  ...\n  577    def checkContext() {\n  578      if (context == null)\n  579:       sys.error(\"uninitialized effect context: effectful statements may only be used within a reifyEffects { .. } block\")\n  580    }\n  581  \n  ...\n  585    def summarizeAll(es: List[Exp[Any]]): Summary = {\n  586      // compute an *external* summary for a seq of nodes\n  587:     // don't report any reads/writes on data allocated within the block\n  588      var u = Pure()\n  589      var ux = u\n  ...\n  602    def pruneContext(ctx: List[Exp[Any]]): List[Exp[Any]] = ctx // TODO this doesn't work yet (because of loops!): filterNot { case Def(Reflect(_,u,_)) => mustOnlyRead(u) }\n  603  \n  604:   // reify the effects of an isolated block.\n  605    // no assumptions about the current context remain valid.\n  606:   def reifyEffects[A:Manifest](block: => Exp[A]): Block[A] = {\n  607      val save = context\n  608      context = Nil\n  609  \n  610:     val (result, defs) = reifySubGraph(block)\n  611      reflectSubGraph(defs)\n  612  \n  ...\n  615      context = save\n  616  \n  617:     if (deps.isEmpty && mustPure(summary)) Block(result) else Block(Reify(result, summary, pruneContext(deps))) // calls toAtom...\n  618    }\n  619  \n  620:   // reify the effects of a block that is executed 'here' (if it is executed at all).\n  621    // all assumptions about the current context carry over unchanged.\n  622:   def reifyEffectsHere[A:Manifest](block: => Exp[A]): Block[A] = {\n  623      val save = context\n  624      if (save eq null)\n  625        context = Nil\n  626  \n  627:     val (result, defs) = reifySubGraph(block)\n  628      reflectSubGraph(defs)\n  629  \n  ...\n  636      context = save\n  637  \n  638:     if (deps.isEmpty && mustPure(summary)) Block(result) else Block(Reify(result, summary, pruneContext(deps))) // calls toAtom...\n  639    }\n  640  \n\n/home/gabriel/workspace/lms/src/internal/ExtendedExpressions.scala:\n    8  \n    9  \n   10: trait ExtendedExpressions extends Expressions with Blocks {\n   11    val RefCountAttributeKey = \"refCnt\"\n   12:   val ParentBlockAttributeKey = \"pBlk\"\n   13  \n   14    def infix_refCount(s: Sym[Any]): Int = {\n   ..\n   24    }\n   25  \n   26:   def infix_parentBlock(s: Sym[Any]): Option[Block[Any]] = {\n   27:     s.attributes.get(ParentBlockAttributeKey).asInstanceOf[Option[Block[Any]]]\n   28    }\n   29  \n   30:   def infix_setParentBlock(s: Sym[Any], pBlk: Option[Block[Any]]): Unit = pBlk match {\n   31:     case Some(blk) => s.attributes.update(ParentBlockAttributeKey, blk)\n   32      case None =>\n   33    }\n   34  \n   35:   def infix_inSameParentBlockAs(thiz: Sym[Any], other: Sym[Any]): Boolean = {\n   36:     val thizParent: Option[Block[Any]] = thiz.attributes.get(ParentBlockAttributeKey).asInstanceOf[Option[Block[Any]]]\n   37:     val otherParent: Option[Block[Any]] = other.attributes.get(ParentBlockAttributeKey).asInstanceOf[Option[Block[Any]]]\n   38      thizParent match {\n   39        case Some(thizP) => otherParent match {\n\n/home/gabriel/workspace/lms/src/internal/FatCodegen.scala:\n    5  import java.io.{File, PrintWriter}\n    6  \n    7: trait GenericFatCodegen extends GenericNestedCodegen with FatBlockTraversal {\n    8    val IR: Expressions with Effects with FatExpressions\n    9    import IR._  \n   ..\n   28    def emitNodeKernelExtra(sym: List[Sym[Any]], rhs: Def[Any]): Unit = { }\n   29  \n   30:   def emitFatBlock(rhs: List[Block[Any]]): Unit = {\n   31:     emitBlock(Block(Combine(rhs.map(getBlockResultFull)))) // TODO: find another way\n   32    }\n   33  \n\n/home/gabriel/workspace/lms/src/internal/FatExpressions.scala:\n   32  \n   33  \n   34:   case class Combine(a: List[Exp[Any]]) extends Exp[Any] //TODO: get rid of. used by emitFatBlock\n   35  \n   36    case class Forward[A](x: Exp[A]) extends Def[A] // TODO: get rid of. used by SimplifyTransform\n\n/home/gabriel/workspace/lms/src/internal/FatTraversal.scala:\n    6  \n    7  \n    8: trait FatBlockTraversal extends NestedBlockTraversal with FatScheduling {\n    9    val IR: Expressions with Effects with FatExpressions\n   10    import IR._  \n   ..\n   12  \n   13  \n   14:   override def focusFatBlock[A](result: List[Block[Any]])(body: => A): A = {\n   15:     super.focusFatBlock(result) {\n   16        innerScope = fattenAll(innerScope)\n   17        body\n\n/home/gabriel/workspace/lms/src/internal/GPUCodegen.scala:\n  126    var isNestedNode: Boolean = false\n  127  \n  128:   def emitMultiLoopFunc(func:Block[Any], postfix: String, lastInputs: List[Sym[Any]], stream:PrintWriter): List[String] = {\n  129      isNestedNode = true\n  130      val tempString = new StringWriter\n  ...\n  136      tabWidth = 1\n  137      withStream(tempStream) {\n  138:       emitBlock(func)\n  139      }\n  140      tabWidth = currentTab\n  141  \n  142:     val inputs = getFreeVarBlock(func,lastInputs).distinct\n  143      val paramStr = (inputs++lastInputs).map(ele=>remap(ele.tp)+\" \"+quote(ele)).mkString(\",\")\n  144  \n  145:     header.append(devFuncPrefix + \" %s dev_%s(%s) {\\n\".format(remap(getBlockResult(func).tp),postfix,paramStr))\n  146:     if(remap(getBlockResult(func).tp) != \"void\")\n  147:       footer.append(\"\\treturn %s;\\n\".format(quote(getBlockResult(func))))\n  148      footer.append(\"}\\n\")\n  149      stream.print(header)\n  ...\n  464         and copying  it to CPU memory with allocation of new object in CPU */\n  465    //TODO: Separate output and temporary allocations\n  466:   def emitAllocFunc(sym:Sym[Any], allocFunc:Block[Any], aV:Sym[Any]=null, size:Exp[Any]=null) {\n  467      processingHelperFunc = true\n  468      val tempString = new StringWriter\n  ...\n  472      // Get free variables (exclude the arrayVariable)\n  473      val inputs = if(allocFunc==null) Nil\n  474:     else getFreeVarBlock(allocFunc,List(aV))\n  475  \n  476      // Register metadata\n  ...\n  482      if(allocFunc!=null) {\n  483        withStream(tempStream) {\n  484:         emitBlock(allocFunc)\n  485        }\n  486:       tempString.append(\"\\treturn %s_ptr;\\n\".format(quote(getBlockResult(allocFunc))))\n  487      }\n  488      else {\n\n/home/gabriel/workspace/lms/src/internal/GenericCodegen.scala:\n    7  import scala.collection.mutable.{Map => MMap}\n    8  \n    9: trait GenericCodegen extends BlockTraversal {\n   10    val IR: Expressions\n   11    import IR._\n   ..\n   30    val staticFields: collection.mutable.Map[String, String] = new collection.mutable.HashMap[String, String]()\n   31    \n   32:   def performTransformations[A:Manifest](body: Block[A]): Block[A] = {\n   33      var transformedBody = body\n   34      transformers foreach { trans =>\n   35:       transformedBody = trans.apply[A](body.asInstanceOf[trans.IR.Block[A]]).asInstanceOf[this.Block[A]]\n   36      }\n   37      transformedBody\n   ..\n  121    }\n  122      \n  123:   def emitBlock(y: Block[Any]): Unit = traverseBlock(y)\n  124  \n  125:   def emitBlockResult[A: Manifest](b: Block[A]) {	\n  126:       if (remap(manifest[A]) != \"Unit\") stream.println(quote(getBlockResult(b)))\n  127    }\n  128      \n  ...\n  134    \n  135    def emitSource0[R : Manifest](f: () => Exp[R], className: String, stream: PrintWriter, dynamicReturnType: String = null): List[(Sym[Any], Any)] = {\n  136:     val body = reifyBlock(f())\n  137      emitSource(List(), body, className, stream, dynamicReturnType)\n  138    }\n  ...\n  140    def emitSource1[T1: Manifest, R : Manifest](f: (Exp[T1]) => Exp[R], className: String, stream: PrintWriter): List[(Sym[Any], Any)] = {\n  141      val s1 = fresh[T1]\n  142:     val body = reifyBlock(f(s1))\n  143      emitSource(List(s1), body, className, stream)\n  144    }\n  ...\n  147      val s1 = fresh[T1]\n  148      val s2 = fresh[T2]\n  149:     val body = reifyBlock(f(s1, s2))\n  150      emitSource(List(s1, s2), body, className, stream, dynamicReturnType)\n  151    }\n  ...\n  155      val s2 = fresh[T2]\n  156      val s3 = fresh[T3]\n  157:     val body = reifyBlock(f(s1, s2, s3))\n  158      emitSource(List(s1, s2, s3), body, className, stream)\n  159    }\n  ...\n  164      val s3 = fresh[T3]\n  165      val s4 = fresh[T4]\n  166:     val body = reifyBlock(f(s1, s2, s3, s4))\n  167      emitSource(List(s1, s2, s3, s4), body, className, stream)\n  168    }\n  ...\n  174      val s4 = fresh[T4]\n  175      val s5 = fresh[T5]\n  176:     val body = reifyBlock(f(s1, s2, s3, s4, s5))\n  177      emitSource(List(s1, s2, s3, s4, s5), body, className, stream)\n  178    }\n  ...\n  185      val s5 = fresh[T5]\n  186      val s6 = fresh[T6]\n  187:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6))\n  188      emitSource(List(s1, s2, s3, s4, s5, s6), body, className, stream)\n  189    }\n  ...\n  196      val s6 = fresh[T6]\n  197      val s7 = fresh[T7]\n  198:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7))\n  199      emitSource(List(s1, s2, s3, s4, s5, s6, s7), body, className, stream)\n  200    }\n  ...\n  208      val s7 = fresh[T7]\n  209      val s8 = fresh[T8]\n  210:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8))\n  211      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8), body, className, stream)\n  212    }\n  ...\n  221      val s8 = fresh[T8]\n  222      val s9 = fresh[T9]\n  223:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9))\n  224      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9), body, className, stream)\n  225    }\n  ...\n  235      val s9 = fresh[T9]\n  236      val s10 = fresh[T10]\n  237:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10))\n  238      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10), body, className, stream)\n  239    }\n  ...\n  250      val s10 = fresh[T10]\n  251      val s11 = fresh[T11]\n  252:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11))\n  253      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11), body, className, stream)\n  254    }\n  ...\n  266      val s11 = fresh[T11]\n  267      val s12 = fresh[T12]\n  268:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12))\n  269      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12), body, className, stream)\n  270    }\n  ...\n  283      val s12 = fresh[T12]\n  284      val s13 = fresh[T13]\n  285:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13))\n  286      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13), body, className, stream)\n  287    }\n  ...\n  301      val s13 = fresh[T13]\n  302      val s14 = fresh[T14]\n  303:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14))\n  304      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14), body, className, stream)\n  305    }\n  ...\n  320      val s14 = fresh[T14]\n  321      val s15 = fresh[T15]\n  322:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15))\n  323      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15), body, className, stream)\n  324    }\n  ...\n  340      val s15 = fresh[T15]\n  341      val s16 = fresh[T16]\n  342:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16))\n  343      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16), body, className, stream)\n  344    }\n  ...\n  361      val s16 = fresh[T16]\n  362      val s17 = fresh[T17]\n  363:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17))\n  364      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17), body, className, stream)\n  365    }\n  ...\n  383      val s17 = fresh[T17]\n  384      val s18 = fresh[T18]\n  385:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18))\n  386      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18), body, className, stream)\n  387    }\n  ...\n  406      val s18 = fresh[T18]\n  407      val s19 = fresh[T19]\n  408:     val body = reifyBlock(f(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19))\n  409      emitSource(List(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19), body, className, stream)\n  410    }\n  ...\n  412    /**\n  413     * @param args List of symbols bound to `body`\n  414:    * @param body Block to emit\n  415     * @param className Name of the generated identifier\n  416     * @param stream Output stream\n  417     */\n  418:   def emitSource[A : Manifest](args: List[Sym[_]], body: Block[A], className: String, stream: PrintWriter, dynamicReturnType: String = null, serializable: Boolean = false): List[(Sym[Any], Any)] // return free static data in block\n  419  \n  420    def quote(x: Exp[Any]) : String = quote(x, false)\n  ...\n  494  \n  495  \n  496: trait GenericNestedCodegen extends NestedBlockTraversal with GenericCodegen {\n  497    val IR: Expressions with Effects\n  498    import IR._\n  ...\n  506        emitNode(sym, s)\n  507      case Reify(s, u, effects) =>\n  508:       // just ignore -- effects are accounted for in emitBlock\n  509      case _ => super.emitNode(sym, rhs)\n  510    }\n  511  \n  512:   case class NestedBlock(b: Block[Any])\n  513:   def nestedBlock(b: Block[Any]) = NestedBlock(b)\n  514  \n  515:   // Allows the gen string interpolator to perform emitBlock when passed a Block\n  516    implicit class NestedCodegenHelper(sc: StringContext) extends CodegenHelper(sc) {\n  517  \n  518      override def printToStream(arg: Any): Unit = arg match {\n  519:       case NestedBlock(b) => emitBlock(b)\n  520:       case b: Block[_] => stream.print(quoteOrRemap(getBlockResult(b)))\n  521        case _ => stream.print(quoteOrRemap(arg))\n  522      }\n\n/home/gabriel/workspace/lms/src/internal/GraphVizDependencyGraphExport.scala:\n   12   * ScalaCodegen or etc.\n   13   */\n   14: trait GraphVizDependencyGraphExport extends GenericCodegen with NestedBlockTraversal { self =>\n   15    val IR: ExtendedExpressions with Effects\n   16    import IR._\n   ..\n   46      if(rhs != null) {\n   47        ReflectionUtil.caseNameTypeValues(rhs) foreach {\n   48:         x => if(x._2 == classOf[Block[A]]) {\n   49:           val blk: Block[A] = x._3.asInstanceOf[Block[A]]\n   50            focusExactScope(blk) { levelScope =>\n   51              val clusterName: String = findSymString(blk.res, levelScope)\n   ..\n   57              }\n   58            }\n   59:           emitBlock(blk)\n   60          } else if(x._2 == classOf[Exp[A]]) {\n   61            x._3 match {\n   ..\n   81    }\n   82  \n   83:   override def emitSource[A : Manifest](args: List[Sym[_]], body: Block[A], className: String, out: PrintWriter, dynamicReturnType: String = null, serializable: Boolean = false) = {\n   84  \n   85      val sA = remap(manifest[A])\n   86  \n   87      // TODO - reflect this static data with some (if any exists) representation in the graph\n   88:     val staticData = getFreeDataBlock(body)\n   89  \n   90      withStream(out) {\n   ..\n  100  \n  101        stream.println(args.map( a => getGraphNodeString(a, GraphNodeKindInput, null)).mkString(\"\\n\"))\n  102:       emitBlock(transformedBody)\n  103:       val res = quote(getBlockResult(transformedBody))\n  104        if(res != \"()\" && res.isInstanceOf[Sym[_]]) {\n  105          stream.print(\"\\n\" + getGraphNodeString(res.asInstanceOf[Sym[_]], GraphNodeKindOutput, null))\n  ...\n  116    }\n  117  \n  118:   override def traverseBlockFocused[A](block: Block[A]): Unit = {\n  119:     focusExactScope(block) { levelScope =>\n  120:       val clusterName: String = findSymString(block.res, levelScope)\n  121  \n  122        val indentation = indentString(levelCounter)\n  ...\n  126          stream.println(indentation+\"subgraph cluster_\" + clusterName + \" {\")\n  127        }\n  128:       traverseStmsInBlock(levelScope)\n  129        if(clusterName != \"\") {\n  130          stream.println(\"\\n\"+indentationPlus1+\"label = \\\"\" + clusterName + \"\\\";\")\n  ...\n  136    }\n  137  \n  138:   override def traverseStmsInBlock[A](stms: List[Stm]): Unit = {\n  139      levelCounter+=1\n  140      stms foreach traverseStm\n  ...\n  145      case TP(sym, rhs) => rhs match {\n  146        case Reflect(s, u, effects) => stream.println(getGraphNodeString(sym, s+\"\", s))\n  147:       case Reify(s, u, effects) => // just ignore -- effects are accounted for in emitBlock\n  148        case _ => stream.println(getGraphNodeString(sym, rhs+\"\", rhs))\n  149      }\n  ...\n  152  \n  153    /**\n  154:    * This method produces the symbol name for a block, given:\n  155:    *  - an Exp for block result\n  156:    *  - list of statements in block\n  157     * returns:\n  158:    *  - in the case that block result is a symbol => symbol name\n  159:    *  - in the case that block result is a constant =>\n  160     *    first symbol name in the statements list\n  161     */\n  ...\n  195    def emitValDef(sym: Sym[Any], rhs: String): Unit = {}\n  196  \n  197:   override def performTransformations[A:Manifest](body: Block[A]): Block[A] = {\n  198      val transformedBody = super.performTransformations[A](body)\n  199      val fixer = new SymMetaDataFixerTransform{ val IR: self.IR.type = self.IR }\n  200:     fixer.traverseBlock(transformedBody.asInstanceOf[fixer.Block[A]])\n  201      transformedBody\n  202    }\n\n/home/gabriel/workspace/lms/src/internal/OpenCLCodegen.scala:\n  163    }\n  164  \n  165:   def emitSource[A : Manifest](args: List[Sym[_]], body: Block[A], className: String, out: PrintWriter) = {\n  166      val sB = manifest[A].toString\n  167  \n  ...\n  176        stream.println(\"int main(int argc, char** argv) {\")\n  177  \n  178:       emitBlock(body)\n  179:       //stream.println(quote(getBlockResult(y)))\n  180  \n  181        stream.println(\"}\")\n  ...\n  228    import IR._\n  229    \n  230:   def emitMultiLoopCond(sym: Sym[Any], funcs:List[Block[Any]], idx: Sym[Int], postfix: String=\"\", stream:PrintWriter):(String,List[Exp[Any]]) = {\n  231      isNestedNode = true\n  232      devFuncIdx += 1\n  ...\n  240      tabWidth = 1\n  241      withStream(tempStream) {\n  242:       emitFatBlock(funcs)\n  243      }\n  244      tabWidth = currentTab\n  245  \n  246:     val inputs = getFreeVarBlock(Block(Combine(funcs.map(getBlockResultFull))),Nil).filterNot(quote(_)==quote(idx)).distinct\n  247      val paramStr = (inputs++List(idx)).map(ele=>remap(ele.tp)+\" \"+quote(ele)).mkString(\",\")\n  248      header.append(\"bool dev_%s(%s) {\\n\".format(postfix,paramStr))\n  249:     footer.append(\"\\treturn %s;\\n\".format(funcs.map(f=>quote(getBlockResult(f))).mkString(\"&&\")))\n  250      footer.append(\"}\\n\")\n  251      stream.print(header)\n\n/home/gabriel/workspace/lms/src/internal/ScalaCodegen.scala:\n   20    }\n   21  \n   22:   def emitSource[A : Manifest](args: List[Sym[_]], body: Block[A], className: String, out: PrintWriter, dynamicReturnType: String = null, serializable: Boolean = false) = {\n   23  \n   24      val sA = if (dynamicReturnType != null) dynamicReturnType else remap(manifest[A])\n   25:     val staticData = getFreeDataBlock(body)\n   26  \n   27      withStream(out) {\n   ..\n   37        if (serializable) stream.println(\"with Serializable {\") else stream.println(\" {\")\n   38        stream.println(\"def apply(\"+args.map(a => quote(a, true) + \":\" + remap(a.tp)).mkString(\", \")+\"): \"+sA+\" = {\")\n   39:       emitBlock(transformedBody)\n   40:       if (sA != \"Unit\") stream.println(quote(getBlockResult(transformedBody)))\n   41        stream.println(\"}\")\n   42        staticFields.map { case (key, staticFldDef) =>\n   ..\n  114  \n  115    // emit forward decls for recursive vals\n  116:   override def traverseStmsInBlock[A](stms: List[Stm]): Unit = {\n  117      recursive foreach emitForwardDef\n  118:     super.traverseStmsInBlock(stms)\n  119    }\n  120  \n\n/home/gabriel/workspace/lms/src/internal/ScalaConciseCodegen.scala:\n   94    }\n   95  \n   96:   override def performTransformations[A:Manifest](body: Block[A]): Block[A] = {\n   97      val transformedBody = super.performTransformations[A](body)\n   98      val fixer = new SymMetaDataFixerTransform{ val IR: self.IR.type = self.IR }\n   99:     fixer.traverseBlock(transformedBody.asInstanceOf[fixer.Block[A]])\n  100      transformedBody\n  101    }\n\n/home/gabriel/workspace/lms/src/internal/SymMetaDataFixerTransform.scala:\n    7   * There are some meta-data added to Sym using infix\n    8   * operations in ExtendedExpressions.\n    9:  * This trait fixes this properties, e.g parentBlock\n   10   * and refCount.\n   11   *\n   ..\n   13   * traversal over Exp graph.\n   14   */\n   15: trait SymMetaDataFixerTransform extends NestedBlockTraversal {\n   16    val IR: ExtendedExpressions with Effects\n   17    import IR._\n   18  \n   19:   override def traverseBlockFocused[A](block: Block[A]): Unit = {\n   20:     focusExactScope(block) { levelScope =>\n   21        levelScope foreach { stm => stm match {\n   22:           case TP(sym, rhs) => sym.setParentBlock(Some(block))\n   23            case _ => \n   24          }\n   25        }\n   26  \n   27:       traverseStmsInBlock(levelScope)\n   28      }\n   29    }\n   ..\n   42            }\n   43            case Reify(s, u, effects) => {\n   44:             sym.incRefCount(-1000) // just ignore -- effects are accounted for in emitBlock\n   45              s match {\n   46                case s@Sym(n) => s.incRefCount(1)\n   ..\n   53        case _ =>\n   54      } \n   55:     blocks(stm.rhs) foreach traverseBlock\n   56    }\n   57  \n   ..\n   59      val sym = s.asInstanceOf[Sym[Any]]\n   60      ReflectionUtil.caseNameTypeValues(rhs) foreach {\n   61:       x => if(x._2 == classOf[Block[A]]) {\n   62:         val blk: Block[A] = x._3.asInstanceOf[Block[A]]\n   63          blk.res match {\n   64:           case s:Sym[_] => if(s.inSameParentBlockAs(sym)) { s.incRefCount(1) } else { s.incRefCount(10) }\n   65            case _ =>\n   66          }\n   67:         //transformBlock[Any](blk)\n   68        } else if(x._2 == classOf[Exp[A]]) {\n   69          x._3 match {\n   70:           case s:Sym[_] => if(s.inSameParentBlockAs(sym)) { s.incRefCount(1) } else { s.incRefCount(10) }\n   71            case _ =>\n   72          }\n   ..\n   74  		if (x._3 != null) {\n   75  	        x._3.asInstanceOf[Variable[A]].e match {\n   76:     	      case s:Sym[_] => if(s.inSameParentBlockAs(sym)) { s.incRefCount(1) } else { s.incRefCount(10) }\n   77          	  case _ =>\n   78          	}\n   ..\n   80        } else {\n   81          syms(x._3).foreach {\n   82:           s: Sym[Any] => if(s.inSameParentBlockAs(sym)) { s.incRefCount(1) } else { s.incRefCount(10) }\n   83          }\n   84        }\n\n/home/gabriel/workspace/lms/src/internal/Transforming.scala:\n    7  \n    8  trait AbstractTransformer {\n    9:   val IR: Expressions with Blocks with OverloadHack\n   10    import IR._\n   11  \n   12    def hasContext = false\n   13:   def reflectBlock[A](xs: Block[A]): Exp[A] = sys.error(\"reflectBlock not supported by context-free transformers\")\n   14  \n   15    def apply[A](x: Exp[A]): Exp[A]\n   16:   def apply[A:Manifest](xs: Block[A]): Block[A] = {\n   17      // should be overridden by transformers with context\n   18      assert(!hasContext)\n   19:     Block(apply(xs.res))\n   20    }\n   21    def apply[A](xs: List[Exp[A]]): List[Exp[A]] = xs map (e => apply(e))\n   ..\n   32    var subst = immutable.Map.empty[Exp[Any], Exp[Any]]\n   33  \n   34:   def withSubstScope[A](extend: (Exp[Any],Exp[Any])*)(block: => A): A =\n   35      withSubstScope {\n   36        subst ++= extend\n   37:       block\n   38      }\n   39  \n   40:   def withSubstScope[A](block: => A): A = {\n   41      val save = subst\n   42:     val r = block\n   43      subst = save\n   44      r\n   ..\n   52  \n   53  \n   54: trait Transforming extends Expressions with Blocks with OverloadHack {\n   55    self =>\n   56  \n\n/home/gabriel/workspace/lms/src/internal/Traversal.scala:\n  131          }\n  132          \n  133:         // also remove direct inner deps (without inner stms): x1 = Lambda { x2 => Block(x3) }\n  134          (level intersect xs) foreach {\n  135:           case stm if allSyms(blocks(stm.rhs)) exists (fs contains _) => \n  136              fixed(stm.rhs) = allSyms(stm.rhs) filterNot (fs contains _)\n  137              printdbg(\"fixing deps of \" + stm.rhs + \" to \" + fixed(stm.rhs))\n\n/home/gabriel/workspace/lms/src/util/Timing.scala:\n   10  \n   11  trait TimingExp extends BaseExp with EffectExp {\n   12:   case class TimeGeneratedCode[A: Manifest](start: Exp[Long], end: Exp[Long], f: Block[A], msg: Rep[String] = unit(\"\")) extends Def[A]\n   13  \n   14    def timeGeneratedCode[A: Manifest](f: => Rep[A], msg: Rep[String] = unit(\"\")) = {\n   ..\n   44          stream.println(\"val \" + quote(start) + \" = System.nanoTime\")\n   45          stream.print(\"val \" + quote(sym) + \" = { \")\n   46:         emitBlock(f)\n   47:         stream.println(quote(getBlockResult(f)))\n   48          stream.println(\"}\")\n   49          stream.println(\"val \" + quote(end) + \" = System.nanoTime\")\n\n726 matches across 46 files\n",
			"settings":
			{
				"buffer_size": 103166,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "src/common/Base.scala",
			"settings":
			{
				"buffer_size": 3417,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/Structs.scala",
			"settings":
			{
				"buffer_size": 17319,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/ArrayOps.scala",
			"settings":
			{
				"buffer_size": 18471,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/internal/Expressions.scala",
			"settings":
			{
				"buffer_size": 12343,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/common/While.scala",
			"settings":
			{
				"buffer_size": 6465,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"console":
	{
		"height": 0.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/home/gabriel/workspace/lms/src/internal/ScalaCodegen.scala",
		"/home/gabriel/workspace/lms/src/common/NumericOps.scala",
		"/home/gabriel/workspace/lms/src/common/CastingOps.scala",
		"/home/gabriel/workspace/lms/src/common/OrderingOps.scala",
		"/home/gabriel/workspace/lms/src/internal/FatExpressions.scala",
		"/home/gabriel/workspace/lms/test-src/epfl/test10-transform/TestMiscTransform.scala",
		"/home/gabriel/workspace/lms/src/internal/CodeMotion.scala",
		"/home/gabriel/workspace/lms/src/internal/SymMetaDataFixerTransform.scala",
		"/home/gabriel/workspace/lms/src/internal/Transforming.scala",
		"/home/gabriel/workspace/lms/src/internal/Traversal.scala",
		"/home/gabriel/workspace/lms/src/internal/BlockTraversal.scala",
		"/home/gabriel/workspace/lms/src/common/HashMapOps.scala",
		"/home/gabriel/workspace/lms/src/internal/GenericCodegen.scala",
		"/home/gabriel/workspace/lms/src/internal/Utils.scala",
		"/home/gabriel/workspace/lms/test-src/epfl/test3-parsers/Effects.scala",
		"/home/gabriel/workspace/lms/src/common/ListBuffer.scala",
		"/home/gabriel/workspace/lms/src/common/LivenessOpt.scala",
		"/home/gabriel/workspace/lms/src/common/ListOps.scala",
		"/home/gabriel/workspace/lms/src/common/ArrayBufferOps.scala",
		"/home/gabriel/workspace/lms/test-src/epfl/test12-collections/TestArrayOps.scala",
		"/home/gabriel/workspace/lms/src/common/SetOps.scala",
		"/home/gabriel/workspace/lms/src/common/Structs.scala",
		"/home/gabriel/workspace/lms/src/common/TreeSet.scala",
		"/home/gabriel/workspace/lms/src/common/ArrayOps.scala",
		"/home/gabriel/workspace/lms/src/common/Variables.scala",
		"/home/gabriel/workspace/lms/src/common/PrimitiveOps.scala",
		"/home/gabriel/workspace/lms/src/common/HashCodeOps.scala",
		"/home/gabriel/workspace/lms/src/common/Equal.scala",
		"/home/gabriel/workspace/lms/src/common/BooleanOps.scala",
		"/home/gabriel/workspace/lms/src/internal/FatCodegen.scala",
		"/home/gabriel/workspace/lms/src/common/Packages.scala",
		"/home/gabriel/workspace/lms/test-src/epfl/test12-collections/TestList.scala",
		"/home/gabriel/workspace/lms/src/internal/Effects.scala",
		"/home/gabriel/workspace/lms/src/internal/FatTraversal.scala",
		"/home/gabriel/workspace/lms/src/internal/FatScheduling.scala",
		"/home/gabriel/workspace/lms/test-src/epfl/test7-analysis/TestDB.scalax",
		"/home/gabriel/workspace/lms/test-src/epfl/test12-collections/Entry.scala",
		"/home/gabriel/workspace/lms/src/common/StringOps.scala"
	],
	"find":
	{
		"height": 60.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			"/home/gabriel/workspace/lms/src",
			"/home/gabriel/workspace/lms/test-src/epfl"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"Block",
			"reif",
			"EffectExp",
			"readMutableData",
			"aliasSyms",
			"allAliasCache",
			"reflectMutableSym",
			"globalMutableSyms",
			"allAliasCache",
			"emitVarDef",
			"Variable",
			"var",
			"variable",
			"mustIdempotent",
			"Summary",
			"Reify",
			"ForwardTransformer",
			"sanity",
			"globalMutableSyms",
			"reflectMutableSym",
			"reifyef",
			"FatExpressions",
			"HashMapMAXIMUM_CAPACITY",
			"HashMapMAXIMUM",
			"createDefinition(",
			"Array[Entry[K,V]]"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"HashMap[K,V]"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "test-src/epfl/test12-collections/TestArrayOps.scala",
					"settings":
					{
						"buffer_size": 32057,
						"regions":
						{
						},
						"selection":
						[
							[
								18679,
								18679
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5850.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/common/Variables.scala",
					"settings":
					{
						"buffer_size": 14608,
						"regions":
						{
						},
						"selection":
						[
							[
								7039,
								7039
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 360.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/internal/Effects.scala",
					"settings":
					{
						"buffer_size": 26992,
						"regions":
						{
						},
						"selection":
						[
							[
								23494,
								23494
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7905.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"settings":
					{
						"buffer_size": 103166,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										131,
										140
									],
									[
										259,
										268
									],
									[
										448,
										457
									],
									[
										577,
										586
									],
									[
										714,
										723
									],
									[
										912,
										921
									],
									[
										1087,
										1096
									],
									[
										1171,
										1180
									],
									[
										1216,
										1225
									],
									[
										1316,
										1325
									],
									[
										1400,
										1409
									],
									[
										1445,
										1454
									],
									[
										1596,
										1605
									],
									[
										1717,
										1726
									],
									[
										1847,
										1856
									],
									[
										2110,
										2119
									],
									[
										2275,
										2284
									],
									[
										2485,
										2494
									],
									[
										2568,
										2577
									],
									[
										2724,
										2733
									],
									[
										2907,
										2916
									],
									[
										2936,
										2945
									],
									[
										3096,
										3105
									],
									[
										3510,
										3519
									],
									[
										3889,
										3898
									],
									[
										3914,
										3923
									],
									[
										3946,
										3955
									],
									[
										4366,
										4375
									],
									[
										4625,
										4634
									],
									[
										4888,
										4897
									],
									[
										5161,
										5170
									],
									[
										5474,
										5483
									],
									[
										5809,
										5818
									],
									[
										6088,
										6097
									],
									[
										6404,
										6413
									],
									[
										6721,
										6730
									],
									[
										6921,
										6930
									],
									[
										7320,
										7329
									],
									[
										7776,
										7785
									],
									[
										8028,
										8037
									],
									[
										8342,
										8351
									],
									[
										8554,
										8563
									],
									[
										8849,
										8858
									],
									[
										9205,
										9214
									],
									[
										9469,
										9478
									],
									[
										9663,
										9672
									],
									[
										9922,
										9931
									],
									[
										10184,
										10193
									],
									[
										10433,
										10442
									],
									[
										10725,
										10734
									],
									[
										11061,
										11070
									],
									[
										11264,
										11273
									],
									[
										11526,
										11535
									],
									[
										11778,
										11787
									],
									[
										12056,
										12065
									],
									[
										12276,
										12285
									],
									[
										12585,
										12594
									],
									[
										12746,
										12755
									],
									[
										13043,
										13052
									],
									[
										13511,
										13516
									],
									[
										13587,
										13592
									],
									[
										14033,
										14038
									],
									[
										14493,
										14498
									],
									[
										14500,
										14505
									],
									[
										14606,
										14611
									],
									[
										14613,
										14618
									],
									[
										14739,
										14744
									],
									[
										14746,
										14751
									],
									[
										15105,
										15110
									],
									[
										15112,
										15117
									],
									[
										15515,
										15520
									],
									[
										15647,
										15652
									],
									[
										15960,
										15965
									],
									[
										16115,
										16120
									],
									[
										16500,
										16505
									],
									[
										16615,
										16620
									],
									[
										16621,
										16626
									],
									[
										16649,
										16654
									],
									[
										16926,
										16931
									],
									[
										17158,
										17163
									],
									[
										17209,
										17214
									],
									[
										17421,
										17426
									],
									[
										17445,
										17450
									],
									[
										17663,
										17668
									],
									[
										17687,
										17692
									],
									[
										17920,
										17925
									],
									[
										18022,
										18027
									],
									[
										18078,
										18083
									],
									[
										18108,
										18113
									],
									[
										18164,
										18169
									],
									[
										18191,
										18196
									],
									[
										18231,
										18236
									],
									[
										18258,
										18263
									],
									[
										18269,
										18274
									],
									[
										18569,
										18574
									],
									[
										18785,
										18790
									],
									[
										18980,
										18985
									],
									[
										19052,
										19057
									],
									[
										19424,
										19429
									],
									[
										19564,
										19569
									],
									[
										19978,
										19983
									],
									[
										19985,
										19990
									],
									[
										20324,
										20329
									],
									[
										20628,
										20633
									],
									[
										20634,
										20639
									],
									[
										21001,
										21006
									],
									[
										21293,
										21298
									],
									[
										21299,
										21304
									],
									[
										21826,
										21831
									],
									[
										21839,
										21844
									],
									[
										21854,
										21859
									],
									[
										22223,
										22228
									],
									[
										22285,
										22290
									],
									[
										22576,
										22581
									],
									[
										22757,
										22762
									],
									[
										22948,
										22953
									],
									[
										23017,
										23022
									],
									[
										23348,
										23353
									],
									[
										23675,
										23680
									],
									[
										23832,
										23837
									],
									[
										23850,
										23855
									],
									[
										23857,
										23862
									],
									[
										23868,
										23873
									],
									[
										23927,
										23932
									],
									[
										23933,
										23938
									],
									[
										24064,
										24069
									],
									[
										24075,
										24080
									],
									[
										24095,
										24100
									],
									[
										24244,
										24249
									],
									[
										24253,
										24258
									],
									[
										24260,
										24265
									],
									[
										24331,
										24336
									],
									[
										24337,
										24342
									],
									[
										24366,
										24371
									],
									[
										24378,
										24383
									],
									[
										24512,
										24517
									],
									[
										24731,
										24736
									],
									[
										24795,
										24800
									],
									[
										24982,
										24987
									],
									[
										24993,
										24998
									],
									[
										25026,
										25031
									],
									[
										25182,
										25187
									],
									[
										25350,
										25355
									],
									[
										25474,
										25479
									],
									[
										25485,
										25490
									],
									[
										25612,
										25617
									],
									[
										25664,
										25669
									],
									[
										25675,
										25680
									],
									[
										25888,
										25893
									],
									[
										26140,
										26145
									],
									[
										26443,
										26448
									],
									[
										26522,
										26527
									],
									[
										26649,
										26654
									],
									[
										26680,
										26685
									],
									[
										26744,
										26749
									],
									[
										26806,
										26811
									],
									[
										26844,
										26849
									],
									[
										26890,
										26895
									],
									[
										26909,
										26914
									],
									[
										26919,
										26924
									],
									[
										26972,
										26977
									],
									[
										27070,
										27075
									],
									[
										27136,
										27141
									],
									[
										27167,
										27172
									],
									[
										27187,
										27192
									],
									[
										27197,
										27202
									],
									[
										27248,
										27253
									],
									[
										27385,
										27390
									],
									[
										27453,
										27458
									],
									[
										27496,
										27501
									],
									[
										27516,
										27521
									],
									[
										27536,
										27541
									],
									[
										27546,
										27551
									],
									[
										27635,
										27640
									],
									[
										27740,
										27745
									],
									[
										27787,
										27792
									],
									[
										27856,
										27861
									],
									[
										28031,
										28036
									],
									[
										28107,
										28112
									],
									[
										28163,
										28168
									],
									[
										28188,
										28193
									],
									[
										28309,
										28314
									],
									[
										28390,
										28395
									],
									[
										28445,
										28450
									],
									[
										28502,
										28507
									],
									[
										28549,
										28554
									],
									[
										28557,
										28562
									],
									[
										28599,
										28604
									],
									[
										28650,
										28655
									],
									[
										28670,
										28675
									],
									[
										28687,
										28692
									],
									[
										28739,
										28744
									],
									[
										28807,
										28812
									],
									[
										28827,
										28832
									],
									[
										28844,
										28849
									],
									[
										28862,
										28867
									],
									[
										28945,
										28950
									],
									[
										29019,
										29024
									],
									[
										29041,
										29046
									],
									[
										29070,
										29075
									],
									[
										29081,
										29086
									],
									[
										29110,
										29115
									],
									[
										29144,
										29149
									],
									[
										29176,
										29181
									],
									[
										29187,
										29192
									],
									[
										29225,
										29230
									],
									[
										29254,
										29259
									],
									[
										29300,
										29305
									],
									[
										29335,
										29340
									],
									[
										29346,
										29351
									],
									[
										29384,
										29389
									],
									[
										29422,
										29427
									],
									[
										29665,
										29670
									],
									[
										29981,
										29986
									],
									[
										30055,
										30060
									],
									[
										30311,
										30316
									],
									[
										30429,
										30434
									],
									[
										30687,
										30692
									],
									[
										30792,
										30797
									],
									[
										31095,
										31100
									],
									[
										31182,
										31187
									],
									[
										31259,
										31264
									],
									[
										31483,
										31488
									],
									[
										31516,
										31521
									],
									[
										31820,
										31825
									],
									[
										31853,
										31858
									],
									[
										32193,
										32198
									],
									[
										32275,
										32280
									],
									[
										32747,
										32752
									],
									[
										33376,
										33381
									],
									[
										33519,
										33524
									],
									[
										33526,
										33531
									],
									[
										34035,
										34040
									],
									[
										34372,
										34377
									],
									[
										34501,
										34506
									],
									[
										34557,
										34562
									],
									[
										34742,
										34747
									],
									[
										34768,
										34773
									],
									[
										34969,
										34974
									],
									[
										34995,
										35000
									],
									[
										35207,
										35212
									],
									[
										35232,
										35237
									],
									[
										35458,
										35463
									],
									[
										35559,
										35564
									],
									[
										35637,
										35642
									],
									[
										35876,
										35881
									],
									[
										35907,
										35912
									],
									[
										36007,
										36012
									],
									[
										36024,
										36029
									],
									[
										36296,
										36301
									],
									[
										36313,
										36318
									],
									[
										36577,
										36582
									],
									[
										36595,
										36600
									],
									[
										36843,
										36848
									],
									[
										36861,
										36866
									],
									[
										37272,
										37277
									],
									[
										37302,
										37307
									],
									[
										37515,
										37520
									],
									[
										37554,
										37559
									],
									[
										37723,
										37728
									],
									[
										37748,
										37753
									],
									[
										37941,
										37946
									],
									[
										38179,
										38184
									],
									[
										38201,
										38206
									],
									[
										38277,
										38282
									],
									[
										38299,
										38304
									],
									[
										38549,
										38554
									],
									[
										38634,
										38639
									],
									[
										38702,
										38707
									],
									[
										38789,
										38794
									],
									[
										38874,
										38879
									],
									[
										38942,
										38947
									],
									[
										39247,
										39252
									],
									[
										39305,
										39310
									],
									[
										39380,
										39385
									],
									[
										39438,
										39443
									],
									[
										39679,
										39684
									],
									[
										39842,
										39847
									],
									[
										40076,
										40081
									],
									[
										40170,
										40175
									],
									[
										40342,
										40347
									],
									[
										40436,
										40441
									],
									[
										40679,
										40684
									],
									[
										40842,
										40847
									],
									[
										41076,
										41081
									],
									[
										41170,
										41175
									],
									[
										41342,
										41347
									],
									[
										41436,
										41441
									],
									[
										41659,
										41664
									],
									[
										41737,
										41742
									],
									[
										41977,
										41982
									],
									[
										42058,
										42063
									],
									[
										42145,
										42150
									],
									[
										42226,
										42231
									],
									[
										42461,
										42466
									],
									[
										42540,
										42545
									],
									[
										42623,
										42628
									],
									[
										42702,
										42707
									],
									[
										42876,
										42881
									],
									[
										42950,
										42955
									],
									[
										43211,
										43216
									],
									[
										43269,
										43274
									],
									[
										43344,
										43349
									],
									[
										43402,
										43407
									],
									[
										43612,
										43617
									],
									[
										43691,
										43696
									],
									[
										43854,
										43859
									],
									[
										44215,
										44220
									],
									[
										44222,
										44227
									],
									[
										44461,
										44466
									],
									[
										44593,
										44598
									],
									[
										44816,
										44821
									],
									[
										44910,
										44915
									],
									[
										44916,
										44921
									],
									[
										44944,
										44949
									],
									[
										45333,
										45338
									],
									[
										45340,
										45345
									],
									[
										45668,
										45673
									],
									[
										45722,
										45727
									],
									[
										46024,
										46029
									],
									[
										46031,
										46036
									],
									[
										46134,
										46139
									],
									[
										46141,
										46146
									],
									[
										46256,
										46261
									],
									[
										46263,
										46268
									],
									[
										46373,
										46378
									],
									[
										46380,
										46385
									],
									[
										46508,
										46513
									],
									[
										46515,
										46520
									],
									[
										46833,
										46838
									],
									[
										47011,
										47016
									],
									[
										47175,
										47180
									],
									[
										47349,
										47354
									],
									[
										47523,
										47528
									],
									[
										47742,
										47747
									],
									[
										47851,
										47856
									],
									[
										47950,
										47955
									],
									[
										47967,
										47972
									],
									[
										48020,
										48025
									],
									[
										48095,
										48100
									],
									[
										48239,
										48244
									],
									[
										48381,
										48386
									],
									[
										48398,
										48403
									],
									[
										48451,
										48456
									],
									[
										48697,
										48702
									],
									[
										48912,
										48917
									],
									[
										48976,
										48981
									],
									[
										49073,
										49078
									],
									[
										49095,
										49100
									],
									[
										49147,
										49152
									],
									[
										49217,
										49222
									],
									[
										49251,
										49256
									],
									[
										49308,
										49313
									],
									[
										49542,
										49547
									],
									[
										49676,
										49681
									],
									[
										49799,
										49804
									],
									[
										49870,
										49875
									],
									[
										49934,
										49939
									],
									[
										49997,
										50002
									],
									[
										50087,
										50092
									],
									[
										50144,
										50149
									],
									[
										50270,
										50275
									],
									[
										50459,
										50464
									],
									[
										50541,
										50546
									],
									[
										50837,
										50842
									],
									[
										50869,
										50874
									],
									[
										51202,
										51207
									],
									[
										51432,
										51437
									],
									[
										51584,
										51589
									],
									[
										51811,
										51816
									],
									[
										52109,
										52114
									],
									[
										52282,
										52287
									],
									[
										52624,
										52629
									],
									[
										52716,
										52721
									],
									[
										53288,
										53293
									],
									[
										54056,
										54061
									],
									[
										54063,
										54068
									],
									[
										54806,
										54811
									],
									[
										54945,
										54950
									],
									[
										55271,
										55276
									],
									[
										55293,
										55298
									],
									[
										55740,
										55745
									],
									[
										55990,
										55995
									],
									[
										56127,
										56132
									],
									[
										56411,
										56416
									],
									[
										56460,
										56465
									],
									[
										56675,
										56680
									],
									[
										56817,
										56822
									],
									[
										57045,
										57050
									],
									[
										57335,
										57340
									],
									[
										57552,
										57557
									],
									[
										57803,
										57808
									],
									[
										58061,
										58066
									],
									[
										58135,
										58140
									],
									[
										58410,
										58415
									],
									[
										58675,
										58680
									],
									[
										58682,
										58687
									],
									[
										58773,
										58778
									],
									[
										58780,
										58785
									],
									[
										59155,
										59160
									],
									[
										59287,
										59292
									],
									[
										59466,
										59471
									],
									[
										59581,
										59586
									],
									[
										59587,
										59592
									],
									[
										59615,
										59620
									],
									[
										59669,
										59674
									],
									[
										59780,
										59785
									],
									[
										59786,
										59791
									],
									[
										59814,
										59819
									],
									[
										60083,
										60088
									],
									[
										60115,
										60120
									],
									[
										60403,
										60408
									],
									[
										60449,
										60454
									],
									[
										60878,
										60883
									],
									[
										60910,
										60915
									],
									[
										60950,
										60955
									],
									[
										61013,
										61018
									],
									[
										61264,
										61269
									],
									[
										61328,
										61333
									],
									[
										61510,
										61515
									],
									[
										61523,
										61528
									],
									[
										61563,
										61568
									],
									[
										61594,
										61599
									],
									[
										61700,
										61705
									],
									[
										61815,
										61820
									],
									[
										61826,
										61831
									],
									[
										61863,
										61868
									],
									[
										61894,
										61899
									],
									[
										61990,
										61995
									],
									[
										62020,
										62025
									],
									[
										62104,
										62109
									],
									[
										62114,
										62119
									],
									[
										62154,
										62159
									],
									[
										62281,
										62286
									],
									[
										62292,
										62297
									],
									[
										62380,
										62385
									],
									[
										62390,
										62395
									],
									[
										62430,
										62435
									],
									[
										62556,
										62561
									],
									[
										62583,
										62588
									],
									[
										62736,
										62741
									],
									[
										62770,
										62775
									],
									[
										62815,
										62820
									],
									[
										63046,
										63051
									],
									[
										63448,
										63453
									],
									[
										63747,
										63752
									],
									[
										63815,
										63820
									],
									[
										63886,
										63891
									],
									[
										63944,
										63949
									],
									[
										64157,
										64162
									],
									[
										64173,
										64178
									],
									[
										64225,
										64230
									],
									[
										64449,
										64454
									],
									[
										64462,
										64467
									],
									[
										64534,
										64539
									],
									[
										64567,
										64572
									],
									[
										64772,
										64777
									],
									[
										64790,
										64795
									],
									[
										65086,
										65091
									],
									[
										65171,
										65176
									],
									[
										65195,
										65200
									],
									[
										65209,
										65214
									],
									[
										65233,
										65238
									],
									[
										65378,
										65383
									],
									[
										65407,
										65412
									],
									[
										65492,
										65497
									],
									[
										65505,
										65510
									],
									[
										65575,
										65580
									],
									[
										65592,
										65597
									],
									[
										65606,
										65611
									],
									[
										65623,
										65628
									],
									[
										65867,
										65872
									],
									[
										65879,
										65884
									],
									[
										65981,
										65986
									],
									[
										66011,
										66016
									],
									[
										66062,
										66067
									],
									[
										66075,
										66080
									],
									[
										66191,
										66196
									],
									[
										66204,
										66209
									],
									[
										66544,
										66549
									],
									[
										66558,
										66563
									],
									[
										66844,
										66849
									],
									[
										66869,
										66874
									],
									[
										67018,
										67023
									],
									[
										67043,
										67048
									],
									[
										67441,
										67446
									],
									[
										67806,
										67811
									],
									[
										67858,
										67863
									],
									[
										68087,
										68092
									],
									[
										68208,
										68213
									],
									[
										68235,
										68240
									],
									[
										68279,
										68284
									],
									[
										68458,
										68463
									],
									[
										68579,
										68584
									],
									[
										68707,
										68712
									],
									[
										68764,
										68769
									],
									[
										68994,
										68999
									],
									[
										69016,
										69021
									],
									[
										69081,
										69086
									],
									[
										69100,
										69105
									],
									[
										69336,
										69341
									],
									[
										69382,
										69387
									],
									[
										69452,
										69457
									],
									[
										69498,
										69503
									],
									[
										69669,
										69674
									],
									[
										69715,
										69720
									],
									[
										69789,
										69794
									],
									[
										69837,
										69842
									],
									[
										70002,
										70007
									],
									[
										70050,
										70055
									],
									[
										70130,
										70135
									],
									[
										70176,
										70181
									],
									[
										70337,
										70342
									],
									[
										70391,
										70396
									],
									[
										70436,
										70441
									],
									[
										70561,
										70566
									],
									[
										70662,
										70667
									],
									[
										70716,
										70721
									],
									[
										70761,
										70766
									],
									[
										70942,
										70947
									],
									[
										71054,
										71059
									],
									[
										71092,
										71097
									],
									[
										71126,
										71131
									],
									[
										71174,
										71179
									],
									[
										71324,
										71329
									],
									[
										71337,
										71342
									],
									[
										71426,
										71431
									],
									[
										71442,
										71447
									],
									[
										71532,
										71537
									],
									[
										71550,
										71555
									],
									[
										71573,
										71578
									],
									[
										71619,
										71624
									],
									[
										71641,
										71646
									],
									[
										71701,
										71706
									],
									[
										71710,
										71715
									],
									[
										71717,
										71722
									],
									[
										71825,
										71830
									],
									[
										71848,
										71853
									],
									[
										71980,
										71985
									],
									[
										72019,
										72024
									],
									[
										72034,
										72039
									],
									[
										72061,
										72066
									],
									[
										72095,
										72100
									],
									[
										72158,
										72163
									],
									[
										72180,
										72185
									],
									[
										72241,
										72246
									],
									[
										72259,
										72264
									],
									[
										72305,
										72310
									],
									[
										72353,
										72358
									],
									[
										72414,
										72419
									],
									[
										72431,
										72436
									],
									[
										72480,
										72485
									],
									[
										72539,
										72544
									],
									[
										72561,
										72566
									],
									[
										72634,
										72639
									],
									[
										72715,
										72720
									],
									[
										72865,
										72870
									],
									[
										72959,
										72964
									],
									[
										73101,
										73106
									],
									[
										73114,
										73119
									],
									[
										73185,
										73190
									],
									[
										73240,
										73245
									],
									[
										73330,
										73335
									],
									[
										73346,
										73351
									],
									[
										73503,
										73508
									],
									[
										73512,
										73517
									],
									[
										73519,
										73524
									],
									[
										73555,
										73560
									],
									[
										73561,
										73566
									],
									[
										73591,
										73596
									],
									[
										73604,
										73609
									],
									[
										73664,
										73669
									],
									[
										73680,
										73685
									],
									[
										73687,
										73692
									],
									[
										73734,
										73739
									],
									[
										73784,
										73789
									],
									[
										73861,
										73866
									],
									[
										74055,
										74060
									],
									[
										74087,
										74092
									],
									[
										74252,
										74257
									],
									[
										74650,
										74655
									],
									[
										74696,
										74701
									],
									[
										74964,
										74969
									],
									[
										75217,
										75222
									],
									[
										75411,
										75416
									],
									[
										75462,
										75467
									],
									[
										75612,
										75617
									],
									[
										75852,
										75857
									],
									[
										75953,
										75958
									],
									[
										75959,
										75964
									],
									[
										75986,
										75991
									],
									[
										76311,
										76316
									],
									[
										76546,
										76551
									],
									[
										76603,
										76608
									],
									[
										76719,
										76724
									],
									[
										76740,
										76745
									],
									[
										76783,
										76788
									],
									[
										76868,
										76873
									],
									[
										76983,
										76988
									],
									[
										77298,
										77303
									],
									[
										77466,
										77471
									],
									[
										77506,
										77511
									],
									[
										77784,
										77789
									],
									[
										78057,
										78062
									],
									[
										78438,
										78443
									],
									[
										78666,
										78671
									],
									[
										78957,
										78962
									],
									[
										79069,
										79074
									],
									[
										79088,
										79093
									],
									[
										79210,
										79215
									],
									[
										79348,
										79353
									],
									[
										79367,
										79372
									],
									[
										79490,
										79495
									],
									[
										79666,
										79671
									],
									[
										79685,
										79690
									],
									[
										79838,
										79843
									],
									[
										79976,
										79981
									],
									[
										79995,
										80000
									],
									[
										80226,
										80231
									],
									[
										80299,
										80304
									],
									[
										80434,
										80439
									],
									[
										80461,
										80466
									],
									[
										80511,
										80516
									],
									[
										80550,
										80555
									],
									[
										80610,
										80615
									],
									[
										80642,
										80647
									],
									[
										80731,
										80736
									],
									[
										80829,
										80834
									],
									[
										80917,
										80922
									],
									[
										80957,
										80962
									],
									[
										80996,
										81001
									],
									[
										81044,
										81049
									],
									[
										81085,
										81090
									],
									[
										81124,
										81129
									],
									[
										81398,
										81403
									],
									[
										81615,
										81620
									],
									[
										81631,
										81636
									],
									[
										81669,
										81674
									],
									[
										81675,
										81680
									],
									[
										81700,
										81705
									],
									[
										81944,
										81949
									],
									[
										82156,
										82161
									],
									[
										82185,
										82190
									],
									[
										82358,
										82363
									],
									[
										82380,
										82385
									],
									[
										82437,
										82442
									],
									[
										82666,
										82671
									],
									[
										82920,
										82925
									],
									[
										83020,
										83025
									],
									[
										83238,
										83243
									],
									[
										83302,
										83307
									],
									[
										83395,
										83400
									],
									[
										83680,
										83685
									],
									[
										83957,
										83962
									],
									[
										84119,
										84124
									],
									[
										84219,
										84224
									],
									[
										84437,
										84442
									],
									[
										84691,
										84696
									],
									[
										84702,
										84707
									],
									[
										84869,
										84874
									],
									[
										84898,
										84903
									],
									[
										84994,
										84999
									],
									[
										85003,
										85008
									],
									[
										85031,
										85036
									],
									[
										85065,
										85070
									],
									[
										85093,
										85098
									],
									[
										85177,
										85182
									],
									[
										85417,
										85422
									],
									[
										85720,
										85725
									],
									[
										85894,
										85899
									],
									[
										86095,
										86100
									],
									[
										86285,
										86290
									],
									[
										86483,
										86488
									],
									[
										86689,
										86694
									],
									[
										86903,
										86908
									],
									[
										87125,
										87130
									],
									[
										87355,
										87360
									],
									[
										87595,
										87600
									],
									[
										87847,
										87852
									],
									[
										88109,
										88114
									],
									[
										88381,
										88386
									],
									[
										88663,
										88668
									],
									[
										88955,
										88960
									],
									[
										89257,
										89262
									],
									[
										89569,
										89574
									],
									[
										89891,
										89896
									],
									[
										90223,
										90228
									],
									[
										90567,
										90572
									],
									[
										90760,
										90765
									],
									[
										90928,
										90933
									],
									[
										91071,
										91076
									],
									[
										91311,
										91316
									],
									[
										91408,
										91413
									],
									[
										91417,
										91422
									],
									[
										91448,
										91453
									],
									[
										91457,
										91462
									],
									[
										91477,
										91482
									],
									[
										91556,
										91561
									],
									[
										91576,
										91581
									],
									[
										91773,
										91778
									],
									[
										91789,
										91794
									],
									[
										91819,
										91824
									],
									[
										91860,
										91865
									],
									[
										92143,
										92148
									],
									[
										92375,
										92380
									],
									[
										92414,
										92419
									],
									[
										92443,
										92448
									],
									[
										92654,
										92659
									],
									[
										92845,
										92850
									],
									[
										93155,
										93160
									],
									[
										93343,
										93348
									],
									[
										93398,
										93403
									],
									[
										93650,
										93655
									],
									[
										93666,
										93671
									],
									[
										93673,
										93678
									],
									[
										93720,
										93725
									],
									[
										93796,
										93801
									],
									[
										94017,
										94022
									],
									[
										94221,
										94226
									],
									[
										94556,
										94561
									],
									[
										94733,
										94738
									],
									[
										94773,
										94778
									],
									[
										94823,
										94828
									],
									[
										94882,
										94887
									],
									[
										94954,
										94959
									],
									[
										95193,
										95198
									],
									[
										95204,
										95209
									],
									[
										95400,
										95405
									],
									[
										95441,
										95446
									],
									[
										95636,
										95641
									],
									[
										95832,
										95837
									],
									[
										95883,
										95888
									],
									[
										96035,
										96040
									],
									[
										96275,
										96280
									],
									[
										96376,
										96381
									],
									[
										96382,
										96387
									],
									[
										96409,
										96414
									],
									[
										96717,
										96722
									],
									[
										96960,
										96965
									],
									[
										97216,
										97221
									],
									[
										97506,
										97511
									],
									[
										97584,
										97589
									],
									[
										97808,
										97813
									],
									[
										97919,
										97924
									],
									[
										98101,
										98106
									],
									[
										98112,
										98117
									],
									[
										98308,
										98313
									],
									[
										98349,
										98354
									],
									[
										98632,
										98637
									],
									[
										98778,
										98783
									],
									[
										98904,
										98909
									],
									[
										98920,
										98925
									],
									[
										98927,
										98932
									],
									[
										98974,
										98979
									],
									[
										99101,
										99106
									],
									[
										99112,
										99117
									],
									[
										99215,
										99220
									],
									[
										99423,
										99428
									],
									[
										99567,
										99572
									],
									[
										99599,
										99604
									],
									[
										99773,
										99778
									],
									[
										99810,
										99815
									],
									[
										99839,
										99844
									],
									[
										99931,
										99936
									],
									[
										100063,
										100068
									],
									[
										100208,
										100213
									],
									[
										100458,
										100463
									],
									[
										100679,
										100684
									],
									[
										100912,
										100917
									],
									[
										101018,
										101023
									],
									[
										101031,
										101036
									],
									[
										101069,
										101074
									],
									[
										101204,
										101209
									],
									[
										101215,
										101220
									],
									[
										101334,
										101339
									],
									[
										101581,
										101586
									],
									[
										101670,
										101675
									],
									[
										101728,
										101733
									],
									[
										101795,
										101800
									],
									[
										101911,
										101916
									],
									[
										102145,
										102150
									],
									[
										102240,
										102245
									],
									[
										102650,
										102655
									],
									[
										102963,
										102968
									],
									[
										103011,
										103016
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								13235,
								13235
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"output_tag": 3,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 1610.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/common/Base.scala",
					"settings":
					{
						"buffer_size": 3417,
						"regions":
						{
						},
						"selection":
						[
							[
								514,
								514
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 270.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/common/Structs.scala",
					"settings":
					{
						"buffer_size": 17319,
						"regions":
						{
						},
						"selection":
						[
							[
								32,
								32
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1440.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/common/ArrayOps.scala",
					"settings":
					{
						"buffer_size": 18471,
						"regions":
						{
						},
						"selection":
						[
							[
								132,
								132
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 90.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/internal/Expressions.scala",
					"settings":
					{
						"buffer_size": 12343,
						"regions":
						{
						},
						"selection":
						[
							[
								7555,
								7555
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3645.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/common/While.scala",
					"settings":
					{
						"buffer_size": 6465,
						"regions":
						{
						},
						"selection":
						[
							[
								3945,
								3945
							]
						],
						"settings":
						{
							"syntax": "Packages/Scala/Scala.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 810.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"fat",
				"src/internal/FatExpressions.scala"
			],
			[
				"effect",
				"test-src/epfl/test3-parsers/Effects.scala"
			],
			[
				"hash",
				"src/common/HashCodeOps.scala"
			],
			[
				"arr",
				"src/common/ArrayOps.scala"
			],
			[
				"array",
				"src/common/ArrayOps.scala"
			],
			[
				"eff",
				"src/internal/Effects.scala"
			],
			[
				"effects",
				"src/internal/Effects.scala"
			],
			[
				"var",
				"src/common/Variables.scala"
			],
			[
				"pa",
				"src/common/Packages.scala"
			],
			[
				"pack",
				"src/common/Packages.scala"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 266.0,
	"status_bar_visible": true
}
